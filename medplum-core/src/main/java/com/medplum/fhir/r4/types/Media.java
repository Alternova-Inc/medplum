/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

/**
 * A photo, video, or audio recording acquired or used in healthcare. The
 * actual content may be inline or provided by direct reference.
 */
public class Media extends FhirResource {
    public static final String RESOURCE_TYPE = "Media";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_EXTENSION = "extension";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_BASED_ON = "basedOn";
    public static final String PROPERTY_PART_OF = "partOf";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_MODALITY = "modality";
    public static final String PROPERTY_VIEW = "view";
    public static final String PROPERTY_SUBJECT = "subject";
    public static final String PROPERTY_ENCOUNTER = "encounter";
    public static final String PROPERTY_CREATED_DATE_TIME = "createdDateTime";
    public static final String PROPERTY_CREATED_PERIOD = "createdPeriod";
    public static final String PROPERTY_ISSUED = "issued";
    public static final String PROPERTY_OPERATOR = "operator";
    public static final String PROPERTY_REASON_CODE = "reasonCode";
    public static final String PROPERTY_BODY_SITE = "bodySite";
    public static final String PROPERTY_DEVICE_NAME = "deviceName";
    public static final String PROPERTY_DEVICE = "device";
    public static final String PROPERTY_HEIGHT = "height";
    public static final String PROPERTY_WIDTH = "width";
    public static final String PROPERTY_FRAMES = "frames";
    public static final String PROPERTY_DURATION = "duration";
    public static final String PROPERTY_CONTENT = "content";
    public static final String PROPERTY_NOTE = "note";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Media(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public java.net.URI implicitRules() {
        return getUri(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Identifiers associated with the image - these may include identifiers
     * for the image itself, identifiers for the context of its collection
     * (e.g. series ids) and context ids such as accession numbers or other
     * workflow identifiers.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * A procedure that is fulfilled in whole or in part by the creation of
     * this media.
     */
    public java.util.List<Reference> basedOn() {
        return getList(Reference.class, PROPERTY_BASED_ON);
    }

    /**
     * A larger event of which this particular event is a component or step.
     */
    public java.util.List<Reference> partOf() {
        return getList(Reference.class, PROPERTY_PART_OF);
    }

    /**
     * The current state of the {{title}}.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * A code that classifies whether the media is an image, video or audio
     * recording or some other media category.
     */
    public CodeableConcept type() {
        return getObject(CodeableConcept.class, PROPERTY_TYPE);
    }

    /**
     * Details of the type of the media - usually, how it was acquired (what
     * type of device). If images sourced from a DICOM system, are wrapped in
     * a Media resource, then this is the modality.
     */
    public CodeableConcept modality() {
        return getObject(CodeableConcept.class, PROPERTY_MODALITY);
    }

    /**
     * The name of the imaging view e.g. Lateral or Antero-posterior (AP).
     */
    public CodeableConcept view() {
        return getObject(CodeableConcept.class, PROPERTY_VIEW);
    }

    /**
     * Who/What this Media is a record of.
     */
    public Reference subject() {
        return getObject(Reference.class, PROPERTY_SUBJECT);
    }

    /**
     * The encounter that establishes the context for this media.
     */
    public Reference encounter() {
        return getObject(Reference.class, PROPERTY_ENCOUNTER);
    }

    /**
     * The date and time(s) at which the media was collected.
     */
    public String createdDateTime() {
        return getString(PROPERTY_CREATED_DATE_TIME);
    }

    /**
     * The date and time(s) at which the media was collected.
     */
    public Period createdPeriod() {
        return getObject(Period.class, PROPERTY_CREATED_PERIOD);
    }

    /**
     * The date and time this version of the media was made available to
     * providers, typically after having been reviewed.
     */
    public java.time.Instant issued() {
        return getInstant(PROPERTY_ISSUED);
    }

    /**
     * The person who administered the collection of the image.
     */
    public Reference operator() {
        return getObject(Reference.class, PROPERTY_OPERATOR);
    }

    /**
     * Describes why the event occurred in coded or textual form.
     */
    public java.util.List<CodeableConcept> reasonCode() {
        return getList(CodeableConcept.class, PROPERTY_REASON_CODE);
    }

    /**
     * Indicates the site on the subject's body where the observation was
     * made (i.e. the target site).
     */
    public CodeableConcept bodySite() {
        return getObject(CodeableConcept.class, PROPERTY_BODY_SITE);
    }

    /**
     * The name of the device / manufacturer of the device  that was used to
     * make the recording.
     */
    public String deviceName() {
        return getString(PROPERTY_DEVICE_NAME);
    }

    /**
     * The device used to collect the media.
     */
    public Reference device() {
        return getObject(Reference.class, PROPERTY_DEVICE);
    }

    /**
     * Height of the image in pixels (photo/video).
     */
    public Integer height() {
        return data.getInt(PROPERTY_HEIGHT);
    }

    /**
     * Width of the image in pixels (photo/video).
     */
    public Integer width() {
        return data.getInt(PROPERTY_WIDTH);
    }

    /**
     * The number of frames in a photo. This is used with a multi-page fax,
     * or an imaging acquisition context that takes multiple slices in a
     * single image, or an animated gif. If there is more than one frame,
     * this SHALL have a value in order to alert interface software that a
     * multi-frame capable rendering widget is required.
     */
    public Integer frames() {
        return data.getInt(PROPERTY_FRAMES);
    }

    /**
     * The duration of the recording in seconds - for audio and video.
     */
    public Double duration() {
        return data.getJsonNumber(PROPERTY_DURATION).doubleValue();
    }

    /**
     * The actual content of the media - inline or by direct reference to the
     * media source file.
     */
    public Attachment content() {
        return getObject(Attachment.class, PROPERTY_CONTENT);
    }

    /**
     * Comments made about the media by the performer, subject or other
     * participants.
     */
    public java.util.List<Annotation> note() {
        return getList(Annotation.class, PROPERTY_NOTE);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final java.net.URI implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules.toString());
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder basedOn(final java.util.List<Reference> basedOn) {
            b.add(PROPERTY_BASED_ON, FhirObject.toArray(basedOn));
            return this;
        }

        public Builder partOf(final java.util.List<Reference> partOf) {
            b.add(PROPERTY_PART_OF, FhirObject.toArray(partOf));
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder type(final CodeableConcept type) {
            b.add(PROPERTY_TYPE, type);
            return this;
        }

        public Builder modality(final CodeableConcept modality) {
            b.add(PROPERTY_MODALITY, modality);
            return this;
        }

        public Builder view(final CodeableConcept view) {
            b.add(PROPERTY_VIEW, view);
            return this;
        }

        public Builder subject(final Reference subject) {
            b.add(PROPERTY_SUBJECT, subject);
            return this;
        }

        public Builder encounter(final Reference encounter) {
            b.add(PROPERTY_ENCOUNTER, encounter);
            return this;
        }

        public Builder createdDateTime(final String createdDateTime) {
            b.add(PROPERTY_CREATED_DATE_TIME, createdDateTime);
            return this;
        }

        public Builder createdPeriod(final Period createdPeriod) {
            b.add(PROPERTY_CREATED_PERIOD, createdPeriod);
            return this;
        }

        public Builder issued(final java.time.Instant issued) {
            b.add(PROPERTY_ISSUED, issued.toString());
            return this;
        }

        public Builder operator(final Reference operator) {
            b.add(PROPERTY_OPERATOR, operator);
            return this;
        }

        public Builder reasonCode(final java.util.List<CodeableConcept> reasonCode) {
            b.add(PROPERTY_REASON_CODE, FhirObject.toArray(reasonCode));
            return this;
        }

        public Builder bodySite(final CodeableConcept bodySite) {
            b.add(PROPERTY_BODY_SITE, bodySite);
            return this;
        }

        public Builder deviceName(final String deviceName) {
            b.add(PROPERTY_DEVICE_NAME, deviceName);
            return this;
        }

        public Builder device(final Reference device) {
            b.add(PROPERTY_DEVICE, device);
            return this;
        }

        public Builder height(final Integer height) {
            b.add(PROPERTY_HEIGHT, height);
            return this;
        }

        public Builder width(final Integer width) {
            b.add(PROPERTY_WIDTH, width);
            return this;
        }

        public Builder frames(final Integer frames) {
            b.add(PROPERTY_FRAMES, frames);
            return this;
        }

        public Builder duration(final Double duration) {
            b.add(PROPERTY_DURATION, duration);
            return this;
        }

        public Builder content(final Attachment content) {
            b.add(PROPERTY_CONTENT, content);
            return this;
        }

        public Builder note(final java.util.List<Annotation> note) {
            b.add(PROPERTY_NOTE, FhirObject.toArray(note));
            return this;
        }

        public Media build() {
            return new Media(b.build());
        }
    }
}
