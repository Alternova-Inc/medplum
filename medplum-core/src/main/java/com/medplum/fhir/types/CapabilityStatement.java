/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class CapabilityStatement extends FhirResource {
    public static final String RESOURCE_TYPE = "CapabilityStatement";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_EXTENSION = "extension";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_URL = "url";
    public static final String PROPERTY_VERSION = "version";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_TITLE = "title";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_EXPERIMENTAL = "experimental";
    public static final String PROPERTY_DATE = "date";
    public static final String PROPERTY_PUBLISHER = "publisher";
    public static final String PROPERTY_CONTACT = "contact";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_USE_CONTEXT = "useContext";
    public static final String PROPERTY_JURISDICTION = "jurisdiction";
    public static final String PROPERTY_PURPOSE = "purpose";
    public static final String PROPERTY_COPYRIGHT = "copyright";
    public static final String PROPERTY_KIND = "kind";
    public static final String PROPERTY_INSTANTIATES = "instantiates";
    public static final String PROPERTY_IMPORTS = "imports";
    public static final String PROPERTY_SOFTWARE = "software";
    public static final String PROPERTY_IMPLEMENTATION = "implementation";
    public static final String PROPERTY_FHIR_VERSION = "fhirVersion";
    public static final String PROPERTY_FORMAT = "format";
    public static final String PROPERTY_PATCH_FORMAT = "patchFormat";
    public static final String PROPERTY_IMPLEMENTATION_GUIDE = "implementationGuide";
    public static final String PROPERTY_REST = "rest";
    public static final String PROPERTY_MESSAGING = "messaging";
    public static final String PROPERTY_DOCUMENT = "document";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public CapabilityStatement(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * An absolute URI that is used to identify this capability statement
     * when it is referenced in a specification, model, design or an
     * instance; also called its canonical identifier. This SHOULD be
     * globally unique and SHOULD be a literal address at which at which an
     * authoritative instance of this capability statement is (or will be)
     * published. This URL can be the target of a canonical reference. It
     * SHALL remain the same when the capability statement is stored on
     * different servers.
     */
    public String url() {
        return getString(PROPERTY_URL);
    }

    /**
     * The identifier that is used to identify this version of the capability
     * statement when it is referenced in a specification, model, design or
     * instance. This is an arbitrary value managed by the capability
     * statement author and is not expected to be globally unique. For
     * example, it might be a timestamp (e.g. yyyymmdd) if a managed version
     * is not available. There is also no expectation that versions can be
     * placed in a lexicographical sequence.
     */
    public String version() {
        return getString(PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the capability statement. This
     * name should be usable as an identifier for the module by machine
     * processing applications such as code generation.
     */
    public String name() {
        return getString(PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the capability
     * statement.
     */
    public String title() {
        return getString(PROPERTY_TITLE);
    }

    /**
     * The status of this capability statement. Enables tracking the
     * life-cycle of the content.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this capability statement is authored
     * for testing purposes (or education/evaluation/marketing) and is not
     * intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the capability statement was
     * published. The date must change when the business version changes and
     * it must change if the status code changes. In addition, it should
     * change when the substantive content of the capability statement
     * changes.
     */
    public java.time.Instant date() {
        return java.time.Instant.parse(data.getString(PROPERTY_DATE));
    }

    /**
     * The name of the organization or individual that published the
     * capability statement.
     */
    public String publisher() {
        return getString(PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the capability statement
     * from a consumer's perspective. Typically, this is used when the
     * capability statement describes a desired rather than an actual
     * solution, for example as a formal expression of requirements as part
     * of an RFP.
     */
    public String description() {
        return getString(PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate capability statement instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the capability statement is
     * intended to be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this capability statement is needed and why it has
     * been designed as it has.
     */
    public String purpose() {
        return getString(PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the capability statement and/or its
     * contents. Copyright statements are generally legal restrictions on the
     * use and publishing of the capability statement.
     */
    public String copyright() {
        return getString(PROPERTY_COPYRIGHT);
    }

    /**
     * The way that this statement is intended to be used, to describe an
     * actual running instance of software, a particular product (kind, not
     * instance of software) or a class of implementation (e.g. a desired
     * purchase).
     */
    public String kind() {
        return getString(PROPERTY_KIND);
    }

    /**
     * Reference to a canonical URL of another CapabilityStatement that this
     * software implements. This capability statement is a published API
     * description that corresponds to a business service. The server may
     * actually implement a subset of the capability statement it claims to
     * implement, so the capability statement must specify the full
     * capability details.
     */
    public java.util.List<String> instantiates() {
        return getList(String.class, PROPERTY_INSTANTIATES);
    }

    /**
     * Reference to a canonical URL of another CapabilityStatement that this
     * software adds to. The capability statement automatically includes
     * everything in the other statement, and it is not duplicated, though
     * the server may repeat the same resources, interactions and operations
     * to add additional details to them.
     */
    public java.util.List<String> imports() {
        return getList(String.class, PROPERTY_IMPORTS);
    }

    /**
     * Software that is covered by this capability statement.  It is used
     * when the capability statement describes the capabilities of a
     * particular software version, independent of an installation.
     */
    public CapabilityStatementSoftware software() {
        return getObject(CapabilityStatementSoftware.class, PROPERTY_SOFTWARE);
    }

    /**
     * Identifies a specific implementation instance that is described by the
     * capability statement - i.e. a particular installation, rather than the
     * capabilities of a software program.
     */
    public CapabilityStatementImplementation implementation() {
        return getObject(CapabilityStatementImplementation.class, PROPERTY_IMPLEMENTATION);
    }

    /**
     * The version of the FHIR specification that this CapabilityStatement
     * describes (which SHALL be the same as the FHIR version of the
     * CapabilityStatement itself). There is no default value.
     */
    public String fhirVersion() {
        return getString(PROPERTY_FHIR_VERSION);
    }

    /**
     * A list of the formats supported by this implementation using their
     * content types.
     */
    public java.util.List<String> format() {
        return getList(String.class, PROPERTY_FORMAT);
    }

    /**
     * A list of the patch formats supported by this implementation using
     * their content types.
     */
    public java.util.List<String> patchFormat() {
        return getList(String.class, PROPERTY_PATCH_FORMAT);
    }

    /**
     * A list of implementation guides that the server does (or should)
     * support in their entirety.
     */
    public java.util.List<String> implementationGuide() {
        return getList(String.class, PROPERTY_IMPLEMENTATION_GUIDE);
    }

    /**
     * A definition of the restful capabilities of the solution, if any.
     */
    public java.util.List<CapabilityStatementRest> rest() {
        return getList(CapabilityStatementRest.class, PROPERTY_REST);
    }

    /**
     * A description of the messaging capabilities of the solution.
     */
    public java.util.List<CapabilityStatementMessaging> messaging() {
        return getList(CapabilityStatementMessaging.class, PROPERTY_MESSAGING);
    }

    /**
     * A document definition.
     */
    public java.util.List<CapabilityStatementDocument> document() {
        return getList(CapabilityStatementDocument.class, PROPERTY_DOCUMENT);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder url(final String url) {
            b.add(PROPERTY_URL, url);
            return this;
        }

        public Builder version(final String version) {
            b.add(PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder kind(final String kind) {
            b.add(PROPERTY_KIND, kind);
            return this;
        }

        public Builder instantiates(final java.util.List<String> instantiates) {
            b.add(PROPERTY_INSTANTIATES, FhirObject.toStringArray(instantiates));
            return this;
        }

        public Builder imports(final java.util.List<String> imports) {
            b.add(PROPERTY_IMPORTS, FhirObject.toStringArray(imports));
            return this;
        }

        public Builder software(final CapabilityStatementSoftware software) {
            b.add(PROPERTY_SOFTWARE, software);
            return this;
        }

        public Builder implementation(final CapabilityStatementImplementation implementation) {
            b.add(PROPERTY_IMPLEMENTATION, implementation);
            return this;
        }

        public Builder fhirVersion(final String fhirVersion) {
            b.add(PROPERTY_FHIR_VERSION, fhirVersion);
            return this;
        }

        public Builder format(final java.util.List<String> format) {
            b.add(PROPERTY_FORMAT, FhirObject.toStringArray(format));
            return this;
        }

        public Builder patchFormat(final java.util.List<String> patchFormat) {
            b.add(PROPERTY_PATCH_FORMAT, FhirObject.toStringArray(patchFormat));
            return this;
        }

        public Builder implementationGuide(final java.util.List<String> implementationGuide) {
            b.add(PROPERTY_IMPLEMENTATION_GUIDE, FhirObject.toStringArray(implementationGuide));
            return this;
        }

        public Builder rest(final java.util.List<CapabilityStatementRest> rest) {
            b.add(PROPERTY_REST, FhirObject.toArray(rest));
            return this;
        }

        public Builder messaging(final java.util.List<CapabilityStatementMessaging> messaging) {
            b.add(PROPERTY_MESSAGING, FhirObject.toArray(messaging));
            return this;
        }

        public Builder document(final java.util.List<CapabilityStatementDocument> document) {
            b.add(PROPERTY_DOCUMENT, FhirObject.toArray(document));
            return this;
        }

        public CapabilityStatement build() {
            return new CapabilityStatement(b.build());
        }
    }

    public static class CapabilityStatementDocument extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementDocument";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_MODE = "mode";
        public static final String PROPERTY_DOCUMENTATION = "documentation";
        public static final String PROPERTY_PROFILE = "profile";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementDocument(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Mode of this document declaration - whether an application is a
         * producer or consumer.
         */
        public String mode() {
            return getString(PROPERTY_MODE);
        }

        /**
         * A description of how the application supports or uses the specified
         * document profile.  For example, when documents are created, what
         * action is taken with consumed documents, etc.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        /**
         * A profile on the document Bundle that constrains which resources are
         * present, and their contents.
         */
        public String profile() {
            return getString(PROPERTY_PROFILE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder profile(final String profile) {
                b.add(PROPERTY_PROFILE, profile);
                return this;
            }

            public CapabilityStatementDocument build() {
                return new CapabilityStatementDocument(b.build());
            }
        }
    }

    public static class CapabilityStatementEndpoint extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementEndpoint";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_PROTOCOL = "protocol";
        public static final String PROPERTY_ADDRESS = "address";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementEndpoint(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A list of the messaging transport protocol(s) identifiers, supported
         * by this endpoint.
         */
        public Coding protocol() {
            return getObject(Coding.class, PROPERTY_PROTOCOL);
        }

        /**
         * The network address of the endpoint. For solutions that do not use
         * network addresses for routing, it can be just an identifier.
         */
        public String address() {
            return getString(PROPERTY_ADDRESS);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder protocol(final Coding protocol) {
                b.add(PROPERTY_PROTOCOL, protocol);
                return this;
            }

            public Builder address(final String address) {
                b.add(PROPERTY_ADDRESS, address);
                return this;
            }

            public CapabilityStatementEndpoint build() {
                return new CapabilityStatementEndpoint(b.build());
            }
        }
    }

    public static class CapabilityStatementImplementation extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementImplementation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_URL = "url";
        public static final String PROPERTY_CUSTODIAN = "custodian";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementImplementation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about the specific installation that this capability
         * statement relates to.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * An absolute base URL for the implementation.  This forms the base for
         * REST interfaces as well as the mailbox and document interfaces.
         */
        public String url() {
            return getString(PROPERTY_URL);
        }

        /**
         * The organization responsible for the management of the instance and
         * oversight of the data on the server at the specified URL.
         */
        public Reference custodian() {
            return getObject(Reference.class, PROPERTY_CUSTODIAN);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder url(final String url) {
                b.add(PROPERTY_URL, url);
                return this;
            }

            public Builder custodian(final Reference custodian) {
                b.add(PROPERTY_CUSTODIAN, custodian);
                return this;
            }

            public CapabilityStatementImplementation build() {
                return new CapabilityStatementImplementation(b.build());
            }
        }
    }

    public static class CapabilityStatementInteraction extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementInteraction";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementInteraction(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Coded identifier of the operation, supported by the system resource.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * Guidance specific to the implementation of this operation, such as
         * 'delete is a logical delete' or 'updates are only allowed with version
         * id' or 'creates permitted from pre-authorized certificates only'.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementInteraction build() {
                return new CapabilityStatementInteraction(b.build());
            }
        }
    }

    public static class CapabilityStatementInteraction1 extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementInteraction1";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementInteraction1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A coded identifier of the operation, supported by the system.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * Guidance specific to the implementation of this operation, such as
         * limitations on the kind of transactions allowed, or information about
         * system wide search is implemented.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementInteraction1 build() {
                return new CapabilityStatementInteraction1(b.build());
            }
        }
    }

    public static class CapabilityStatementMessaging extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementMessaging";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_ENDPOINT = "endpoint";
        public static final String PROPERTY_RELIABLE_CACHE = "reliableCache";
        public static final String PROPERTY_DOCUMENTATION = "documentation";
        public static final String PROPERTY_SUPPORTED_MESSAGE = "supportedMessage";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementMessaging(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * An endpoint (network accessible address) to which messages and/or
         * replies are to be sent.
         */
        public java.util.List<CapabilityStatementEndpoint> endpoint() {
            return getList(CapabilityStatementEndpoint.class, PROPERTY_ENDPOINT);
        }

        /**
         * Length if the receiver's reliable messaging cache in minutes (if a
         * receiver) or how long the cache length on the receiver should be (if a
         * sender).
         */
        public Integer reliableCache() {
            return data.getInt(PROPERTY_RELIABLE_CACHE);
        }

        /**
         * Documentation about the system's messaging capabilities for this
         * endpoint not otherwise documented by the capability statement.  For
         * example, the process for becoming an authorized messaging exchange
         * partner.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        /**
         * References to message definitions for messages this system can send or
         * receive.
         */
        public java.util.List<CapabilityStatementSupportedMessage> supportedMessage() {
            return getList(CapabilityStatementSupportedMessage.class, PROPERTY_SUPPORTED_MESSAGE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder endpoint(final java.util.List<CapabilityStatementEndpoint> endpoint) {
                b.add(PROPERTY_ENDPOINT, FhirObject.toArray(endpoint));
                return this;
            }

            public Builder reliableCache(final Integer reliableCache) {
                b.add(PROPERTY_RELIABLE_CACHE, reliableCache);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder supportedMessage(final java.util.List<CapabilityStatementSupportedMessage> supportedMessage) {
                b.add(PROPERTY_SUPPORTED_MESSAGE, FhirObject.toArray(supportedMessage));
                return this;
            }

            public CapabilityStatementMessaging build() {
                return new CapabilityStatementMessaging(b.build());
            }
        }
    }

    public static class CapabilityStatementOperation extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementOperation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DEFINITION = "definition";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementOperation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of the operation or query. For an operation, this is the name
         * prefixed with $ and used in the URL. For a query, this is the name
         * used in the _query parameter when the query is called.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Where the formal definition can be found. If a server references the
         * base definition of an Operation (i.e. from the specification itself
         * such as
         * ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that
         * means it supports the full capabilities of the operation - e.g. both
         * GET and POST invocation.  If it only supports a subset, it must define
         * its own custom [[[OperationDefinition]]] with a 'base' of the original
         * OperationDefinition.  The custom definition would describe the
         * specific subset of functionality supported.
         */
        public String definition() {
            return getString(PROPERTY_DEFINITION);
        }

        /**
         * Documentation that describes anything special about the operation
         * behavior, possibly detailing different behavior for system, type and
         * instance-level invocation of the operation.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(PROPERTY_DEFINITION, definition);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementOperation build() {
                return new CapabilityStatementOperation(b.build());
            }
        }
    }

    public static class CapabilityStatementResource extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementResource";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_PROFILE = "profile";
        public static final String PROPERTY_SUPPORTED_PROFILE = "supportedProfile";
        public static final String PROPERTY_DOCUMENTATION = "documentation";
        public static final String PROPERTY_INTERACTION = "interaction";
        public static final String PROPERTY_VERSIONING = "versioning";
        public static final String PROPERTY_READ_HISTORY = "readHistory";
        public static final String PROPERTY_UPDATE_CREATE = "updateCreate";
        public static final String PROPERTY_CONDITIONAL_CREATE = "conditionalCreate";
        public static final String PROPERTY_CONDITIONAL_READ = "conditionalRead";
        public static final String PROPERTY_CONDITIONAL_UPDATE = "conditionalUpdate";
        public static final String PROPERTY_CONDITIONAL_DELETE = "conditionalDelete";
        public static final String PROPERTY_REFERENCE_POLICY = "referencePolicy";
        public static final String PROPERTY_SEARCH_INCLUDE = "searchInclude";
        public static final String PROPERTY_SEARCH_REV_INCLUDE = "searchRevInclude";
        public static final String PROPERTY_SEARCH_PARAM = "searchParam";
        public static final String PROPERTY_OPERATION = "operation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementResource(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A type of resource exposed via the restful interface.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * A specification of the profile that describes the solution's overall
         * support for the resource, including any constraints on cardinality,
         * bindings, lengths or other limitations. See further discussion in
         * [Using Profiles](profiling.html#profile-uses).
         */
        public String profile() {
            return getString(PROPERTY_PROFILE);
        }

        /**
         * A list of profiles that represent different use cases supported by the
         * system. For a server, &quot;supported by the system&quot; means the system
         * hosts/produces a set of resources that are conformant to a particular
         * profile, and allows clients that use its services to search using this
         * profile and to find appropriate data. For a client, it means the
         * system will search by this profile and process data according to the
         * guidance implicit in the profile. See further discussion in [Using
         * Profiles](profiling.html#profile-uses).
         */
        public java.util.List<String> supportedProfile() {
            return getList(String.class, PROPERTY_SUPPORTED_PROFILE);
        }

        /**
         * Additional information about the resource type used by the system.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        /**
         * Identifies a restful operation supported by the solution.
         */
        public java.util.List<CapabilityStatementInteraction> interaction() {
            return getList(CapabilityStatementInteraction.class, PROPERTY_INTERACTION);
        }

        /**
         * This field is set to no-version to specify that the system does not
         * support (server) or use (client) versioning for this resource type. If
         * this has some other value, the server must at least correctly track
         * and populate the versionId meta-property on resources. If the value is
         * 'versioned-update', then the server supports all the versioning
         * features, including using e-tags for version integrity in the API.
         */
        public String versioning() {
            return getString(PROPERTY_VERSIONING);
        }

        /**
         * A flag for whether the server is able to return past versions as part
         * of the vRead operation.
         */
        public Boolean readHistory() {
            return data.getBoolean(PROPERTY_READ_HISTORY);
        }

        /**
         * A flag to indicate that the server allows or needs to allow the client
         * to create new identities on the server (that is, the client PUTs to a
         * location where there is no existing resource). Allowing this operation
         * means that the server allows the client to create new identities on
         * the server.
         */
        public Boolean updateCreate() {
            return data.getBoolean(PROPERTY_UPDATE_CREATE);
        }

        /**
         * A flag that indicates that the server supports conditional create.
         */
        public Boolean conditionalCreate() {
            return data.getBoolean(PROPERTY_CONDITIONAL_CREATE);
        }

        /**
         * A code that indicates how the server supports conditional read.
         */
        public String conditionalRead() {
            return getString(PROPERTY_CONDITIONAL_READ);
        }

        /**
         * A flag that indicates that the server supports conditional update.
         */
        public Boolean conditionalUpdate() {
            return data.getBoolean(PROPERTY_CONDITIONAL_UPDATE);
        }

        /**
         * A code that indicates how the server supports conditional delete.
         */
        public String conditionalDelete() {
            return getString(PROPERTY_CONDITIONAL_DELETE);
        }

        /**
         * A set of flags that defines how references are supported.
         */
        public java.util.List<String> referencePolicy() {
            return getList(String.class, PROPERTY_REFERENCE_POLICY);
        }

        /**
         * A list of _include values supported by the server.
         */
        public java.util.List<String> searchInclude() {
            return getList(String.class, PROPERTY_SEARCH_INCLUDE);
        }

        /**
         * A list of _revinclude (reverse include) values supported by the
         * server.
         */
        public java.util.List<String> searchRevInclude() {
            return getList(String.class, PROPERTY_SEARCH_REV_INCLUDE);
        }

        /**
         * Search parameters for implementations to support and/or make use of -
         * either references to ones defined in the specification, or additional
         * ones defined for/by the implementation.
         */
        public java.util.List<CapabilityStatementSearchParam> searchParam() {
            return getList(CapabilityStatementSearchParam.class, PROPERTY_SEARCH_PARAM);
        }

        /**
         * Definition of an operation or a named query together with its
         * parameters and their meaning and type. Consult the definition of the
         * operation for details about how to invoke the operation, and the
         * parameters.
         */
        public java.util.List<CapabilityStatementOperation> operation() {
            return getList(CapabilityStatementOperation.class, PROPERTY_OPERATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder profile(final String profile) {
                b.add(PROPERTY_PROFILE, profile);
                return this;
            }

            public Builder supportedProfile(final java.util.List<String> supportedProfile) {
                b.add(PROPERTY_SUPPORTED_PROFILE, FhirObject.toStringArray(supportedProfile));
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder interaction(final java.util.List<CapabilityStatementInteraction> interaction) {
                b.add(PROPERTY_INTERACTION, FhirObject.toArray(interaction));
                return this;
            }

            public Builder versioning(final String versioning) {
                b.add(PROPERTY_VERSIONING, versioning);
                return this;
            }

            public Builder readHistory(final Boolean readHistory) {
                b.add(PROPERTY_READ_HISTORY, readHistory);
                return this;
            }

            public Builder updateCreate(final Boolean updateCreate) {
                b.add(PROPERTY_UPDATE_CREATE, updateCreate);
                return this;
            }

            public Builder conditionalCreate(final Boolean conditionalCreate) {
                b.add(PROPERTY_CONDITIONAL_CREATE, conditionalCreate);
                return this;
            }

            public Builder conditionalRead(final String conditionalRead) {
                b.add(PROPERTY_CONDITIONAL_READ, conditionalRead);
                return this;
            }

            public Builder conditionalUpdate(final Boolean conditionalUpdate) {
                b.add(PROPERTY_CONDITIONAL_UPDATE, conditionalUpdate);
                return this;
            }

            public Builder conditionalDelete(final String conditionalDelete) {
                b.add(PROPERTY_CONDITIONAL_DELETE, conditionalDelete);
                return this;
            }

            public Builder referencePolicy(final java.util.List<String> referencePolicy) {
                b.add(PROPERTY_REFERENCE_POLICY, FhirObject.toStringArray(referencePolicy));
                return this;
            }

            public Builder searchInclude(final java.util.List<String> searchInclude) {
                b.add(PROPERTY_SEARCH_INCLUDE, FhirObject.toStringArray(searchInclude));
                return this;
            }

            public Builder searchRevInclude(final java.util.List<String> searchRevInclude) {
                b.add(PROPERTY_SEARCH_REV_INCLUDE, FhirObject.toStringArray(searchRevInclude));
                return this;
            }

            public Builder searchParam(final java.util.List<CapabilityStatementSearchParam> searchParam) {
                b.add(PROPERTY_SEARCH_PARAM, FhirObject.toArray(searchParam));
                return this;
            }

            public Builder operation(final java.util.List<CapabilityStatementOperation> operation) {
                b.add(PROPERTY_OPERATION, FhirObject.toArray(operation));
                return this;
            }

            public CapabilityStatementResource build() {
                return new CapabilityStatementResource(b.build());
            }
        }
    }

    public static class CapabilityStatementRest extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementRest";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_MODE = "mode";
        public static final String PROPERTY_DOCUMENTATION = "documentation";
        public static final String PROPERTY_SECURITY = "security";
        public static final String PROPERTY_RESOURCE = "resource";
        public static final String PROPERTY_INTERACTION = "interaction";
        public static final String PROPERTY_SEARCH_PARAM = "searchParam";
        public static final String PROPERTY_OPERATION = "operation";
        public static final String PROPERTY_COMPARTMENT = "compartment";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementRest(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Identifies whether this portion of the statement is describing the
         * ability to initiate or receive restful operations.
         */
        public String mode() {
            return getString(PROPERTY_MODE);
        }

        /**
         * Information about the system's restful capabilities that apply across
         * all applications, such as security.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        /**
         * Information about security implementation from an interface
         * perspective - what a client needs to know.
         */
        public CapabilityStatementSecurity security() {
            return getObject(CapabilityStatementSecurity.class, PROPERTY_SECURITY);
        }

        /**
         * A specification of the restful capabilities of the solution for a
         * specific resource type.
         */
        public java.util.List<CapabilityStatementResource> resource() {
            return getList(CapabilityStatementResource.class, PROPERTY_RESOURCE);
        }

        /**
         * A specification of restful operations supported by the system.
         */
        public java.util.List<CapabilityStatementInteraction1> interaction() {
            return getList(CapabilityStatementInteraction1.class, PROPERTY_INTERACTION);
        }

        /**
         * Search parameters that are supported for searching all resources for
         * implementations to support and/or make use of - either references to
         * ones defined in the specification, or additional ones defined for/by
         * the implementation.
         */
        public java.util.List<CapabilityStatementSearchParam> searchParam() {
            return getList(CapabilityStatementSearchParam.class, PROPERTY_SEARCH_PARAM);
        }

        /**
         * Definition of an operation or a named query together with its
         * parameters and their meaning and type.
         */
        public java.util.List<CapabilityStatementOperation> operation() {
            return getList(CapabilityStatementOperation.class, PROPERTY_OPERATION);
        }

        /**
         * An absolute URI which is a reference to the definition of a
         * compartment that the system supports. The reference is to a
         * CompartmentDefinition resource by its canonical URL .
         */
        public java.util.List<String> compartment() {
            return getList(String.class, PROPERTY_COMPARTMENT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder security(final CapabilityStatementSecurity security) {
                b.add(PROPERTY_SECURITY, security);
                return this;
            }

            public Builder resource(final java.util.List<CapabilityStatementResource> resource) {
                b.add(PROPERTY_RESOURCE, FhirObject.toArray(resource));
                return this;
            }

            public Builder interaction(final java.util.List<CapabilityStatementInteraction1> interaction) {
                b.add(PROPERTY_INTERACTION, FhirObject.toArray(interaction));
                return this;
            }

            public Builder searchParam(final java.util.List<CapabilityStatementSearchParam> searchParam) {
                b.add(PROPERTY_SEARCH_PARAM, FhirObject.toArray(searchParam));
                return this;
            }

            public Builder operation(final java.util.List<CapabilityStatementOperation> operation) {
                b.add(PROPERTY_OPERATION, FhirObject.toArray(operation));
                return this;
            }

            public Builder compartment(final java.util.List<String> compartment) {
                b.add(PROPERTY_COMPARTMENT, FhirObject.toStringArray(compartment));
                return this;
            }

            public CapabilityStatementRest build() {
                return new CapabilityStatementRest(b.build());
            }
        }
    }

    public static class CapabilityStatementSearchParam extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSearchParam";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DEFINITION = "definition";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSearchParam(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of the search parameter used in the interface.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * An absolute URI that is a formal reference to where this parameter was
         * first defined, so that a client can be confident of the meaning of the
         * search parameter (a reference to [[[SearchParameter.url]]]). This
         * element SHALL be populated if the search parameter refers to a
         * SearchParameter defined by the FHIR core specification or externally
         * defined IGs.
         */
        public String definition() {
            return getString(PROPERTY_DEFINITION);
        }

        /**
         * The type of value a search parameter refers to, and how the content is
         * interpreted.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * This allows documentation of any distinct behaviors about how the
         * search parameter is used.  For example, text matching algorithms.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(PROPERTY_DEFINITION, definition);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementSearchParam build() {
                return new CapabilityStatementSearchParam(b.build());
            }
        }
    }

    public static class CapabilityStatementSecurity extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSecurity";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CORS = "cors";
        public static final String PROPERTY_SERVICE = "service";
        public static final String PROPERTY_DESCRIPTION = "description";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSecurity(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Server adds CORS headers when responding to requests - this enables
         * Javascript applications to use the server.
         */
        public Boolean cors() {
            return data.getBoolean(PROPERTY_CORS);
        }

        /**
         * Types of security services that are supported/required by the system.
         */
        public java.util.List<CodeableConcept> service() {
            return getList(CodeableConcept.class, PROPERTY_SERVICE);
        }

        /**
         * General description of how security works.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder cors(final Boolean cors) {
                b.add(PROPERTY_CORS, cors);
                return this;
            }

            public Builder service(final java.util.List<CodeableConcept> service) {
                b.add(PROPERTY_SERVICE, FhirObject.toArray(service));
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public CapabilityStatementSecurity build() {
                return new CapabilityStatementSecurity(b.build());
            }
        }
    }

    public static class CapabilityStatementSoftware extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSoftware";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_VERSION = "version";
        public static final String PROPERTY_RELEASE_DATE = "releaseDate";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSoftware(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name the software is known by.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * The version identifier for the software covered by this statement.
         */
        public String version() {
            return getString(PROPERTY_VERSION);
        }

        /**
         * Date this version of the software was released.
         */
        public java.time.Instant releaseDate() {
            return java.time.Instant.parse(data.getString(PROPERTY_RELEASE_DATE));
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder version(final String version) {
                b.add(PROPERTY_VERSION, version);
                return this;
            }

            public Builder releaseDate(final java.time.Instant releaseDate) {
                b.add(PROPERTY_RELEASE_DATE, releaseDate.toString());
                return this;
            }

            public CapabilityStatementSoftware build() {
                return new CapabilityStatementSoftware(b.build());
            }
        }
    }

    public static class CapabilityStatementSupportedMessage extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSupportedMessage";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_MODE = "mode";
        public static final String PROPERTY_DEFINITION = "definition";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSupportedMessage(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The mode of this event declaration - whether application is sender or
         * receiver.
         */
        public String mode() {
            return getString(PROPERTY_MODE);
        }

        /**
         * Points to a message definition that identifies the messaging event,
         * message structure, allowed responses, etc.
         */
        public String definition() {
            return getString(PROPERTY_DEFINITION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(PROPERTY_MODE, mode);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(PROPERTY_DEFINITION, definition);
                return this;
            }

            public CapabilityStatementSupportedMessage build() {
                return new CapabilityStatementSupportedMessage(b.build());
            }
        }
    }
}
