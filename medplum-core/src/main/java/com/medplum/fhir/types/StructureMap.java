/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class StructureMap extends FhirResource {
    public static final String RESOURCE_TYPE = "StructureMap";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_URL = "url";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_VERSION = "version";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_TITLE = "title";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_EXPERIMENTAL = "experimental";
    public static final String PROPERTY_DATE = "date";
    public static final String PROPERTY_PUBLISHER = "publisher";
    public static final String PROPERTY_CONTACT = "contact";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_USE_CONTEXT = "useContext";
    public static final String PROPERTY_JURISDICTION = "jurisdiction";
    public static final String PROPERTY_PURPOSE = "purpose";
    public static final String PROPERTY_COPYRIGHT = "copyright";
    public static final String PROPERTY_STRUCTURE = "structure";
    public static final String PROPERTY_IMPORT = "import";
    public static final String PROPERTY_GROUP = "group";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public StructureMap(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it "clinically safe" for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * An absolute URI that is used to identify this structure map when it is
     * referenced in a specification, model, design or an instance; also
     * called its canonical identifier. This SHOULD be globally unique and
     * SHOULD be a literal address at which at which an authoritative
     * instance of this structure map is (or will be) published. This URL can
     * be the target of a canonical reference. It SHALL remain the same when
     * the structure map is stored on different servers.
     */
    public String url() {
        return getString(PROPERTY_URL);
    }

    /**
     * A formal identifier that is used to identify this structure map when
     * it is represented in other formats, or referenced in a specification,
     * model, design or an instance.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * The identifier that is used to identify this version of the structure
     * map when it is referenced in a specification, model, design or
     * instance. This is an arbitrary value managed by the structure map
     * author and is not expected to be globally unique. For example, it
     * might be a timestamp (e.g. yyyymmdd) if a managed version is not
     * available. There is also no expectation that versions can be placed in
     * a lexicographical sequence.
     */
    public String version() {
        return getString(PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the structure map. This name
     * should be usable as an identifier for the module by machine processing
     * applications such as code generation.
     */
    public String name() {
        return getString(PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the structure map.
     */
    public String title() {
        return getString(PROPERTY_TITLE);
    }

    /**
     * The status of this structure map. Enables tracking the life-cycle of
     * the content.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this structure map is authored for
     * testing purposes (or education/evaluation/marketing) and is not
     * intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the structure map was published.
     * The date must change when the business version changes and it must
     * change if the status code changes. In addition, it should change when
     * the substantive content of the structure map changes.
     */
    public java.time.Instant date() {
        return java.time.Instant.parse(data.getString(PROPERTY_DATE));
    }

    /**
     * The name of the organization or individual that published the
     * structure map.
     */
    public String publisher() {
        return getString(PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the structure map from a
     * consumer's perspective.
     */
    public String description() {
        return getString(PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate structure map instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the structure map is intended to
     * be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this structure map is needed and why it has been
     * designed as it has.
     */
    public String purpose() {
        return getString(PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the structure map and/or its
     * contents. Copyright statements are generally legal restrictions on the
     * use and publishing of the structure map.
     */
    public String copyright() {
        return getString(PROPERTY_COPYRIGHT);
    }

    /**
     * A structure definition used by this map. The structure definition may
     * describe instances that are converted, or the instances that are
     * produced.
     */
    public java.util.List<StructureMapStructure> structure() {
        return getList(StructureMapStructure.class, PROPERTY_STRUCTURE);
    }

    /**
     * Other maps used by this map (canonical URLs).
     */
    public java.util.List<String> importValue() {
        return getList(String.class, PROPERTY_IMPORT);
    }

    /**
     * Organizes the mapping into manageable chunks for human review/ease of
     * maintenance.
     */
    public java.util.List<StructureMapGroup> group() {
        return getList(StructureMapGroup.class, PROPERTY_GROUP);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder url(final String url) {
            b.add(PROPERTY_URL, url);
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder version(final String version) {
            b.add(PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder structure(final java.util.List<StructureMapStructure> structure) {
            b.add(PROPERTY_STRUCTURE, FhirObject.toArray(structure));
            return this;
        }

        public Builder importValue(final java.util.List<String> importValue) {
            b.add(PROPERTY_IMPORT, FhirObject.toStringArray(importValue));
            return this;
        }

        public Builder group(final java.util.List<StructureMapGroup> group) {
            b.add(PROPERTY_GROUP, FhirObject.toArray(group));
            return this;
        }

        public StructureMap build() {
            return new StructureMap(b.build());
        }
    }

    public static class StructureMapDependent extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapDependent";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_VARIABLE = "variable";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapDependent(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name of a rule or group to apply.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Variable to pass to the rule or group.
         */
        public java.util.List<String> variable() {
            return getList(String.class, PROPERTY_VARIABLE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder variable(final java.util.List<String> variable) {
                b.add(PROPERTY_VARIABLE, FhirObject.toStringArray(variable));
                return this;
            }

            public StructureMapDependent build() {
                return new StructureMapDependent(b.build());
            }
        }
    }

    public static class StructureMapGroup extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapGroup";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_EXTENDS = "extends";
        public static final String PROPERTY_TYPE_MODE = "typeMode";
        public static final String PROPERTY_DOCUMENTATION = "documentation";
        public static final String PROPERTY_INPUT = "input";
        public static final String PROPERTY_RULE = "rule";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapGroup(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A unique name for the group for the convenience of human readers.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Another group that this group adds rules to.
         */
        public String extendsValue() {
            return getString(PROPERTY_EXTENDS);
        }

        /**
         * If this is the default rule set to apply for the source type or this
         * combination of types.
         */
        public String typeMode() {
            return getString(PROPERTY_TYPE_MODE);
        }

        /**
         * Additional supporting documentation that explains the purpose of the
         * group and the types of mappings within it.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        /**
         * A name assigned to an instance of data. The instance must be provided
         * when the mapping is invoked.
         */
        public java.util.List<StructureMapInput> input() {
            return getList(StructureMapInput.class, PROPERTY_INPUT);
        }

        /**
         * Transform Rule from source to target.
         */
        public java.util.List<StructureMapRule> rule() {
            return getList(StructureMapRule.class, PROPERTY_RULE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder extendsValue(final String extendsValue) {
                b.add(PROPERTY_EXTENDS, extendsValue);
                return this;
            }

            public Builder typeMode(final String typeMode) {
                b.add(PROPERTY_TYPE_MODE, typeMode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder input(final java.util.List<StructureMapInput> input) {
                b.add(PROPERTY_INPUT, FhirObject.toArray(input));
                return this;
            }

            public Builder rule(final java.util.List<StructureMapRule> rule) {
                b.add(PROPERTY_RULE, FhirObject.toArray(rule));
                return this;
            }

            public StructureMapGroup build() {
                return new StructureMapGroup(b.build());
            }
        }
    }

    public static class StructureMapInput extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapInput";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_MODE = "mode";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapInput(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name for this instance of data.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Type for this instance of data.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * Mode for this instance of data.
         */
        public String mode() {
            return getString(PROPERTY_MODE);
        }

        /**
         * Documentation for this instance of data.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder mode(final String mode) {
                b.add(PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapInput build() {
                return new StructureMapInput(b.build());
            }
        }
    }

    public static class StructureMapParameter extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapParameter";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_VALUE_ID = "valueId";
        public static final String PROPERTY_VALUE_STRING = "valueString";
        public static final String PROPERTY_VALUE_BOOLEAN = "valueBoolean";
        public static final String PROPERTY_VALUE_INTEGER = "valueInteger";
        public static final String PROPERTY_VALUE_DECIMAL = "valueDecimal";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapParameter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Parameter value - variable or literal.
         */
        public String valueId() {
            return getString(PROPERTY_VALUE_ID);
        }

        /**
         * Parameter value - variable or literal.
         */
        public String valueString() {
            return getString(PROPERTY_VALUE_STRING);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(PROPERTY_VALUE_BOOLEAN);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Integer valueInteger() {
            return data.getInt(PROPERTY_VALUE_INTEGER);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Integer valueDecimal() {
            return data.getInt(PROPERTY_VALUE_DECIMAL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder valueId(final String valueId) {
                b.add(PROPERTY_VALUE_ID, valueId);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(PROPERTY_VALUE_STRING, valueString);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(PROPERTY_VALUE_BOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(PROPERTY_VALUE_INTEGER, valueInteger);
                return this;
            }

            public Builder valueDecimal(final Integer valueDecimal) {
                b.add(PROPERTY_VALUE_DECIMAL, valueDecimal);
                return this;
            }

            public StructureMapParameter build() {
                return new StructureMapParameter(b.build());
            }
        }
    }

    public static class StructureMapRule extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapRule";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_SOURCE = "source";
        public static final String PROPERTY_TARGET = "target";
        public static final String PROPERTY_RULE = "rule";
        public static final String PROPERTY_DEPENDENT = "dependent";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapRule(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name of the rule for internal references.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Source inputs to the mapping.
         */
        public java.util.List<StructureMapSource> source() {
            return getList(StructureMapSource.class, PROPERTY_SOURCE);
        }

        /**
         * Content to create because of this mapping rule.
         */
        public java.util.List<StructureMapTarget> target() {
            return getList(StructureMapTarget.class, PROPERTY_TARGET);
        }

        /**
         * Rules contained in this rule.
         */
        public java.util.List<StructureMapRule> rule() {
            return getList(StructureMapRule.class, PROPERTY_RULE);
        }

        /**
         * Which other rules to apply in the context of this rule.
         */
        public java.util.List<StructureMapDependent> dependent() {
            return getList(StructureMapDependent.class, PROPERTY_DEPENDENT);
        }

        /**
         * Documentation for this instance of data.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder source(final java.util.List<StructureMapSource> source) {
                b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public Builder target(final java.util.List<StructureMapTarget> target) {
                b.add(PROPERTY_TARGET, FhirObject.toArray(target));
                return this;
            }

            public Builder rule(final java.util.List<StructureMapRule> rule) {
                b.add(PROPERTY_RULE, FhirObject.toArray(rule));
                return this;
            }

            public Builder dependent(final java.util.List<StructureMapDependent> dependent) {
                b.add(PROPERTY_DEPENDENT, FhirObject.toArray(dependent));
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapRule build() {
                return new StructureMapRule(b.build());
            }
        }
    }

    public static class StructureMapSource extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapSource";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CONTEXT = "context";
        public static final String PROPERTY_MIN = "min";
        public static final String PROPERTY_MAX = "max";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_DEFAULT_VALUE_BASE64_BINARY = "defaultValueBase64Binary";
        public static final String PROPERTY_DEFAULT_VALUE_BOOLEAN = "defaultValueBoolean";
        public static final String PROPERTY_DEFAULT_VALUE_CANONICAL = "defaultValueCanonical";
        public static final String PROPERTY_DEFAULT_VALUE_CODE = "defaultValueCode";
        public static final String PROPERTY_DEFAULT_VALUE_DATE = "defaultValueDate";
        public static final String PROPERTY_DEFAULT_VALUE_DATE_TIME = "defaultValueDateTime";
        public static final String PROPERTY_DEFAULT_VALUE_DECIMAL = "defaultValueDecimal";
        public static final String PROPERTY_DEFAULT_VALUE_ID = "defaultValueId";
        public static final String PROPERTY_DEFAULT_VALUE_INSTANT = "defaultValueInstant";
        public static final String PROPERTY_DEFAULT_VALUE_INTEGER = "defaultValueInteger";
        public static final String PROPERTY_DEFAULT_VALUE_MARKDOWN = "defaultValueMarkdown";
        public static final String PROPERTY_DEFAULT_VALUE_OID = "defaultValueOid";
        public static final String PROPERTY_DEFAULT_VALUE_POSITIVE_INT = "defaultValuePositiveInt";
        public static final String PROPERTY_DEFAULT_VALUE_STRING = "defaultValueString";
        public static final String PROPERTY_DEFAULT_VALUE_TIME = "defaultValueTime";
        public static final String PROPERTY_DEFAULT_VALUE_UNSIGNED_INT = "defaultValueUnsignedInt";
        public static final String PROPERTY_DEFAULT_VALUE_URI = "defaultValueUri";
        public static final String PROPERTY_DEFAULT_VALUE_URL = "defaultValueUrl";
        public static final String PROPERTY_DEFAULT_VALUE_UUID = "defaultValueUuid";
        public static final String PROPERTY_DEFAULT_VALUE_ADDRESS = "defaultValueAddress";
        public static final String PROPERTY_DEFAULT_VALUE_AGE = "defaultValueAge";
        public static final String PROPERTY_DEFAULT_VALUE_ANNOTATION = "defaultValueAnnotation";
        public static final String PROPERTY_DEFAULT_VALUE_ATTACHMENT = "defaultValueAttachment";
        public static final String PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT = "defaultValueCodeableConcept";
        public static final String PROPERTY_DEFAULT_VALUE_CODING = "defaultValueCoding";
        public static final String PROPERTY_DEFAULT_VALUE_CONTACT_POINT = "defaultValueContactPoint";
        public static final String PROPERTY_DEFAULT_VALUE_COUNT = "defaultValueCount";
        public static final String PROPERTY_DEFAULT_VALUE_DISTANCE = "defaultValueDistance";
        public static final String PROPERTY_DEFAULT_VALUE_DURATION = "defaultValueDuration";
        public static final String PROPERTY_DEFAULT_VALUE_HUMAN_NAME = "defaultValueHumanName";
        public static final String PROPERTY_DEFAULT_VALUE_IDENTIFIER = "defaultValueIdentifier";
        public static final String PROPERTY_DEFAULT_VALUE_MONEY = "defaultValueMoney";
        public static final String PROPERTY_DEFAULT_VALUE_PERIOD = "defaultValuePeriod";
        public static final String PROPERTY_DEFAULT_VALUE_QUANTITY = "defaultValueQuantity";
        public static final String PROPERTY_DEFAULT_VALUE_RANGE = "defaultValueRange";
        public static final String PROPERTY_DEFAULT_VALUE_RATIO = "defaultValueRatio";
        public static final String PROPERTY_DEFAULT_VALUE_REFERENCE = "defaultValueReference";
        public static final String PROPERTY_DEFAULT_VALUE_SAMPLED_DATA = "defaultValueSampledData";
        public static final String PROPERTY_DEFAULT_VALUE_SIGNATURE = "defaultValueSignature";
        public static final String PROPERTY_DEFAULT_VALUE_TIMING = "defaultValueTiming";
        public static final String PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL = "defaultValueContactDetail";
        public static final String PROPERTY_DEFAULT_VALUE_CONTRIBUTOR = "defaultValueContributor";
        public static final String PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT = "defaultValueDataRequirement";
        public static final String PROPERTY_DEFAULT_VALUE_EXPRESSION = "defaultValueExpression";
        public static final String PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION = "defaultValueParameterDefinition";
        public static final String PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT = "defaultValueRelatedArtifact";
        public static final String PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION = "defaultValueTriggerDefinition";
        public static final String PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT = "defaultValueUsageContext";
        public static final String PROPERTY_DEFAULT_VALUE_DOSAGE = "defaultValueDosage";
        public static final String PROPERTY_DEFAULT_VALUE_META = "defaultValueMeta";
        public static final String PROPERTY_ELEMENT = "element";
        public static final String PROPERTY_LIST_MODE = "listMode";
        public static final String PROPERTY_VARIABLE = "variable";
        public static final String PROPERTY_CONDITION = "condition";
        public static final String PROPERTY_CHECK = "check";
        public static final String PROPERTY_LOG_MESSAGE = "logMessage";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapSource(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Type or variable this rule applies to.
         */
        public String context() {
            return getString(PROPERTY_CONTEXT);
        }

        /**
         * Specified minimum cardinality for the element. This is optional; if
         * present, it acts an implicit check on the input content.
         */
        public Integer min() {
            return data.getInt(PROPERTY_MIN);
        }

        /**
         * Specified maximum cardinality for the element - a number or a "*".
         * This is optional; if present, it acts an implicit check on the input
         * content (* just serves as documentation; it's the default value).
         */
        public String max() {
            return getString(PROPERTY_MAX);
        }

        /**
         * Specified type for the element. This works as a condition on the
         * mapping - use for polymorphic elements.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueBase64Binary() {
            return getString(PROPERTY_DEFAULT_VALUE_BASE64_BINARY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Boolean defaultValueBoolean() {
            return data.getBoolean(PROPERTY_DEFAULT_VALUE_BOOLEAN);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueCanonical() {
            return getString(PROPERTY_DEFAULT_VALUE_CANONICAL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueCode() {
            return getString(PROPERTY_DEFAULT_VALUE_CODE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueDate() {
            return getString(PROPERTY_DEFAULT_VALUE_DATE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueDateTime() {
            return getString(PROPERTY_DEFAULT_VALUE_DATE_TIME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueDecimal() {
            return data.getInt(PROPERTY_DEFAULT_VALUE_DECIMAL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueId() {
            return getString(PROPERTY_DEFAULT_VALUE_ID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueInstant() {
            return getString(PROPERTY_DEFAULT_VALUE_INSTANT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueInteger() {
            return data.getInt(PROPERTY_DEFAULT_VALUE_INTEGER);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueMarkdown() {
            return getString(PROPERTY_DEFAULT_VALUE_MARKDOWN);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueOid() {
            return getString(PROPERTY_DEFAULT_VALUE_OID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValuePositiveInt() {
            return data.getInt(PROPERTY_DEFAULT_VALUE_POSITIVE_INT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueString() {
            return getString(PROPERTY_DEFAULT_VALUE_STRING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueTime() {
            return getString(PROPERTY_DEFAULT_VALUE_TIME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueUnsignedInt() {
            return data.getInt(PROPERTY_DEFAULT_VALUE_UNSIGNED_INT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUri() {
            return getString(PROPERTY_DEFAULT_VALUE_URI);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUrl() {
            return getString(PROPERTY_DEFAULT_VALUE_URL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUuid() {
            return getString(PROPERTY_DEFAULT_VALUE_UUID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Address defaultValueAddress() {
            return getObject(Address.class, PROPERTY_DEFAULT_VALUE_ADDRESS);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Age defaultValueAge() {
            return getObject(Age.class, PROPERTY_DEFAULT_VALUE_AGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Annotation defaultValueAnnotation() {
            return getObject(Annotation.class, PROPERTY_DEFAULT_VALUE_ANNOTATION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Attachment defaultValueAttachment() {
            return getObject(Attachment.class, PROPERTY_DEFAULT_VALUE_ATTACHMENT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public CodeableConcept defaultValueCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Coding defaultValueCoding() {
            return getObject(Coding.class, PROPERTY_DEFAULT_VALUE_CODING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ContactPoint defaultValueContactPoint() {
            return getObject(ContactPoint.class, PROPERTY_DEFAULT_VALUE_CONTACT_POINT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Count defaultValueCount() {
            return getObject(Count.class, PROPERTY_DEFAULT_VALUE_COUNT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Distance defaultValueDistance() {
            return getObject(Distance.class, PROPERTY_DEFAULT_VALUE_DISTANCE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Duration defaultValueDuration() {
            return getObject(Duration.class, PROPERTY_DEFAULT_VALUE_DURATION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public HumanName defaultValueHumanName() {
            return getObject(HumanName.class, PROPERTY_DEFAULT_VALUE_HUMAN_NAME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Identifier defaultValueIdentifier() {
            return getObject(Identifier.class, PROPERTY_DEFAULT_VALUE_IDENTIFIER);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Money defaultValueMoney() {
            return getObject(Money.class, PROPERTY_DEFAULT_VALUE_MONEY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Period defaultValuePeriod() {
            return getObject(Period.class, PROPERTY_DEFAULT_VALUE_PERIOD);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Quantity defaultValueQuantity() {
            return getObject(Quantity.class, PROPERTY_DEFAULT_VALUE_QUANTITY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Range defaultValueRange() {
            return getObject(Range.class, PROPERTY_DEFAULT_VALUE_RANGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Ratio defaultValueRatio() {
            return getObject(Ratio.class, PROPERTY_DEFAULT_VALUE_RATIO);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Reference defaultValueReference() {
            return getObject(Reference.class, PROPERTY_DEFAULT_VALUE_REFERENCE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public SampledData defaultValueSampledData() {
            return getObject(SampledData.class, PROPERTY_DEFAULT_VALUE_SAMPLED_DATA);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Signature defaultValueSignature() {
            return getObject(Signature.class, PROPERTY_DEFAULT_VALUE_SIGNATURE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Timing defaultValueTiming() {
            return getObject(Timing.class, PROPERTY_DEFAULT_VALUE_TIMING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ContactDetail defaultValueContactDetail() {
            return getObject(ContactDetail.class, PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Contributor defaultValueContributor() {
            return getObject(Contributor.class, PROPERTY_DEFAULT_VALUE_CONTRIBUTOR);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public DataRequirement defaultValueDataRequirement() {
            return getObject(DataRequirement.class, PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Expression defaultValueExpression() {
            return getObject(Expression.class, PROPERTY_DEFAULT_VALUE_EXPRESSION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ParameterDefinition defaultValueParameterDefinition() {
            return getObject(ParameterDefinition.class, PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public RelatedArtifact defaultValueRelatedArtifact() {
            return getObject(RelatedArtifact.class, PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public TriggerDefinition defaultValueTriggerDefinition() {
            return getObject(TriggerDefinition.class, PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public UsageContext defaultValueUsageContext() {
            return getObject(UsageContext.class, PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Dosage defaultValueDosage() {
            return getObject(Dosage.class, PROPERTY_DEFAULT_VALUE_DOSAGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Meta defaultValueMeta() {
            return getObject(Meta.class, PROPERTY_DEFAULT_VALUE_META);
        }

        /**
         * Optional field for this source.
         */
        public String element() {
            return getString(PROPERTY_ELEMENT);
        }

        /**
         * How to handle the list mode for this element.
         */
        public String listMode() {
            return getString(PROPERTY_LIST_MODE);
        }

        /**
         * Named context for field, if a field is specified.
         */
        public String variable() {
            return getString(PROPERTY_VARIABLE);
        }

        /**
         * FHIRPath expression  - must be true or the rule does not apply.
         */
        public String condition() {
            return getString(PROPERTY_CONDITION);
        }

        /**
         * FHIRPath expression  - must be true or the mapping engine throws an
         * error instead of completing.
         */
        public String check() {
            return getString(PROPERTY_CHECK);
        }

        /**
         * A FHIRPath expression which specifies a message to put in the
         * transform log when content matching the source rule is found.
         */
        public String logMessage() {
            return getString(PROPERTY_LOG_MESSAGE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder context(final String context) {
                b.add(PROPERTY_CONTEXT, context);
                return this;
            }

            public Builder min(final Integer min) {
                b.add(PROPERTY_MIN, min);
                return this;
            }

            public Builder max(final String max) {
                b.add(PROPERTY_MAX, max);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder defaultValueBase64Binary(final String defaultValueBase64Binary) {
                b.add(PROPERTY_DEFAULT_VALUE_BASE64_BINARY, defaultValueBase64Binary);
                return this;
            }

            public Builder defaultValueBoolean(final Boolean defaultValueBoolean) {
                b.add(PROPERTY_DEFAULT_VALUE_BOOLEAN, defaultValueBoolean);
                return this;
            }

            public Builder defaultValueCanonical(final String defaultValueCanonical) {
                b.add(PROPERTY_DEFAULT_VALUE_CANONICAL, defaultValueCanonical);
                return this;
            }

            public Builder defaultValueCode(final String defaultValueCode) {
                b.add(PROPERTY_DEFAULT_VALUE_CODE, defaultValueCode);
                return this;
            }

            public Builder defaultValueDate(final String defaultValueDate) {
                b.add(PROPERTY_DEFAULT_VALUE_DATE, defaultValueDate);
                return this;
            }

            public Builder defaultValueDateTime(final String defaultValueDateTime) {
                b.add(PROPERTY_DEFAULT_VALUE_DATE_TIME, defaultValueDateTime);
                return this;
            }

            public Builder defaultValueDecimal(final Integer defaultValueDecimal) {
                b.add(PROPERTY_DEFAULT_VALUE_DECIMAL, defaultValueDecimal);
                return this;
            }

            public Builder defaultValueId(final String defaultValueId) {
                b.add(PROPERTY_DEFAULT_VALUE_ID, defaultValueId);
                return this;
            }

            public Builder defaultValueInstant(final String defaultValueInstant) {
                b.add(PROPERTY_DEFAULT_VALUE_INSTANT, defaultValueInstant);
                return this;
            }

            public Builder defaultValueInteger(final Integer defaultValueInteger) {
                b.add(PROPERTY_DEFAULT_VALUE_INTEGER, defaultValueInteger);
                return this;
            }

            public Builder defaultValueMarkdown(final String defaultValueMarkdown) {
                b.add(PROPERTY_DEFAULT_VALUE_MARKDOWN, defaultValueMarkdown);
                return this;
            }

            public Builder defaultValueOid(final String defaultValueOid) {
                b.add(PROPERTY_DEFAULT_VALUE_OID, defaultValueOid);
                return this;
            }

            public Builder defaultValuePositiveInt(final Integer defaultValuePositiveInt) {
                b.add(PROPERTY_DEFAULT_VALUE_POSITIVE_INT, defaultValuePositiveInt);
                return this;
            }

            public Builder defaultValueString(final String defaultValueString) {
                b.add(PROPERTY_DEFAULT_VALUE_STRING, defaultValueString);
                return this;
            }

            public Builder defaultValueTime(final String defaultValueTime) {
                b.add(PROPERTY_DEFAULT_VALUE_TIME, defaultValueTime);
                return this;
            }

            public Builder defaultValueUnsignedInt(final Integer defaultValueUnsignedInt) {
                b.add(PROPERTY_DEFAULT_VALUE_UNSIGNED_INT, defaultValueUnsignedInt);
                return this;
            }

            public Builder defaultValueUri(final String defaultValueUri) {
                b.add(PROPERTY_DEFAULT_VALUE_URI, defaultValueUri);
                return this;
            }

            public Builder defaultValueUrl(final String defaultValueUrl) {
                b.add(PROPERTY_DEFAULT_VALUE_URL, defaultValueUrl);
                return this;
            }

            public Builder defaultValueUuid(final String defaultValueUuid) {
                b.add(PROPERTY_DEFAULT_VALUE_UUID, defaultValueUuid);
                return this;
            }

            public Builder defaultValueAddress(final Address defaultValueAddress) {
                b.add(PROPERTY_DEFAULT_VALUE_ADDRESS, defaultValueAddress);
                return this;
            }

            public Builder defaultValueAge(final Age defaultValueAge) {
                b.add(PROPERTY_DEFAULT_VALUE_AGE, defaultValueAge);
                return this;
            }

            public Builder defaultValueAnnotation(final Annotation defaultValueAnnotation) {
                b.add(PROPERTY_DEFAULT_VALUE_ANNOTATION, defaultValueAnnotation);
                return this;
            }

            public Builder defaultValueAttachment(final Attachment defaultValueAttachment) {
                b.add(PROPERTY_DEFAULT_VALUE_ATTACHMENT, defaultValueAttachment);
                return this;
            }

            public Builder defaultValueCodeableConcept(final CodeableConcept defaultValueCodeableConcept) {
                b.add(PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT, defaultValueCodeableConcept);
                return this;
            }

            public Builder defaultValueCoding(final Coding defaultValueCoding) {
                b.add(PROPERTY_DEFAULT_VALUE_CODING, defaultValueCoding);
                return this;
            }

            public Builder defaultValueContactPoint(final ContactPoint defaultValueContactPoint) {
                b.add(PROPERTY_DEFAULT_VALUE_CONTACT_POINT, defaultValueContactPoint);
                return this;
            }

            public Builder defaultValueCount(final Count defaultValueCount) {
                b.add(PROPERTY_DEFAULT_VALUE_COUNT, defaultValueCount);
                return this;
            }

            public Builder defaultValueDistance(final Distance defaultValueDistance) {
                b.add(PROPERTY_DEFAULT_VALUE_DISTANCE, defaultValueDistance);
                return this;
            }

            public Builder defaultValueDuration(final Duration defaultValueDuration) {
                b.add(PROPERTY_DEFAULT_VALUE_DURATION, defaultValueDuration);
                return this;
            }

            public Builder defaultValueHumanName(final HumanName defaultValueHumanName) {
                b.add(PROPERTY_DEFAULT_VALUE_HUMAN_NAME, defaultValueHumanName);
                return this;
            }

            public Builder defaultValueIdentifier(final Identifier defaultValueIdentifier) {
                b.add(PROPERTY_DEFAULT_VALUE_IDENTIFIER, defaultValueIdentifier);
                return this;
            }

            public Builder defaultValueMoney(final Money defaultValueMoney) {
                b.add(PROPERTY_DEFAULT_VALUE_MONEY, defaultValueMoney);
                return this;
            }

            public Builder defaultValuePeriod(final Period defaultValuePeriod) {
                b.add(PROPERTY_DEFAULT_VALUE_PERIOD, defaultValuePeriod);
                return this;
            }

            public Builder defaultValueQuantity(final Quantity defaultValueQuantity) {
                b.add(PROPERTY_DEFAULT_VALUE_QUANTITY, defaultValueQuantity);
                return this;
            }

            public Builder defaultValueRange(final Range defaultValueRange) {
                b.add(PROPERTY_DEFAULT_VALUE_RANGE, defaultValueRange);
                return this;
            }

            public Builder defaultValueRatio(final Ratio defaultValueRatio) {
                b.add(PROPERTY_DEFAULT_VALUE_RATIO, defaultValueRatio);
                return this;
            }

            public Builder defaultValueReference(final Reference defaultValueReference) {
                b.add(PROPERTY_DEFAULT_VALUE_REFERENCE, defaultValueReference);
                return this;
            }

            public Builder defaultValueSampledData(final SampledData defaultValueSampledData) {
                b.add(PROPERTY_DEFAULT_VALUE_SAMPLED_DATA, defaultValueSampledData);
                return this;
            }

            public Builder defaultValueSignature(final Signature defaultValueSignature) {
                b.add(PROPERTY_DEFAULT_VALUE_SIGNATURE, defaultValueSignature);
                return this;
            }

            public Builder defaultValueTiming(final Timing defaultValueTiming) {
                b.add(PROPERTY_DEFAULT_VALUE_TIMING, defaultValueTiming);
                return this;
            }

            public Builder defaultValueContactDetail(final ContactDetail defaultValueContactDetail) {
                b.add(PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL, defaultValueContactDetail);
                return this;
            }

            public Builder defaultValueContributor(final Contributor defaultValueContributor) {
                b.add(PROPERTY_DEFAULT_VALUE_CONTRIBUTOR, defaultValueContributor);
                return this;
            }

            public Builder defaultValueDataRequirement(final DataRequirement defaultValueDataRequirement) {
                b.add(PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT, defaultValueDataRequirement);
                return this;
            }

            public Builder defaultValueExpression(final Expression defaultValueExpression) {
                b.add(PROPERTY_DEFAULT_VALUE_EXPRESSION, defaultValueExpression);
                return this;
            }

            public Builder defaultValueParameterDefinition(final ParameterDefinition defaultValueParameterDefinition) {
                b.add(PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION, defaultValueParameterDefinition);
                return this;
            }

            public Builder defaultValueRelatedArtifact(final RelatedArtifact defaultValueRelatedArtifact) {
                b.add(PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT, defaultValueRelatedArtifact);
                return this;
            }

            public Builder defaultValueTriggerDefinition(final TriggerDefinition defaultValueTriggerDefinition) {
                b.add(PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION, defaultValueTriggerDefinition);
                return this;
            }

            public Builder defaultValueUsageContext(final UsageContext defaultValueUsageContext) {
                b.add(PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT, defaultValueUsageContext);
                return this;
            }

            public Builder defaultValueDosage(final Dosage defaultValueDosage) {
                b.add(PROPERTY_DEFAULT_VALUE_DOSAGE, defaultValueDosage);
                return this;
            }

            public Builder defaultValueMeta(final Meta defaultValueMeta) {
                b.add(PROPERTY_DEFAULT_VALUE_META, defaultValueMeta);
                return this;
            }

            public Builder element(final String element) {
                b.add(PROPERTY_ELEMENT, element);
                return this;
            }

            public Builder listMode(final String listMode) {
                b.add(PROPERTY_LIST_MODE, listMode);
                return this;
            }

            public Builder variable(final String variable) {
                b.add(PROPERTY_VARIABLE, variable);
                return this;
            }

            public Builder condition(final String condition) {
                b.add(PROPERTY_CONDITION, condition);
                return this;
            }

            public Builder check(final String check) {
                b.add(PROPERTY_CHECK, check);
                return this;
            }

            public Builder logMessage(final String logMessage) {
                b.add(PROPERTY_LOG_MESSAGE, logMessage);
                return this;
            }

            public StructureMapSource build() {
                return new StructureMapSource(b.build());
            }
        }
    }

    public static class StructureMapStructure extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapStructure";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_URL = "url";
        public static final String PROPERTY_MODE = "mode";
        public static final String PROPERTY_ALIAS = "alias";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapStructure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The canonical reference to the structure.
         */
        public String url() {
            return getString(PROPERTY_URL);
        }

        /**
         * How the referenced structure is used in this mapping.
         */
        public String mode() {
            return getString(PROPERTY_MODE);
        }

        /**
         * The name used for this type in the map.
         */
        public String alias() {
            return getString(PROPERTY_ALIAS);
        }

        /**
         * Documentation that describes how the structure is used in the mapping.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder url(final String url) {
                b.add(PROPERTY_URL, url);
                return this;
            }

            public Builder mode(final String mode) {
                b.add(PROPERTY_MODE, mode);
                return this;
            }

            public Builder alias(final String alias) {
                b.add(PROPERTY_ALIAS, alias);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapStructure build() {
                return new StructureMapStructure(b.build());
            }
        }
    }

    public static class StructureMapTarget extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapTarget";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CONTEXT = "context";
        public static final String PROPERTY_CONTEXT_TYPE = "contextType";
        public static final String PROPERTY_ELEMENT = "element";
        public static final String PROPERTY_VARIABLE = "variable";
        public static final String PROPERTY_LIST_MODE = "listMode";
        public static final String PROPERTY_LIST_RULE_ID = "listRuleId";
        public static final String PROPERTY_TRANSFORM = "transform";
        public static final String PROPERTY_PARAMETER = "parameter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapTarget(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Type or variable this rule applies to.
         */
        public String context() {
            return getString(PROPERTY_CONTEXT);
        }

        /**
         * How to interpret the context.
         */
        public String contextType() {
            return getString(PROPERTY_CONTEXT_TYPE);
        }

        /**
         * Field to create in the context.
         */
        public String element() {
            return getString(PROPERTY_ELEMENT);
        }

        /**
         * Named context for field, if desired, and a field is specified.
         */
        public String variable() {
            return getString(PROPERTY_VARIABLE);
        }

        /**
         * If field is a list, how to manage the list.
         */
        public java.util.List<String> listMode() {
            return getList(String.class, PROPERTY_LIST_MODE);
        }

        /**
         * Internal rule reference for shared list items.
         */
        public String listRuleId() {
            return getString(PROPERTY_LIST_RULE_ID);
        }

        /**
         * How the data is copied / created.
         */
        public String transform() {
            return getString(PROPERTY_TRANSFORM);
        }

        /**
         * Parameters to the transform.
         */
        public java.util.List<StructureMapParameter> parameter() {
            return getList(StructureMapParameter.class, PROPERTY_PARAMETER);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder context(final String context) {
                b.add(PROPERTY_CONTEXT, context);
                return this;
            }

            public Builder contextType(final String contextType) {
                b.add(PROPERTY_CONTEXT_TYPE, contextType);
                return this;
            }

            public Builder element(final String element) {
                b.add(PROPERTY_ELEMENT, element);
                return this;
            }

            public Builder variable(final String variable) {
                b.add(PROPERTY_VARIABLE, variable);
                return this;
            }

            public Builder listMode(final java.util.List<String> listMode) {
                b.add(PROPERTY_LIST_MODE, FhirObject.toStringArray(listMode));
                return this;
            }

            public Builder listRuleId(final String listRuleId) {
                b.add(PROPERTY_LIST_RULE_ID, listRuleId);
                return this;
            }

            public Builder transform(final String transform) {
                b.add(PROPERTY_TRANSFORM, transform);
                return this;
            }

            public Builder parameter(final java.util.List<StructureMapParameter> parameter) {
                b.add(PROPERTY_PARAMETER, FhirObject.toArray(parameter));
                return this;
            }

            public StructureMapTarget build() {
                return new StructureMapTarget(b.build());
            }
        }
    }
}
