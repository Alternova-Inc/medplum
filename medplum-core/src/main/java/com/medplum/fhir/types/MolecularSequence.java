/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class MolecularSequence extends FhirResource {
    public static final String RESOURCE_TYPE = "MolecularSequence";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_COORDINATE_SYSTEM = "coordinateSystem";
    public static final String PROPERTY_PATIENT = "patient";
    public static final String PROPERTY_SPECIMEN = "specimen";
    public static final String PROPERTY_DEVICE = "device";
    public static final String PROPERTY_PERFORMER = "performer";
    public static final String PROPERTY_QUANTITY = "quantity";
    public static final String PROPERTY_REFERENCE_SEQ = "referenceSeq";
    public static final String PROPERTY_VARIANT = "variant";
    public static final String PROPERTY_OBSERVED_SEQ = "observedSeq";
    public static final String PROPERTY_QUALITY = "quality";
    public static final String PROPERTY_READ_COVERAGE = "readCoverage";
    public static final String PROPERTY_REPOSITORY = "repository";
    public static final String PROPERTY_POINTER = "pointer";
    public static final String PROPERTY_STRUCTURE_VARIANT = "structureVariant";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public MolecularSequence(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * A unique identifier for this particular sequence instance. This is a
     * FHIR-defined id.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * Amino Acid Sequence/ DNA Sequence / RNA Sequence.
     */
    public String type() {
        return getString(PROPERTY_TYPE);
    }

    /**
     * Whether the sequence is numbered starting at 0 (0-based numbering or
     * coordinates, inclusive start, exclusive end) or starting at 1 (1-based
     * numbering, inclusive start and inclusive end).
     */
    public Integer coordinateSystem() {
        return data.getInt(PROPERTY_COORDINATE_SYSTEM);
    }

    /**
     * The patient whose sequencing results are described by this resource.
     */
    public Reference patient() {
        return getObject(Reference.class, PROPERTY_PATIENT);
    }

    /**
     * Specimen used for sequencing.
     */
    public Reference specimen() {
        return getObject(Reference.class, PROPERTY_SPECIMEN);
    }

    /**
     * The method for sequencing, for example, chip information.
     */
    public Reference device() {
        return getObject(Reference.class, PROPERTY_DEVICE);
    }

    /**
     * The organization or lab that should be responsible for this result.
     */
    public Reference performer() {
        return getObject(Reference.class, PROPERTY_PERFORMER);
    }

    /**
     * The number of copies of the sequence of interest. (RNASeq).
     */
    public Quantity quantity() {
        return getObject(Quantity.class, PROPERTY_QUANTITY);
    }

    /**
     * A sequence that is used as a reference to describe variants that are
     * present in a sequence analyzed.
     */
    public MolecularSequenceReferenceSeq referenceSeq() {
        return getObject(MolecularSequenceReferenceSeq.class, PROPERTY_REFERENCE_SEQ);
    }

    /**
     * The definition of variant here originates from Sequence ontology
     * ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)).
     * This element can represent amino acid or nucleic sequence
     * change(including insertion,deletion,SNP,etc.)  It can represent some
     * complex mutation or segment variation with the assist of CIGAR string.
     */
    public java.util.List<MolecularSequenceVariant> variant() {
        return getList(MolecularSequenceVariant.class, PROPERTY_VARIANT);
    }

    /**
     * Sequence that was observed. It is the result marked by referenceSeq
     * along with variant records on referenceSeq. This shall start from
     * referenceSeq.windowStart and end by referenceSeq.windowEnd.
     */
    public String observedSeq() {
        return getString(PROPERTY_OBSERVED_SEQ);
    }

    /**
     * An experimental feature attribute that defines the quality of the
     * feature in a quantitative way, such as a phred quality score
     * ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
     */
    public java.util.List<MolecularSequenceQuality> quality() {
        return getList(MolecularSequenceQuality.class, PROPERTY_QUALITY);
    }

    /**
     * Coverage (read depth or depth) is the average number of reads
     * representing a given nucleotide in the reconstructed sequence.
     */
    public Integer readCoverage() {
        return data.getInt(PROPERTY_READ_COVERAGE);
    }

    /**
     * Configurations of the external repository. The repository shall store
     * target's observedSeq or records related with target's observedSeq.
     */
    public java.util.List<MolecularSequenceRepository> repository() {
        return getList(MolecularSequenceRepository.class, PROPERTY_REPOSITORY);
    }

    /**
     * Pointer to next atomic sequence which at most contains one variant.
     */
    public java.util.List<Reference> pointer() {
        return getList(Reference.class, PROPERTY_POINTER);
    }

    /**
     * Information about chromosome structure variation.
     */
    public java.util.List<MolecularSequenceStructureVariant> structureVariant() {
        return getList(MolecularSequenceStructureVariant.class, PROPERTY_STRUCTURE_VARIANT);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder type(final String type) {
            b.add(PROPERTY_TYPE, type);
            return this;
        }

        public Builder coordinateSystem(final Integer coordinateSystem) {
            b.add(PROPERTY_COORDINATE_SYSTEM, coordinateSystem);
            return this;
        }

        public Builder patient(final Reference patient) {
            b.add(PROPERTY_PATIENT, patient);
            return this;
        }

        public Builder specimen(final Reference specimen) {
            b.add(PROPERTY_SPECIMEN, specimen);
            return this;
        }

        public Builder device(final Reference device) {
            b.add(PROPERTY_DEVICE, device);
            return this;
        }

        public Builder performer(final Reference performer) {
            b.add(PROPERTY_PERFORMER, performer);
            return this;
        }

        public Builder quantity(final Quantity quantity) {
            b.add(PROPERTY_QUANTITY, quantity);
            return this;
        }

        public Builder referenceSeq(final MolecularSequenceReferenceSeq referenceSeq) {
            b.add(PROPERTY_REFERENCE_SEQ, referenceSeq);
            return this;
        }

        public Builder variant(final java.util.List<MolecularSequenceVariant> variant) {
            b.add(PROPERTY_VARIANT, FhirObject.toArray(variant));
            return this;
        }

        public Builder observedSeq(final String observedSeq) {
            b.add(PROPERTY_OBSERVED_SEQ, observedSeq);
            return this;
        }

        public Builder quality(final java.util.List<MolecularSequenceQuality> quality) {
            b.add(PROPERTY_QUALITY, FhirObject.toArray(quality));
            return this;
        }

        public Builder readCoverage(final Integer readCoverage) {
            b.add(PROPERTY_READ_COVERAGE, readCoverage);
            return this;
        }

        public Builder repository(final java.util.List<MolecularSequenceRepository> repository) {
            b.add(PROPERTY_REPOSITORY, FhirObject.toArray(repository));
            return this;
        }

        public Builder pointer(final java.util.List<Reference> pointer) {
            b.add(PROPERTY_POINTER, FhirObject.toArray(pointer));
            return this;
        }

        public Builder structureVariant(final java.util.List<MolecularSequenceStructureVariant> structureVariant) {
            b.add(PROPERTY_STRUCTURE_VARIANT, FhirObject.toArray(structureVariant));
            return this;
        }

        public MolecularSequence build() {
            return new MolecularSequence(b.build());
        }
    }

    public static class MolecularSequenceInner extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceInner";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_START = "start";
        public static final String PROPERTY_END = "end";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceInner(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural variant inner start. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(PROPERTY_START);
        }

        /**
         * Structural variant inner end. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(PROPERTY_END);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(PROPERTY_END, end);
                return this;
            }

            public MolecularSequenceInner build() {
                return new MolecularSequenceInner(b.build());
            }
        }
    }

    public static class MolecularSequenceOuter extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceOuter";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_START = "start";
        public static final String PROPERTY_END = "end";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceOuter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural variant outer start. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(PROPERTY_START);
        }

        /**
         * Structural variant outer end. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(PROPERTY_END);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(PROPERTY_END, end);
                return this;
            }

            public MolecularSequenceOuter build() {
                return new MolecularSequenceOuter(b.build());
            }
        }
    }

    public static class MolecularSequenceQuality extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceQuality";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_STANDARD_SEQUENCE = "standardSequence";
        public static final String PROPERTY_START = "start";
        public static final String PROPERTY_END = "end";
        public static final String PROPERTY_SCORE = "score";
        public static final String PROPERTY_METHOD = "method";
        public static final String PROPERTY_TRUTH_T_P = "truthTP";
        public static final String PROPERTY_QUERY_T_P = "queryTP";
        public static final String PROPERTY_TRUTH_F_N = "truthFN";
        public static final String PROPERTY_QUERY_F_P = "queryFP";
        public static final String PROPERTY_GT_F_P = "gtFP";
        public static final String PROPERTY_PRECISION = "precision";
        public static final String PROPERTY_RECALL = "recall";
        public static final String PROPERTY_F_SCORE = "fScore";
        public static final String PROPERTY_ROC = "roc";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceQuality(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * INDEL / SNP / Undefined variant.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * Gold standard sequence used for comparing against.
         */
        public CodeableConcept standardSequence() {
            return getObject(CodeableConcept.class, PROPERTY_STANDARD_SEQUENCE);
        }

        /**
         * Start position of the sequence. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(PROPERTY_START);
        }

        /**
         * End position of the sequence. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(PROPERTY_END);
        }

        /**
         * The score of an experimentally derived feature such as a p-value
         * ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
         */
        public Quantity score() {
            return getObject(Quantity.class, PROPERTY_SCORE);
        }

        /**
         * Which method is used to get sequence quality.
         */
        public CodeableConcept method() {
            return getObject(CodeableConcept.class, PROPERTY_METHOD);
        }

        /**
         * True positives, from the perspective of the truth data, i.e. the
         * number of sites in the Truth Call Set for which there are paths
         * through the Query Call Set that are consistent with all of the alleles
         * at this site, and for which there is an accurate genotype call for the
         * event.
         */
        public Double truthTP() {
            return data.getJsonNumber(PROPERTY_TRUTH_T_P).doubleValue();
        }

        /**
         * True positives, from the perspective of the query data, i.e. the
         * number of sites in the Query Call Set for which there are paths
         * through the Truth Call Set that are consistent with all of the alleles
         * at this site, and for which there is an accurate genotype call for the
         * event.
         */
        public Double queryTP() {
            return data.getJsonNumber(PROPERTY_QUERY_T_P).doubleValue();
        }

        /**
         * False negatives, i.e. the number of sites in the Truth Call Set for
         * which there is no path through the Query Call Set that is consistent
         * with all of the alleles at this site, or sites for which there is an
         * inaccurate genotype call for the event. Sites with correct variant but
         * incorrect genotype are counted here.
         */
        public Double truthFN() {
            return data.getJsonNumber(PROPERTY_TRUTH_F_N).doubleValue();
        }

        /**
         * False positives, i.e. the number of sites in the Query Call Set for
         * which there is no path through the Truth Call Set that is consistent
         * with this site. Sites with correct variant but incorrect genotype are
         * counted here.
         */
        public Double queryFP() {
            return data.getJsonNumber(PROPERTY_QUERY_F_P).doubleValue();
        }

        /**
         * The number of false positives where the non-REF alleles in the Truth
         * and Query Call Sets match (i.e. cases where the truth is 1/1 and the
         * query is 0/1 or similar).
         */
        public Double gtFP() {
            return data.getJsonNumber(PROPERTY_GT_F_P).doubleValue();
        }

        /**
         * QUERY.TP / (QUERY.TP + QUERY.FP).
         */
        public Double precision() {
            return data.getJsonNumber(PROPERTY_PRECISION).doubleValue();
        }

        /**
         * TRUTH.TP / (TRUTH.TP + TRUTH.FN).
         */
        public Double recall() {
            return data.getJsonNumber(PROPERTY_RECALL).doubleValue();
        }

        /**
         * Harmonic mean of Recall and Precision, computed as: 2 * precision *
         * recall / (precision + recall).
         */
        public Double fScore() {
            return data.getJsonNumber(PROPERTY_F_SCORE).doubleValue();
        }

        /**
         * Receiver Operator Characteristic (ROC) Curve  to give
         * sensitivity/specificity tradeoff.
         */
        public MolecularSequenceRoc roc() {
            return getObject(MolecularSequenceRoc.class, PROPERTY_ROC);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder standardSequence(final CodeableConcept standardSequence) {
                b.add(PROPERTY_STANDARD_SEQUENCE, standardSequence);
                return this;
            }

            public Builder start(final Integer start) {
                b.add(PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(PROPERTY_END, end);
                return this;
            }

            public Builder score(final Quantity score) {
                b.add(PROPERTY_SCORE, score);
                return this;
            }

            public Builder method(final CodeableConcept method) {
                b.add(PROPERTY_METHOD, method);
                return this;
            }

            public Builder truthTP(final Double truthTP) {
                b.add(PROPERTY_TRUTH_T_P, truthTP);
                return this;
            }

            public Builder queryTP(final Double queryTP) {
                b.add(PROPERTY_QUERY_T_P, queryTP);
                return this;
            }

            public Builder truthFN(final Double truthFN) {
                b.add(PROPERTY_TRUTH_F_N, truthFN);
                return this;
            }

            public Builder queryFP(final Double queryFP) {
                b.add(PROPERTY_QUERY_F_P, queryFP);
                return this;
            }

            public Builder gtFP(final Double gtFP) {
                b.add(PROPERTY_GT_F_P, gtFP);
                return this;
            }

            public Builder precision(final Double precision) {
                b.add(PROPERTY_PRECISION, precision);
                return this;
            }

            public Builder recall(final Double recall) {
                b.add(PROPERTY_RECALL, recall);
                return this;
            }

            public Builder fScore(final Double fScore) {
                b.add(PROPERTY_F_SCORE, fScore);
                return this;
            }

            public Builder roc(final MolecularSequenceRoc roc) {
                b.add(PROPERTY_ROC, roc);
                return this;
            }

            public MolecularSequenceQuality build() {
                return new MolecularSequenceQuality(b.build());
            }
        }
    }

    public static class MolecularSequenceReferenceSeq extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceReferenceSeq";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CHROMOSOME = "chromosome";
        public static final String PROPERTY_GENOME_BUILD = "genomeBuild";
        public static final String PROPERTY_ORIENTATION = "orientation";
        public static final String PROPERTY_REFERENCE_SEQ_ID = "referenceSeqId";
        public static final String PROPERTY_REFERENCE_SEQ_POINTER = "referenceSeqPointer";
        public static final String PROPERTY_REFERENCE_SEQ_STRING = "referenceSeqString";
        public static final String PROPERTY_STRAND = "strand";
        public static final String PROPERTY_WINDOW_START = "windowStart";
        public static final String PROPERTY_WINDOW_END = "windowEnd";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceReferenceSeq(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural unit composed of a nucleic acid molecule which controls its
         * own replication through the interaction of specific proteins at one or
         * more origins of replication
         * ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
         */
        public CodeableConcept chromosome() {
            return getObject(CodeableConcept.class, PROPERTY_CHROMOSOME);
        }

        /**
         * The Genome Build used for reference, following GRCh build versions
         * e.g. 'GRCh 37'.  Version number must be included if a versioned
         * release of a primary build was used.
         */
        public String genomeBuild() {
            return getString(PROPERTY_GENOME_BUILD);
        }

        /**
         * A relative reference to a DNA strand based on gene orientation. The
         * strand that contains the open reading frame of the gene is the &quot;sense&quot;
         * strand, and the opposite complementary strand is the &quot;antisense&quot;
         * strand.
         */
        public String orientation() {
            return getString(PROPERTY_ORIENTATION);
        }

        /**
         * Reference identifier of reference sequence submitted to NCBI. It must
         * match the type in the MolecularSequence.type field. For example, the
         * prefix, &ldquo;NG_&rdquo; identifies reference sequence for genes, &ldquo;NM_&rdquo; for
         * messenger RNA transcripts, and &ldquo;NP_&rdquo; for amino acid sequences.
         */
        public CodeableConcept referenceSeqId() {
            return getObject(CodeableConcept.class, PROPERTY_REFERENCE_SEQ_ID);
        }

        /**
         * A pointer to another MolecularSequence entity as reference sequence.
         */
        public Reference referenceSeqPointer() {
            return getObject(Reference.class, PROPERTY_REFERENCE_SEQ_POINTER);
        }

        /**
         * A string like &quot;ACGT&quot;.
         */
        public String referenceSeqString() {
            return getString(PROPERTY_REFERENCE_SEQ_STRING);
        }

        /**
         * An absolute reference to a strand. The Watson strand is the strand
         * whose 5'-end is on the short arm of the chromosome, and the Crick
         * strand as the one whose 5'-end is on the long arm.
         */
        public String strand() {
            return getString(PROPERTY_STRAND);
        }

        /**
         * Start position of the window on the reference sequence. If the
         * coordinate system is either 0-based or 1-based, then start position is
         * inclusive.
         */
        public Integer windowStart() {
            return data.getInt(PROPERTY_WINDOW_START);
        }

        /**
         * End position of the window on the reference sequence. If the
         * coordinate system is 0-based then end is exclusive and does not
         * include the last position. If the coordinate system is 1-base, then
         * end is inclusive and includes the last position.
         */
        public Integer windowEnd() {
            return data.getInt(PROPERTY_WINDOW_END);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder chromosome(final CodeableConcept chromosome) {
                b.add(PROPERTY_CHROMOSOME, chromosome);
                return this;
            }

            public Builder genomeBuild(final String genomeBuild) {
                b.add(PROPERTY_GENOME_BUILD, genomeBuild);
                return this;
            }

            public Builder orientation(final String orientation) {
                b.add(PROPERTY_ORIENTATION, orientation);
                return this;
            }

            public Builder referenceSeqId(final CodeableConcept referenceSeqId) {
                b.add(PROPERTY_REFERENCE_SEQ_ID, referenceSeqId);
                return this;
            }

            public Builder referenceSeqPointer(final Reference referenceSeqPointer) {
                b.add(PROPERTY_REFERENCE_SEQ_POINTER, referenceSeqPointer);
                return this;
            }

            public Builder referenceSeqString(final String referenceSeqString) {
                b.add(PROPERTY_REFERENCE_SEQ_STRING, referenceSeqString);
                return this;
            }

            public Builder strand(final String strand) {
                b.add(PROPERTY_STRAND, strand);
                return this;
            }

            public Builder windowStart(final Integer windowStart) {
                b.add(PROPERTY_WINDOW_START, windowStart);
                return this;
            }

            public Builder windowEnd(final Integer windowEnd) {
                b.add(PROPERTY_WINDOW_END, windowEnd);
                return this;
            }

            public MolecularSequenceReferenceSeq build() {
                return new MolecularSequenceReferenceSeq(b.build());
            }
        }
    }

    public static class MolecularSequenceRepository extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceRepository";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_URL = "url";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DATASET_ID = "datasetId";
        public static final String PROPERTY_VARIANTSET_ID = "variantsetId";
        public static final String PROPERTY_READSET_ID = "readsetId";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceRepository(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Click and see / RESTful API / Need login to see / RESTful API with
         * authentication / Other ways to see resource.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * URI of an external repository which contains further details about the
         * genetics data.
         */
        public String url() {
            return getString(PROPERTY_URL);
        }

        /**
         * URI of an external repository which contains further details about the
         * genetics data.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Id of the variant in this external repository. The server will
         * understand how to use this id to call for more info about datasets in
         * external repository.
         */
        public String datasetId() {
            return getString(PROPERTY_DATASET_ID);
        }

        /**
         * Id of the variantset in this external repository. The server will
         * understand how to use this id to call for more info about variantsets
         * in external repository.
         */
        public String variantsetId() {
            return getString(PROPERTY_VARIANTSET_ID);
        }

        /**
         * Id of the read in this external repository.
         */
        public String readsetId() {
            return getString(PROPERTY_READSET_ID);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder url(final String url) {
                b.add(PROPERTY_URL, url);
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder datasetId(final String datasetId) {
                b.add(PROPERTY_DATASET_ID, datasetId);
                return this;
            }

            public Builder variantsetId(final String variantsetId) {
                b.add(PROPERTY_VARIANTSET_ID, variantsetId);
                return this;
            }

            public Builder readsetId(final String readsetId) {
                b.add(PROPERTY_READSET_ID, readsetId);
                return this;
            }

            public MolecularSequenceRepository build() {
                return new MolecularSequenceRepository(b.build());
            }
        }
    }

    public static class MolecularSequenceRoc extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceRoc";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_SCORE = "score";
        public static final String PROPERTY_NUM_T_P = "numTP";
        public static final String PROPERTY_NUM_F_P = "numFP";
        public static final String PROPERTY_NUM_F_N = "numFN";
        public static final String PROPERTY_PRECISION = "precision";
        public static final String PROPERTY_SENSITIVITY = "sensitivity";
        public static final String PROPERTY_F_MEASURE = "fMeasure";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceRoc(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Invidual data point representing the GQ (genotype quality) score
         * threshold.
         */
        public java.util.List<Integer> score() {
            return getList(Integer.class, PROPERTY_SCORE);
        }

        /**
         * The number of true positives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numTP() {
            return getList(Integer.class, PROPERTY_NUM_T_P);
        }

        /**
         * The number of false positives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numFP() {
            return getList(Integer.class, PROPERTY_NUM_F_P);
        }

        /**
         * The number of false negatives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numFN() {
            return getList(Integer.class, PROPERTY_NUM_F_N);
        }

        /**
         * Calculated precision if the GQ score threshold was set to &quot;score&quot;
         * field value.
         */
        public java.util.List<Double> precision() {
            return getList(Double.class, PROPERTY_PRECISION);
        }

        /**
         * Calculated sensitivity if the GQ score threshold was set to &quot;score&quot;
         * field value.
         */
        public java.util.List<Double> sensitivity() {
            return getList(Double.class, PROPERTY_SENSITIVITY);
        }

        /**
         * Calculated fScore if the GQ score threshold was set to &quot;score&quot; field
         * value.
         */
        public java.util.List<Double> fMeasure() {
            return getList(Double.class, PROPERTY_F_MEASURE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder score(final java.util.List<Integer> score) {
                b.add(PROPERTY_SCORE, FhirObject.toIntegerArray(score));
                return this;
            }

            public Builder numTP(final java.util.List<Integer> numTP) {
                b.add(PROPERTY_NUM_T_P, FhirObject.toIntegerArray(numTP));
                return this;
            }

            public Builder numFP(final java.util.List<Integer> numFP) {
                b.add(PROPERTY_NUM_F_P, FhirObject.toIntegerArray(numFP));
                return this;
            }

            public Builder numFN(final java.util.List<Integer> numFN) {
                b.add(PROPERTY_NUM_F_N, FhirObject.toIntegerArray(numFN));
                return this;
            }

            public Builder precision(final java.util.List<Double> precision) {
                b.add(PROPERTY_PRECISION, FhirObject.toDoubleArray(precision));
                return this;
            }

            public Builder sensitivity(final java.util.List<Double> sensitivity) {
                b.add(PROPERTY_SENSITIVITY, FhirObject.toDoubleArray(sensitivity));
                return this;
            }

            public Builder fMeasure(final java.util.List<Double> fMeasure) {
                b.add(PROPERTY_F_MEASURE, FhirObject.toDoubleArray(fMeasure));
                return this;
            }

            public MolecularSequenceRoc build() {
                return new MolecularSequenceRoc(b.build());
            }
        }
    }

    public static class MolecularSequenceStructureVariant extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceStructureVariant";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_VARIANT_TYPE = "variantType";
        public static final String PROPERTY_EXACT = "exact";
        public static final String PROPERTY_LENGTH = "length";
        public static final String PROPERTY_OUTER = "outer";
        public static final String PROPERTY_INNER = "inner";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceStructureVariant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about chromosome structure variation DNA change type.
         */
        public CodeableConcept variantType() {
            return getObject(CodeableConcept.class, PROPERTY_VARIANT_TYPE);
        }

        /**
         * Used to indicate if the outer and inner start-end values have the same
         * meaning.
         */
        public Boolean exact() {
            return data.getBoolean(PROPERTY_EXACT);
        }

        /**
         * Length of the variant chromosome.
         */
        public Integer length() {
            return data.getInt(PROPERTY_LENGTH);
        }

        /**
         * Structural variant outer.
         */
        public MolecularSequenceOuter outer() {
            return getObject(MolecularSequenceOuter.class, PROPERTY_OUTER);
        }

        /**
         * Structural variant inner.
         */
        public MolecularSequenceInner inner() {
            return getObject(MolecularSequenceInner.class, PROPERTY_INNER);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder variantType(final CodeableConcept variantType) {
                b.add(PROPERTY_VARIANT_TYPE, variantType);
                return this;
            }

            public Builder exact(final Boolean exact) {
                b.add(PROPERTY_EXACT, exact);
                return this;
            }

            public Builder length(final Integer length) {
                b.add(PROPERTY_LENGTH, length);
                return this;
            }

            public Builder outer(final MolecularSequenceOuter outer) {
                b.add(PROPERTY_OUTER, outer);
                return this;
            }

            public Builder inner(final MolecularSequenceInner inner) {
                b.add(PROPERTY_INNER, inner);
                return this;
            }

            public MolecularSequenceStructureVariant build() {
                return new MolecularSequenceStructureVariant(b.build());
            }
        }
    }

    public static class MolecularSequenceVariant extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceVariant";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_START = "start";
        public static final String PROPERTY_END = "end";
        public static final String PROPERTY_OBSERVED_ALLELE = "observedAllele";
        public static final String PROPERTY_REFERENCE_ALLELE = "referenceAllele";
        public static final String PROPERTY_CIGAR = "cigar";
        public static final String PROPERTY_VARIANT_POINTER = "variantPointer";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceVariant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Start position of the variant on the  reference sequence. If the
         * coordinate system is either 0-based or 1-based, then start position is
         * inclusive.
         */
        public Integer start() {
            return data.getInt(PROPERTY_START);
        }

        /**
         * End position of the variant on the reference sequence. If the
         * coordinate system is 0-based then end is exclusive and does not
         * include the last position. If the coordinate system is 1-base, then
         * end is inclusive and includes the last position.
         */
        public Integer end() {
            return data.getInt(PROPERTY_END);
        }

        /**
         * An allele is one of a set of coexisting sequence variants of a gene
         * ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
         * Nucleotide(s)/amino acids from start position of sequence to stop
         * position of sequence on the positive (+) strand of the observed 
         * sequence. When the sequence  type is DNA, it should be the sequence on
         * the positive (+) strand. This will lay in the range between
         * variant.start and variant.end.
         */
        public String observedAllele() {
            return getString(PROPERTY_OBSERVED_ALLELE);
        }

        /**
         * An allele is one of a set of coexisting sequence variants of a gene
         * ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
         * Nucleotide(s)/amino acids from start position of sequence to stop
         * position of sequence on the positive (+) strand of the reference
         * sequence. When the sequence  type is DNA, it should be the sequence on
         * the positive (+) strand. This will lay in the range between
         * variant.start and variant.end.
         */
        public String referenceAllele() {
            return getString(PROPERTY_REFERENCE_ALLELE);
        }

        /**
         * Extended CIGAR string for aligning the sequence with reference bases.
         * See detailed documentation
         * [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
         */
        public String cigar() {
            return getString(PROPERTY_CIGAR);
        }

        /**
         * A pointer to an Observation containing variant information.
         */
        public Reference variantPointer() {
            return getObject(Reference.class, PROPERTY_VARIANT_POINTER);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(PROPERTY_END, end);
                return this;
            }

            public Builder observedAllele(final String observedAllele) {
                b.add(PROPERTY_OBSERVED_ALLELE, observedAllele);
                return this;
            }

            public Builder referenceAllele(final String referenceAllele) {
                b.add(PROPERTY_REFERENCE_ALLELE, referenceAllele);
                return this;
            }

            public Builder cigar(final String cigar) {
                b.add(PROPERTY_CIGAR, cigar);
                return this;
            }

            public Builder variantPointer(final Reference variantPointer) {
                b.add(PROPERTY_VARIANT_POINTER, variantPointer);
                return this;
            }

            public MolecularSequenceVariant build() {
                return new MolecularSequenceVariant(b.build());
            }
        }
    }
}
