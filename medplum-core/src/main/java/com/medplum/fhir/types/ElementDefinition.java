/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class ElementDefinition extends FhirResource {
    public static final String RESOURCE_TYPE = "ElementDefinition";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_PATH = "path";
    public static final String PROPERTY_REPRESENTATION = "representation";
    public static final String PROPERTY_SLICENAME = "sliceName";
    public static final String PROPERTY_SLICEISCONSTRAINING = "sliceIsConstraining";
    public static final String PROPERTY_LABEL = "label";
    public static final String PROPERTY_CODE = "code";
    public static final String PROPERTY_SLICING = "slicing";
    public static final String PROPERTY_SHORT = "short";
    public static final String PROPERTY_DEFINITION = "definition";
    public static final String PROPERTY_COMMENT = "comment";
    public static final String PROPERTY_REQUIREMENTS = "requirements";
    public static final String PROPERTY_ALIAS = "alias";
    public static final String PROPERTY_MIN = "min";
    public static final String PROPERTY_MAX = "max";
    public static final String PROPERTY_BASE = "base";
    public static final String PROPERTY_CONTENTREFERENCE = "contentReference";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_DEFAULTVALUEBASE64BINARY = "defaultValueBase64Binary";
    public static final String PROPERTY_DEFAULTVALUEBOOLEAN = "defaultValueBoolean";
    public static final String PROPERTY_DEFAULTVALUECANONICAL = "defaultValueCanonical";
    public static final String PROPERTY_DEFAULTVALUECODE = "defaultValueCode";
    public static final String PROPERTY_DEFAULTVALUEDATE = "defaultValueDate";
    public static final String PROPERTY_DEFAULTVALUEDATETIME = "defaultValueDateTime";
    public static final String PROPERTY_DEFAULTVALUEDECIMAL = "defaultValueDecimal";
    public static final String PROPERTY_DEFAULTVALUEID = "defaultValueId";
    public static final String PROPERTY_DEFAULTVALUEINSTANT = "defaultValueInstant";
    public static final String PROPERTY_DEFAULTVALUEINTEGER = "defaultValueInteger";
    public static final String PROPERTY_DEFAULTVALUEMARKDOWN = "defaultValueMarkdown";
    public static final String PROPERTY_DEFAULTVALUEOID = "defaultValueOid";
    public static final String PROPERTY_DEFAULTVALUEPOSITIVEINT = "defaultValuePositiveInt";
    public static final String PROPERTY_DEFAULTVALUESTRING = "defaultValueString";
    public static final String PROPERTY_DEFAULTVALUETIME = "defaultValueTime";
    public static final String PROPERTY_DEFAULTVALUEUNSIGNEDINT = "defaultValueUnsignedInt";
    public static final String PROPERTY_DEFAULTVALUEURI = "defaultValueUri";
    public static final String PROPERTY_DEFAULTVALUEURL = "defaultValueUrl";
    public static final String PROPERTY_DEFAULTVALUEUUID = "defaultValueUuid";
    public static final String PROPERTY_DEFAULTVALUEADDRESS = "defaultValueAddress";
    public static final String PROPERTY_DEFAULTVALUEAGE = "defaultValueAge";
    public static final String PROPERTY_DEFAULTVALUEANNOTATION = "defaultValueAnnotation";
    public static final String PROPERTY_DEFAULTVALUEATTACHMENT = "defaultValueAttachment";
    public static final String PROPERTY_DEFAULTVALUECODEABLECONCEPT = "defaultValueCodeableConcept";
    public static final String PROPERTY_DEFAULTVALUECODING = "defaultValueCoding";
    public static final String PROPERTY_DEFAULTVALUECONTACTPOINT = "defaultValueContactPoint";
    public static final String PROPERTY_DEFAULTVALUECOUNT = "defaultValueCount";
    public static final String PROPERTY_DEFAULTVALUEDISTANCE = "defaultValueDistance";
    public static final String PROPERTY_DEFAULTVALUEDURATION = "defaultValueDuration";
    public static final String PROPERTY_DEFAULTVALUEHUMANNAME = "defaultValueHumanName";
    public static final String PROPERTY_DEFAULTVALUEIDENTIFIER = "defaultValueIdentifier";
    public static final String PROPERTY_DEFAULTVALUEMONEY = "defaultValueMoney";
    public static final String PROPERTY_DEFAULTVALUEPERIOD = "defaultValuePeriod";
    public static final String PROPERTY_DEFAULTVALUEQUANTITY = "defaultValueQuantity";
    public static final String PROPERTY_DEFAULTVALUERANGE = "defaultValueRange";
    public static final String PROPERTY_DEFAULTVALUERATIO = "defaultValueRatio";
    public static final String PROPERTY_DEFAULTVALUEREFERENCE = "defaultValueReference";
    public static final String PROPERTY_DEFAULTVALUESAMPLEDDATA = "defaultValueSampledData";
    public static final String PROPERTY_DEFAULTVALUESIGNATURE = "defaultValueSignature";
    public static final String PROPERTY_DEFAULTVALUETIMING = "defaultValueTiming";
    public static final String PROPERTY_DEFAULTVALUECONTACTDETAIL = "defaultValueContactDetail";
    public static final String PROPERTY_DEFAULTVALUECONTRIBUTOR = "defaultValueContributor";
    public static final String PROPERTY_DEFAULTVALUEDATAREQUIREMENT = "defaultValueDataRequirement";
    public static final String PROPERTY_DEFAULTVALUEEXPRESSION = "defaultValueExpression";
    public static final String PROPERTY_DEFAULTVALUEPARAMETERDEFINITION = "defaultValueParameterDefinition";
    public static final String PROPERTY_DEFAULTVALUERELATEDARTIFACT = "defaultValueRelatedArtifact";
    public static final String PROPERTY_DEFAULTVALUETRIGGERDEFINITION = "defaultValueTriggerDefinition";
    public static final String PROPERTY_DEFAULTVALUEUSAGECONTEXT = "defaultValueUsageContext";
    public static final String PROPERTY_DEFAULTVALUEDOSAGE = "defaultValueDosage";
    public static final String PROPERTY_DEFAULTVALUEMETA = "defaultValueMeta";
    public static final String PROPERTY_MEANINGWHENMISSING = "meaningWhenMissing";
    public static final String PROPERTY_ORDERMEANING = "orderMeaning";
    public static final String PROPERTY_FIXEDBASE64BINARY = "fixedBase64Binary";
    public static final String PROPERTY_FIXEDBOOLEAN = "fixedBoolean";
    public static final String PROPERTY_FIXEDCANONICAL = "fixedCanonical";
    public static final String PROPERTY_FIXEDCODE = "fixedCode";
    public static final String PROPERTY_FIXEDDATE = "fixedDate";
    public static final String PROPERTY_FIXEDDATETIME = "fixedDateTime";
    public static final String PROPERTY_FIXEDDECIMAL = "fixedDecimal";
    public static final String PROPERTY_FIXEDID = "fixedId";
    public static final String PROPERTY_FIXEDINSTANT = "fixedInstant";
    public static final String PROPERTY_FIXEDINTEGER = "fixedInteger";
    public static final String PROPERTY_FIXEDMARKDOWN = "fixedMarkdown";
    public static final String PROPERTY_FIXEDOID = "fixedOid";
    public static final String PROPERTY_FIXEDPOSITIVEINT = "fixedPositiveInt";
    public static final String PROPERTY_FIXEDSTRING = "fixedString";
    public static final String PROPERTY_FIXEDTIME = "fixedTime";
    public static final String PROPERTY_FIXEDUNSIGNEDINT = "fixedUnsignedInt";
    public static final String PROPERTY_FIXEDURI = "fixedUri";
    public static final String PROPERTY_FIXEDURL = "fixedUrl";
    public static final String PROPERTY_FIXEDUUID = "fixedUuid";
    public static final String PROPERTY_FIXEDADDRESS = "fixedAddress";
    public static final String PROPERTY_FIXEDAGE = "fixedAge";
    public static final String PROPERTY_FIXEDANNOTATION = "fixedAnnotation";
    public static final String PROPERTY_FIXEDATTACHMENT = "fixedAttachment";
    public static final String PROPERTY_FIXEDCODEABLECONCEPT = "fixedCodeableConcept";
    public static final String PROPERTY_FIXEDCODING = "fixedCoding";
    public static final String PROPERTY_FIXEDCONTACTPOINT = "fixedContactPoint";
    public static final String PROPERTY_FIXEDCOUNT = "fixedCount";
    public static final String PROPERTY_FIXEDDISTANCE = "fixedDistance";
    public static final String PROPERTY_FIXEDDURATION = "fixedDuration";
    public static final String PROPERTY_FIXEDHUMANNAME = "fixedHumanName";
    public static final String PROPERTY_FIXEDIDENTIFIER = "fixedIdentifier";
    public static final String PROPERTY_FIXEDMONEY = "fixedMoney";
    public static final String PROPERTY_FIXEDPERIOD = "fixedPeriod";
    public static final String PROPERTY_FIXEDQUANTITY = "fixedQuantity";
    public static final String PROPERTY_FIXEDRANGE = "fixedRange";
    public static final String PROPERTY_FIXEDRATIO = "fixedRatio";
    public static final String PROPERTY_FIXEDREFERENCE = "fixedReference";
    public static final String PROPERTY_FIXEDSAMPLEDDATA = "fixedSampledData";
    public static final String PROPERTY_FIXEDSIGNATURE = "fixedSignature";
    public static final String PROPERTY_FIXEDTIMING = "fixedTiming";
    public static final String PROPERTY_FIXEDCONTACTDETAIL = "fixedContactDetail";
    public static final String PROPERTY_FIXEDCONTRIBUTOR = "fixedContributor";
    public static final String PROPERTY_FIXEDDATAREQUIREMENT = "fixedDataRequirement";
    public static final String PROPERTY_FIXEDEXPRESSION = "fixedExpression";
    public static final String PROPERTY_FIXEDPARAMETERDEFINITION = "fixedParameterDefinition";
    public static final String PROPERTY_FIXEDRELATEDARTIFACT = "fixedRelatedArtifact";
    public static final String PROPERTY_FIXEDTRIGGERDEFINITION = "fixedTriggerDefinition";
    public static final String PROPERTY_FIXEDUSAGECONTEXT = "fixedUsageContext";
    public static final String PROPERTY_FIXEDDOSAGE = "fixedDosage";
    public static final String PROPERTY_FIXEDMETA = "fixedMeta";
    public static final String PROPERTY_PATTERNBASE64BINARY = "patternBase64Binary";
    public static final String PROPERTY_PATTERNBOOLEAN = "patternBoolean";
    public static final String PROPERTY_PATTERNCANONICAL = "patternCanonical";
    public static final String PROPERTY_PATTERNCODE = "patternCode";
    public static final String PROPERTY_PATTERNDATE = "patternDate";
    public static final String PROPERTY_PATTERNDATETIME = "patternDateTime";
    public static final String PROPERTY_PATTERNDECIMAL = "patternDecimal";
    public static final String PROPERTY_PATTERNID = "patternId";
    public static final String PROPERTY_PATTERNINSTANT = "patternInstant";
    public static final String PROPERTY_PATTERNINTEGER = "patternInteger";
    public static final String PROPERTY_PATTERNMARKDOWN = "patternMarkdown";
    public static final String PROPERTY_PATTERNOID = "patternOid";
    public static final String PROPERTY_PATTERNPOSITIVEINT = "patternPositiveInt";
    public static final String PROPERTY_PATTERNSTRING = "patternString";
    public static final String PROPERTY_PATTERNTIME = "patternTime";
    public static final String PROPERTY_PATTERNUNSIGNEDINT = "patternUnsignedInt";
    public static final String PROPERTY_PATTERNURI = "patternUri";
    public static final String PROPERTY_PATTERNURL = "patternUrl";
    public static final String PROPERTY_PATTERNUUID = "patternUuid";
    public static final String PROPERTY_PATTERNADDRESS = "patternAddress";
    public static final String PROPERTY_PATTERNAGE = "patternAge";
    public static final String PROPERTY_PATTERNANNOTATION = "patternAnnotation";
    public static final String PROPERTY_PATTERNATTACHMENT = "patternAttachment";
    public static final String PROPERTY_PATTERNCODEABLECONCEPT = "patternCodeableConcept";
    public static final String PROPERTY_PATTERNCODING = "patternCoding";
    public static final String PROPERTY_PATTERNCONTACTPOINT = "patternContactPoint";
    public static final String PROPERTY_PATTERNCOUNT = "patternCount";
    public static final String PROPERTY_PATTERNDISTANCE = "patternDistance";
    public static final String PROPERTY_PATTERNDURATION = "patternDuration";
    public static final String PROPERTY_PATTERNHUMANNAME = "patternHumanName";
    public static final String PROPERTY_PATTERNIDENTIFIER = "patternIdentifier";
    public static final String PROPERTY_PATTERNMONEY = "patternMoney";
    public static final String PROPERTY_PATTERNPERIOD = "patternPeriod";
    public static final String PROPERTY_PATTERNQUANTITY = "patternQuantity";
    public static final String PROPERTY_PATTERNRANGE = "patternRange";
    public static final String PROPERTY_PATTERNRATIO = "patternRatio";
    public static final String PROPERTY_PATTERNREFERENCE = "patternReference";
    public static final String PROPERTY_PATTERNSAMPLEDDATA = "patternSampledData";
    public static final String PROPERTY_PATTERNSIGNATURE = "patternSignature";
    public static final String PROPERTY_PATTERNTIMING = "patternTiming";
    public static final String PROPERTY_PATTERNCONTACTDETAIL = "patternContactDetail";
    public static final String PROPERTY_PATTERNCONTRIBUTOR = "patternContributor";
    public static final String PROPERTY_PATTERNDATAREQUIREMENT = "patternDataRequirement";
    public static final String PROPERTY_PATTERNEXPRESSION = "patternExpression";
    public static final String PROPERTY_PATTERNPARAMETERDEFINITION = "patternParameterDefinition";
    public static final String PROPERTY_PATTERNRELATEDARTIFACT = "patternRelatedArtifact";
    public static final String PROPERTY_PATTERNTRIGGERDEFINITION = "patternTriggerDefinition";
    public static final String PROPERTY_PATTERNUSAGECONTEXT = "patternUsageContext";
    public static final String PROPERTY_PATTERNDOSAGE = "patternDosage";
    public static final String PROPERTY_PATTERNMETA = "patternMeta";
    public static final String PROPERTY_EXAMPLE = "example";
    public static final String PROPERTY_MINVALUEDATE = "minValueDate";
    public static final String PROPERTY_MINVALUEDATETIME = "minValueDateTime";
    public static final String PROPERTY_MINVALUEINSTANT = "minValueInstant";
    public static final String PROPERTY_MINVALUETIME = "minValueTime";
    public static final String PROPERTY_MINVALUEDECIMAL = "minValueDecimal";
    public static final String PROPERTY_MINVALUEINTEGER = "minValueInteger";
    public static final String PROPERTY_MINVALUEPOSITIVEINT = "minValuePositiveInt";
    public static final String PROPERTY_MINVALUEUNSIGNEDINT = "minValueUnsignedInt";
    public static final String PROPERTY_MINVALUEQUANTITY = "minValueQuantity";
    public static final String PROPERTY_MAXVALUEDATE = "maxValueDate";
    public static final String PROPERTY_MAXVALUEDATETIME = "maxValueDateTime";
    public static final String PROPERTY_MAXVALUEINSTANT = "maxValueInstant";
    public static final String PROPERTY_MAXVALUETIME = "maxValueTime";
    public static final String PROPERTY_MAXVALUEDECIMAL = "maxValueDecimal";
    public static final String PROPERTY_MAXVALUEINTEGER = "maxValueInteger";
    public static final String PROPERTY_MAXVALUEPOSITIVEINT = "maxValuePositiveInt";
    public static final String PROPERTY_MAXVALUEUNSIGNEDINT = "maxValueUnsignedInt";
    public static final String PROPERTY_MAXVALUEQUANTITY = "maxValueQuantity";
    public static final String PROPERTY_MAXLENGTH = "maxLength";
    public static final String PROPERTY_CONDITION = "condition";
    public static final String PROPERTY_CONSTRAINT = "constraint";
    public static final String PROPERTY_MUSTSUPPORT = "mustSupport";
    public static final String PROPERTY_ISMODIFIER = "isModifier";
    public static final String PROPERTY_ISMODIFIERREASON = "isModifierReason";
    public static final String PROPERTY_ISSUMMARY = "isSummary";
    public static final String PROPERTY_BINDING = "binding";
    public static final String PROPERTY_MAPPING = "mapping";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public ElementDefinition(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element and that modifies the
     * understanding of the element in which it is contained and/or the
     * understanding of the containing element's descendants. Usually
     * modifier elements provide negation or qualification. To make the use
     * of extensions safe and manageable, there is a strict set of governance
     * applied to the definition and use of extensions. Though any
     * implementer can define an extension, there is a set of requirements
     * that SHALL be met as part of the definition of the extension.
     * Applications processing a resource are required to check for modifier
     * extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * The path identifies the element and is expressed as a "."-separated
     * list of ancestor elements, beginning with the name of the resource or
     * extension.
     */
    public String path() {
        return getString(PROPERTY_PATH);
    }

    /**
     * Codes that define how this element is represented in instances, when
     * the deviation varies from the normal case.
     */
    public java.util.List<String> representation() {
        return getList(String.class, PROPERTY_REPRESENTATION);
    }

    /**
     * The name of this element definition slice, when slicing is working.
     * The name must be a token with no dots or spaces. This is a unique name
     * referring to a specific set of constraints applied to this element,
     * used to provide a name to different slices of the same element.
     */
    public String sliceName() {
        return getString(PROPERTY_SLICENAME);
    }

    /**
     * If true, indicates that this slice definition is constraining a slice
     * definition with the same name in an inherited profile. If false, the
     * slice is not overriding any slice in an inherited profile. If missing,
     * the slice might or might not be overriding a slice in an inherited
     * profile, depending on the sliceName.
     */
    public Boolean sliceIsConstraining() {
        return data.getBoolean(PROPERTY_SLICEISCONSTRAINING);
    }

    /**
     * A single preferred label which is the text to display beside the
     * element indicating its meaning or to use to prompt for the element in
     * a user display or form.
     */
    public String label() {
        return getString(PROPERTY_LABEL);
    }

    /**
     * A code that has the same meaning as the element in a particular
     * terminology.
     */
    public java.util.List<Coding> code() {
        return getList(Coding.class, PROPERTY_CODE);
    }

    /**
     * Indicates that the element is sliced into a set of alternative
     * definitions (i.e. in a structure definition, there are multiple
     * different constraints on a single element in the base resource).
     * Slicing can be used in any resource that has cardinality ..* on the
     * base resource, or any resource with a choice of types. The set of
     * slices is any elements that come after this in the element sequence
     * that have the same path, until a shorter path occurs (the shorter path
     * terminates the set).
     */
    public ElementDefinitionSlicing slicing() {
        return getObject(ElementDefinitionSlicing.class, PROPERTY_SLICING);
    }

    /**
     * A concise description of what this element means (e.g. for use in
     * autogenerated summaries).
     */
    public String shortValue() {
        return getString(PROPERTY_SHORT);
    }

    /**
     * Provides a complete explanation of the meaning of the data element for
     * human readability.  For the case of elements derived from existing
     * elements (e.g. constraints), the definition SHALL be consistent with
     * the base definition, but convey the meaning of the element in the
     * particular context of use of the resource. (Note: The text you are
     * reading is specified in ElementDefinition.definition).
     */
    public String definition() {
        return getString(PROPERTY_DEFINITION);
    }

    /**
     * Explanatory notes and implementation guidance about the data element,
     * including notes about how to use the data properly, exceptions to
     * proper use, etc. (Note: The text you are reading is specified in
     * ElementDefinition.comment).
     */
    public String comment() {
        return getString(PROPERTY_COMMENT);
    }

    /**
     * This element is for traceability of why the element was created and
     * why the constraints exist as they do. This may be used to point to
     * source materials or specifications that drove the structure of this
     * element.
     */
    public String requirements() {
        return getString(PROPERTY_REQUIREMENTS);
    }

    /**
     * Identifies additional names by which this element might also be known.
     */
    public java.util.List<String> alias() {
        return getList(String.class, PROPERTY_ALIAS);
    }

    /**
     * The minimum number of times this element SHALL appear in the instance.
     */
    public Integer min() {
        return data.getInt(PROPERTY_MIN);
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * instance.
     */
    public String max() {
        return getString(PROPERTY_MAX);
    }

    /**
     * Information about the base definition of the element, provided to make
     * it unnecessary for tools to trace the deviation of the element through
     * the derived and related profiles. When the element definition is not
     * the original definition of an element - i.g. either in a constraint on
     * another type, or for elements from a super type in a snap shot - then
     * the information in provided in the element definition may be different
     * to the base definition. On the original definition of the element, it
     * will be same.
     */
    public ElementDefinitionBase base() {
        return getObject(ElementDefinitionBase.class, PROPERTY_BASE);
    }

    /**
     * Identifies an element defined elsewhere in the definition whose
     * content rules should be applied to the current element.
     * ContentReferences bring across all the rules that are in the
     * ElementDefinition for the element, including definitions, cardinality
     * constraints, bindings, invariants etc.
     */
    public String contentReference() {
        return getString(PROPERTY_CONTENTREFERENCE);
    }

    /**
     * The data type or resource that the value of this element is permitted
     * to be.
     */
    public java.util.List<ElementDefinitionType> type() {
        return getList(ElementDefinitionType.class, PROPERTY_TYPE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueBase64Binary() {
        return getString(PROPERTY_DEFAULTVALUEBASE64BINARY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Boolean defaultValueBoolean() {
        return data.getBoolean(PROPERTY_DEFAULTVALUEBOOLEAN);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueCanonical() {
        return getString(PROPERTY_DEFAULTVALUECANONICAL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueCode() {
        return getString(PROPERTY_DEFAULTVALUECODE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueDate() {
        return getString(PROPERTY_DEFAULTVALUEDATE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueDateTime() {
        return getString(PROPERTY_DEFAULTVALUEDATETIME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueDecimal() {
        return data.getInt(PROPERTY_DEFAULTVALUEDECIMAL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueId() {
        return getString(PROPERTY_DEFAULTVALUEID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueInstant() {
        return getString(PROPERTY_DEFAULTVALUEINSTANT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueInteger() {
        return data.getInt(PROPERTY_DEFAULTVALUEINTEGER);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueMarkdown() {
        return getString(PROPERTY_DEFAULTVALUEMARKDOWN);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueOid() {
        return getString(PROPERTY_DEFAULTVALUEOID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValuePositiveInt() {
        return data.getInt(PROPERTY_DEFAULTVALUEPOSITIVEINT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueString() {
        return getString(PROPERTY_DEFAULTVALUESTRING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueTime() {
        return getString(PROPERTY_DEFAULTVALUETIME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueUnsignedInt() {
        return data.getInt(PROPERTY_DEFAULTVALUEUNSIGNEDINT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUri() {
        return getString(PROPERTY_DEFAULTVALUEURI);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUrl() {
        return getString(PROPERTY_DEFAULTVALUEURL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUuid() {
        return getString(PROPERTY_DEFAULTVALUEUUID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Address defaultValueAddress() {
        return getObject(Address.class, PROPERTY_DEFAULTVALUEADDRESS);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Age defaultValueAge() {
        return getObject(Age.class, PROPERTY_DEFAULTVALUEAGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Annotation defaultValueAnnotation() {
        return getObject(Annotation.class, PROPERTY_DEFAULTVALUEANNOTATION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Attachment defaultValueAttachment() {
        return getObject(Attachment.class, PROPERTY_DEFAULTVALUEATTACHMENT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public CodeableConcept defaultValueCodeableConcept() {
        return getObject(CodeableConcept.class, PROPERTY_DEFAULTVALUECODEABLECONCEPT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Coding defaultValueCoding() {
        return getObject(Coding.class, PROPERTY_DEFAULTVALUECODING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ContactPoint defaultValueContactPoint() {
        return getObject(ContactPoint.class, PROPERTY_DEFAULTVALUECONTACTPOINT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Count defaultValueCount() {
        return getObject(Count.class, PROPERTY_DEFAULTVALUECOUNT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Distance defaultValueDistance() {
        return getObject(Distance.class, PROPERTY_DEFAULTVALUEDISTANCE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Duration defaultValueDuration() {
        return getObject(Duration.class, PROPERTY_DEFAULTVALUEDURATION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public HumanName defaultValueHumanName() {
        return getObject(HumanName.class, PROPERTY_DEFAULTVALUEHUMANNAME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Identifier defaultValueIdentifier() {
        return getObject(Identifier.class, PROPERTY_DEFAULTVALUEIDENTIFIER);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Money defaultValueMoney() {
        return getObject(Money.class, PROPERTY_DEFAULTVALUEMONEY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Period defaultValuePeriod() {
        return getObject(Period.class, PROPERTY_DEFAULTVALUEPERIOD);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Quantity defaultValueQuantity() {
        return getObject(Quantity.class, PROPERTY_DEFAULTVALUEQUANTITY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Range defaultValueRange() {
        return getObject(Range.class, PROPERTY_DEFAULTVALUERANGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Ratio defaultValueRatio() {
        return getObject(Ratio.class, PROPERTY_DEFAULTVALUERATIO);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Reference defaultValueReference() {
        return getObject(Reference.class, PROPERTY_DEFAULTVALUEREFERENCE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public SampledData defaultValueSampledData() {
        return getObject(SampledData.class, PROPERTY_DEFAULTVALUESAMPLEDDATA);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Signature defaultValueSignature() {
        return getObject(Signature.class, PROPERTY_DEFAULTVALUESIGNATURE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Timing defaultValueTiming() {
        return getObject(Timing.class, PROPERTY_DEFAULTVALUETIMING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ContactDetail defaultValueContactDetail() {
        return getObject(ContactDetail.class, PROPERTY_DEFAULTVALUECONTACTDETAIL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Contributor defaultValueContributor() {
        return getObject(Contributor.class, PROPERTY_DEFAULTVALUECONTRIBUTOR);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public DataRequirement defaultValueDataRequirement() {
        return getObject(DataRequirement.class, PROPERTY_DEFAULTVALUEDATAREQUIREMENT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Expression defaultValueExpression() {
        return getObject(Expression.class, PROPERTY_DEFAULTVALUEEXPRESSION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ParameterDefinition defaultValueParameterDefinition() {
        return getObject(ParameterDefinition.class, PROPERTY_DEFAULTVALUEPARAMETERDEFINITION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public RelatedArtifact defaultValueRelatedArtifact() {
        return getObject(RelatedArtifact.class, PROPERTY_DEFAULTVALUERELATEDARTIFACT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public TriggerDefinition defaultValueTriggerDefinition() {
        return getObject(TriggerDefinition.class, PROPERTY_DEFAULTVALUETRIGGERDEFINITION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public UsageContext defaultValueUsageContext() {
        return getObject(UsageContext.class, PROPERTY_DEFAULTVALUEUSAGECONTEXT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Dosage defaultValueDosage() {
        return getObject(Dosage.class, PROPERTY_DEFAULTVALUEDOSAGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Meta defaultValueMeta() {
        return getObject(Meta.class, PROPERTY_DEFAULTVALUEMETA);
    }

    /**
     * The Implicit meaning that is to be understood when this element is
     * missing (e.g. 'when this element is missing, the period is ongoing').
     */
    public String meaningWhenMissing() {
        return getString(PROPERTY_MEANINGWHENMISSING);
    }

    /**
     * If present, indicates that the order of the repeating element has
     * meaning and describes what that meaning is.  If absent, it means that
     * the order of the element has no meaning.
     */
    public String orderMeaning() {
        return getString(PROPERTY_ORDERMEANING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedBase64Binary() {
        return getString(PROPERTY_FIXEDBASE64BINARY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Boolean fixedBoolean() {
        return data.getBoolean(PROPERTY_FIXEDBOOLEAN);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedCanonical() {
        return getString(PROPERTY_FIXEDCANONICAL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedCode() {
        return getString(PROPERTY_FIXEDCODE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedDate() {
        return getString(PROPERTY_FIXEDDATE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedDateTime() {
        return getString(PROPERTY_FIXEDDATETIME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedDecimal() {
        return data.getInt(PROPERTY_FIXEDDECIMAL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedId() {
        return getString(PROPERTY_FIXEDID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedInstant() {
        return getString(PROPERTY_FIXEDINSTANT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedInteger() {
        return data.getInt(PROPERTY_FIXEDINTEGER);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedMarkdown() {
        return getString(PROPERTY_FIXEDMARKDOWN);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedOid() {
        return getString(PROPERTY_FIXEDOID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedPositiveInt() {
        return data.getInt(PROPERTY_FIXEDPOSITIVEINT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedString() {
        return getString(PROPERTY_FIXEDSTRING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedTime() {
        return getString(PROPERTY_FIXEDTIME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedUnsignedInt() {
        return data.getInt(PROPERTY_FIXEDUNSIGNEDINT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUri() {
        return getString(PROPERTY_FIXEDURI);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUrl() {
        return getString(PROPERTY_FIXEDURL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUuid() {
        return getString(PROPERTY_FIXEDUUID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Address fixedAddress() {
        return getObject(Address.class, PROPERTY_FIXEDADDRESS);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Age fixedAge() {
        return getObject(Age.class, PROPERTY_FIXEDAGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Annotation fixedAnnotation() {
        return getObject(Annotation.class, PROPERTY_FIXEDANNOTATION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Attachment fixedAttachment() {
        return getObject(Attachment.class, PROPERTY_FIXEDATTACHMENT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public CodeableConcept fixedCodeableConcept() {
        return getObject(CodeableConcept.class, PROPERTY_FIXEDCODEABLECONCEPT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Coding fixedCoding() {
        return getObject(Coding.class, PROPERTY_FIXEDCODING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ContactPoint fixedContactPoint() {
        return getObject(ContactPoint.class, PROPERTY_FIXEDCONTACTPOINT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Count fixedCount() {
        return getObject(Count.class, PROPERTY_FIXEDCOUNT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Distance fixedDistance() {
        return getObject(Distance.class, PROPERTY_FIXEDDISTANCE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Duration fixedDuration() {
        return getObject(Duration.class, PROPERTY_FIXEDDURATION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public HumanName fixedHumanName() {
        return getObject(HumanName.class, PROPERTY_FIXEDHUMANNAME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Identifier fixedIdentifier() {
        return getObject(Identifier.class, PROPERTY_FIXEDIDENTIFIER);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Money fixedMoney() {
        return getObject(Money.class, PROPERTY_FIXEDMONEY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Period fixedPeriod() {
        return getObject(Period.class, PROPERTY_FIXEDPERIOD);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Quantity fixedQuantity() {
        return getObject(Quantity.class, PROPERTY_FIXEDQUANTITY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Range fixedRange() {
        return getObject(Range.class, PROPERTY_FIXEDRANGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Ratio fixedRatio() {
        return getObject(Ratio.class, PROPERTY_FIXEDRATIO);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Reference fixedReference() {
        return getObject(Reference.class, PROPERTY_FIXEDREFERENCE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public SampledData fixedSampledData() {
        return getObject(SampledData.class, PROPERTY_FIXEDSAMPLEDDATA);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Signature fixedSignature() {
        return getObject(Signature.class, PROPERTY_FIXEDSIGNATURE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Timing fixedTiming() {
        return getObject(Timing.class, PROPERTY_FIXEDTIMING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ContactDetail fixedContactDetail() {
        return getObject(ContactDetail.class, PROPERTY_FIXEDCONTACTDETAIL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Contributor fixedContributor() {
        return getObject(Contributor.class, PROPERTY_FIXEDCONTRIBUTOR);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public DataRequirement fixedDataRequirement() {
        return getObject(DataRequirement.class, PROPERTY_FIXEDDATAREQUIREMENT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Expression fixedExpression() {
        return getObject(Expression.class, PROPERTY_FIXEDEXPRESSION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ParameterDefinition fixedParameterDefinition() {
        return getObject(ParameterDefinition.class, PROPERTY_FIXEDPARAMETERDEFINITION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public RelatedArtifact fixedRelatedArtifact() {
        return getObject(RelatedArtifact.class, PROPERTY_FIXEDRELATEDARTIFACT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public TriggerDefinition fixedTriggerDefinition() {
        return getObject(TriggerDefinition.class, PROPERTY_FIXEDTRIGGERDEFINITION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public UsageContext fixedUsageContext() {
        return getObject(UsageContext.class, PROPERTY_FIXEDUSAGECONTEXT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Dosage fixedDosage() {
        return getObject(Dosage.class, PROPERTY_FIXEDDOSAGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Meta fixedMeta() {
        return getObject(Meta.class, PROPERTY_FIXEDMETA);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternBase64Binary() {
        return getString(PROPERTY_PATTERNBASE64BINARY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Boolean patternBoolean() {
        return data.getBoolean(PROPERTY_PATTERNBOOLEAN);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternCanonical() {
        return getString(PROPERTY_PATTERNCANONICAL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternCode() {
        return getString(PROPERTY_PATTERNCODE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternDate() {
        return getString(PROPERTY_PATTERNDATE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternDateTime() {
        return getString(PROPERTY_PATTERNDATETIME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternDecimal() {
        return data.getInt(PROPERTY_PATTERNDECIMAL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternId() {
        return getString(PROPERTY_PATTERNID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternInstant() {
        return getString(PROPERTY_PATTERNINSTANT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternInteger() {
        return data.getInt(PROPERTY_PATTERNINTEGER);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternMarkdown() {
        return getString(PROPERTY_PATTERNMARKDOWN);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternOid() {
        return getString(PROPERTY_PATTERNOID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternPositiveInt() {
        return data.getInt(PROPERTY_PATTERNPOSITIVEINT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternString() {
        return getString(PROPERTY_PATTERNSTRING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternTime() {
        return getString(PROPERTY_PATTERNTIME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternUnsignedInt() {
        return data.getInt(PROPERTY_PATTERNUNSIGNEDINT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUri() {
        return getString(PROPERTY_PATTERNURI);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUrl() {
        return getString(PROPERTY_PATTERNURL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUuid() {
        return getString(PROPERTY_PATTERNUUID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Address patternAddress() {
        return getObject(Address.class, PROPERTY_PATTERNADDRESS);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Age patternAge() {
        return getObject(Age.class, PROPERTY_PATTERNAGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Annotation patternAnnotation() {
        return getObject(Annotation.class, PROPERTY_PATTERNANNOTATION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Attachment patternAttachment() {
        return getObject(Attachment.class, PROPERTY_PATTERNATTACHMENT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public CodeableConcept patternCodeableConcept() {
        return getObject(CodeableConcept.class, PROPERTY_PATTERNCODEABLECONCEPT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Coding patternCoding() {
        return getObject(Coding.class, PROPERTY_PATTERNCODING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ContactPoint patternContactPoint() {
        return getObject(ContactPoint.class, PROPERTY_PATTERNCONTACTPOINT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Count patternCount() {
        return getObject(Count.class, PROPERTY_PATTERNCOUNT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Distance patternDistance() {
        return getObject(Distance.class, PROPERTY_PATTERNDISTANCE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Duration patternDuration() {
        return getObject(Duration.class, PROPERTY_PATTERNDURATION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public HumanName patternHumanName() {
        return getObject(HumanName.class, PROPERTY_PATTERNHUMANNAME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Identifier patternIdentifier() {
        return getObject(Identifier.class, PROPERTY_PATTERNIDENTIFIER);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Money patternMoney() {
        return getObject(Money.class, PROPERTY_PATTERNMONEY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Period patternPeriod() {
        return getObject(Period.class, PROPERTY_PATTERNPERIOD);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Quantity patternQuantity() {
        return getObject(Quantity.class, PROPERTY_PATTERNQUANTITY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Range patternRange() {
        return getObject(Range.class, PROPERTY_PATTERNRANGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Ratio patternRatio() {
        return getObject(Ratio.class, PROPERTY_PATTERNRATIO);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Reference patternReference() {
        return getObject(Reference.class, PROPERTY_PATTERNREFERENCE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public SampledData patternSampledData() {
        return getObject(SampledData.class, PROPERTY_PATTERNSAMPLEDDATA);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Signature patternSignature() {
        return getObject(Signature.class, PROPERTY_PATTERNSIGNATURE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Timing patternTiming() {
        return getObject(Timing.class, PROPERTY_PATTERNTIMING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ContactDetail patternContactDetail() {
        return getObject(ContactDetail.class, PROPERTY_PATTERNCONTACTDETAIL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Contributor patternContributor() {
        return getObject(Contributor.class, PROPERTY_PATTERNCONTRIBUTOR);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public DataRequirement patternDataRequirement() {
        return getObject(DataRequirement.class, PROPERTY_PATTERNDATAREQUIREMENT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Expression patternExpression() {
        return getObject(Expression.class, PROPERTY_PATTERNEXPRESSION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ParameterDefinition patternParameterDefinition() {
        return getObject(ParameterDefinition.class, PROPERTY_PATTERNPARAMETERDEFINITION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public RelatedArtifact patternRelatedArtifact() {
        return getObject(RelatedArtifact.class, PROPERTY_PATTERNRELATEDARTIFACT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public TriggerDefinition patternTriggerDefinition() {
        return getObject(TriggerDefinition.class, PROPERTY_PATTERNTRIGGERDEFINITION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public UsageContext patternUsageContext() {
        return getObject(UsageContext.class, PROPERTY_PATTERNUSAGECONTEXT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Dosage patternDosage() {
        return getObject(Dosage.class, PROPERTY_PATTERNDOSAGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.  
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Meta patternMeta() {
        return getObject(Meta.class, PROPERTY_PATTERNMETA);
    }

    /**
     * A sample value for this element demonstrating the type of information
     * that would typically be found in the element.
     */
    public java.util.List<ElementDefinitionExample> example() {
        return getList(ElementDefinitionExample.class, PROPERTY_EXAMPLE);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueDate() {
        return getString(PROPERTY_MINVALUEDATE);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueDateTime() {
        return getString(PROPERTY_MINVALUEDATETIME);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueInstant() {
        return getString(PROPERTY_MINVALUEINSTANT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueTime() {
        return getString(PROPERTY_MINVALUETIME);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueDecimal() {
        return data.getInt(PROPERTY_MINVALUEDECIMAL);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueInteger() {
        return data.getInt(PROPERTY_MINVALUEINTEGER);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValuePositiveInt() {
        return data.getInt(PROPERTY_MINVALUEPOSITIVEINT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueUnsignedInt() {
        return data.getInt(PROPERTY_MINVALUEUNSIGNEDINT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Quantity minValueQuantity() {
        return getObject(Quantity.class, PROPERTY_MINVALUEQUANTITY);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueDate() {
        return getString(PROPERTY_MAXVALUEDATE);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueDateTime() {
        return getString(PROPERTY_MAXVALUEDATETIME);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueInstant() {
        return getString(PROPERTY_MAXVALUEINSTANT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueTime() {
        return getString(PROPERTY_MAXVALUETIME);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueDecimal() {
        return data.getInt(PROPERTY_MAXVALUEDECIMAL);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueInteger() {
        return data.getInt(PROPERTY_MAXVALUEINTEGER);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValuePositiveInt() {
        return data.getInt(PROPERTY_MAXVALUEPOSITIVEINT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueUnsignedInt() {
        return data.getInt(PROPERTY_MAXVALUEUNSIGNEDINT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Quantity maxValueQuantity() {
        return getObject(Quantity.class, PROPERTY_MAXVALUEQUANTITY);
    }

    /**
     * Indicates the maximum length in characters that is permitted to be
     * present in conformant instances and which is expected to be supported
     * by conformant consumers that support the element.
     */
    public Integer maxLength() {
        return data.getInt(PROPERTY_MAXLENGTH);
    }

    /**
     * A reference to an invariant that may make additional statements about
     * the cardinality or value in the instance.
     */
    public java.util.List<String> condition() {
        return getList(String.class, PROPERTY_CONDITION);
    }

    /**
     * Formal constraints such as co-occurrence and other constraints that
     * can be computationally evaluated within the context of the instance.
     */
    public java.util.List<ElementDefinitionConstraint> constraint() {
        return getList(ElementDefinitionConstraint.class, PROPERTY_CONSTRAINT);
    }

    /**
     * If true, implementations that produce or consume resources SHALL
     * provide "support" for the element in some meaningful way.  If false,
     * the element may be ignored and not supported. If false, whether to
     * populate or use the data element in any way is at the discretion of
     * the implementation.
     */
    public Boolean mustSupport() {
        return data.getBoolean(PROPERTY_MUSTSUPPORT);
    }

    /**
     * If true, the value of this element affects the interpretation of the
     * element or resource that contains it, and the value of the element
     * cannot be ignored. Typically, this is used for status, negation and
     * qualification codes. The effect of this is that the element cannot be
     * ignored by systems: they SHALL either recognize the element and
     * process it, and/or a pre-determination has been made that it is not
     * relevant to their particular system.
     */
    public Boolean isModifier() {
        return data.getBoolean(PROPERTY_ISMODIFIER);
    }

    /**
     * Explains how that element affects the interpretation of the resource
     * or element that contains it.
     */
    public String isModifierReason() {
        return getString(PROPERTY_ISMODIFIERREASON);
    }

    /**
     * Whether the element should be included if a client requests a search
     * with the parameter _summary=true.
     */
    public Boolean isSummary() {
        return data.getBoolean(PROPERTY_ISSUMMARY);
    }

    /**
     * Binds to a value set if this element is coded (code, Coding,
     * CodeableConcept, Quantity), or the data types (string, uri).
     */
    public ElementDefinitionBinding binding() {
        return getObject(ElementDefinitionBinding.class, PROPERTY_BINDING);
    }

    /**
     * Identifies a concept from an external specification that roughly
     * corresponds to this element.
     */
    public java.util.List<ElementDefinitionMapping> mapping() {
        return getList(ElementDefinitionMapping.class, PROPERTY_MAPPING);
    }

    public static class Builder {
        private final JsonObjectBuilder b;

        private Builder() {
            b = Json.createObjectBuilder();
        }

        private Builder(final JsonObject data) {
            b = Json.createObjectBuilder(data);
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder path(final String path) {
            b.add(PROPERTY_PATH, path);
            return this;
        }

        public Builder representation(final java.util.List<String> representation) {
            b.add(PROPERTY_REPRESENTATION, FhirObject.toStringArray(representation));
            return this;
        }

        public Builder sliceName(final String sliceName) {
            b.add(PROPERTY_SLICENAME, sliceName);
            return this;
        }

        public Builder sliceIsConstraining(final Boolean sliceIsConstraining) {
            b.add(PROPERTY_SLICEISCONSTRAINING, sliceIsConstraining);
            return this;
        }

        public Builder label(final String label) {
            b.add(PROPERTY_LABEL, label);
            return this;
        }

        public Builder code(final java.util.List<Coding> code) {
            b.add(PROPERTY_CODE, FhirObject.toArray(code));
            return this;
        }

        public Builder slicing(final ElementDefinitionSlicing slicing) {
            b.add(PROPERTY_SLICING, slicing);
            return this;
        }

        public Builder shortValue(final String shortValue) {
            b.add(PROPERTY_SHORT, shortValue);
            return this;
        }

        public Builder definition(final String definition) {
            b.add(PROPERTY_DEFINITION, definition);
            return this;
        }

        public Builder comment(final String comment) {
            b.add(PROPERTY_COMMENT, comment);
            return this;
        }

        public Builder requirements(final String requirements) {
            b.add(PROPERTY_REQUIREMENTS, requirements);
            return this;
        }

        public Builder alias(final java.util.List<String> alias) {
            b.add(PROPERTY_ALIAS, FhirObject.toStringArray(alias));
            return this;
        }

        public Builder min(final Integer min) {
            b.add(PROPERTY_MIN, min);
            return this;
        }

        public Builder max(final String max) {
            b.add(PROPERTY_MAX, max);
            return this;
        }

        public Builder base(final ElementDefinitionBase base) {
            b.add(PROPERTY_BASE, base);
            return this;
        }

        public Builder contentReference(final String contentReference) {
            b.add(PROPERTY_CONTENTREFERENCE, contentReference);
            return this;
        }

        public Builder type(final java.util.List<ElementDefinitionType> type) {
            b.add(PROPERTY_TYPE, FhirObject.toArray(type));
            return this;
        }

        public Builder defaultValueBase64Binary(final String defaultValueBase64Binary) {
            b.add(PROPERTY_DEFAULTVALUEBASE64BINARY, defaultValueBase64Binary);
            return this;
        }

        public Builder defaultValueBoolean(final Boolean defaultValueBoolean) {
            b.add(PROPERTY_DEFAULTVALUEBOOLEAN, defaultValueBoolean);
            return this;
        }

        public Builder defaultValueCanonical(final String defaultValueCanonical) {
            b.add(PROPERTY_DEFAULTVALUECANONICAL, defaultValueCanonical);
            return this;
        }

        public Builder defaultValueCode(final String defaultValueCode) {
            b.add(PROPERTY_DEFAULTVALUECODE, defaultValueCode);
            return this;
        }

        public Builder defaultValueDate(final String defaultValueDate) {
            b.add(PROPERTY_DEFAULTVALUEDATE, defaultValueDate);
            return this;
        }

        public Builder defaultValueDateTime(final String defaultValueDateTime) {
            b.add(PROPERTY_DEFAULTVALUEDATETIME, defaultValueDateTime);
            return this;
        }

        public Builder defaultValueDecimal(final Integer defaultValueDecimal) {
            b.add(PROPERTY_DEFAULTVALUEDECIMAL, defaultValueDecimal);
            return this;
        }

        public Builder defaultValueId(final String defaultValueId) {
            b.add(PROPERTY_DEFAULTVALUEID, defaultValueId);
            return this;
        }

        public Builder defaultValueInstant(final String defaultValueInstant) {
            b.add(PROPERTY_DEFAULTVALUEINSTANT, defaultValueInstant);
            return this;
        }

        public Builder defaultValueInteger(final Integer defaultValueInteger) {
            b.add(PROPERTY_DEFAULTVALUEINTEGER, defaultValueInteger);
            return this;
        }

        public Builder defaultValueMarkdown(final String defaultValueMarkdown) {
            b.add(PROPERTY_DEFAULTVALUEMARKDOWN, defaultValueMarkdown);
            return this;
        }

        public Builder defaultValueOid(final String defaultValueOid) {
            b.add(PROPERTY_DEFAULTVALUEOID, defaultValueOid);
            return this;
        }

        public Builder defaultValuePositiveInt(final Integer defaultValuePositiveInt) {
            b.add(PROPERTY_DEFAULTVALUEPOSITIVEINT, defaultValuePositiveInt);
            return this;
        }

        public Builder defaultValueString(final String defaultValueString) {
            b.add(PROPERTY_DEFAULTVALUESTRING, defaultValueString);
            return this;
        }

        public Builder defaultValueTime(final String defaultValueTime) {
            b.add(PROPERTY_DEFAULTVALUETIME, defaultValueTime);
            return this;
        }

        public Builder defaultValueUnsignedInt(final Integer defaultValueUnsignedInt) {
            b.add(PROPERTY_DEFAULTVALUEUNSIGNEDINT, defaultValueUnsignedInt);
            return this;
        }

        public Builder defaultValueUri(final String defaultValueUri) {
            b.add(PROPERTY_DEFAULTVALUEURI, defaultValueUri);
            return this;
        }

        public Builder defaultValueUrl(final String defaultValueUrl) {
            b.add(PROPERTY_DEFAULTVALUEURL, defaultValueUrl);
            return this;
        }

        public Builder defaultValueUuid(final String defaultValueUuid) {
            b.add(PROPERTY_DEFAULTVALUEUUID, defaultValueUuid);
            return this;
        }

        public Builder defaultValueAddress(final Address defaultValueAddress) {
            b.add(PROPERTY_DEFAULTVALUEADDRESS, defaultValueAddress);
            return this;
        }

        public Builder defaultValueAge(final Age defaultValueAge) {
            b.add(PROPERTY_DEFAULTVALUEAGE, defaultValueAge);
            return this;
        }

        public Builder defaultValueAnnotation(final Annotation defaultValueAnnotation) {
            b.add(PROPERTY_DEFAULTVALUEANNOTATION, defaultValueAnnotation);
            return this;
        }

        public Builder defaultValueAttachment(final Attachment defaultValueAttachment) {
            b.add(PROPERTY_DEFAULTVALUEATTACHMENT, defaultValueAttachment);
            return this;
        }

        public Builder defaultValueCodeableConcept(final CodeableConcept defaultValueCodeableConcept) {
            b.add(PROPERTY_DEFAULTVALUECODEABLECONCEPT, defaultValueCodeableConcept);
            return this;
        }

        public Builder defaultValueCoding(final Coding defaultValueCoding) {
            b.add(PROPERTY_DEFAULTVALUECODING, defaultValueCoding);
            return this;
        }

        public Builder defaultValueContactPoint(final ContactPoint defaultValueContactPoint) {
            b.add(PROPERTY_DEFAULTVALUECONTACTPOINT, defaultValueContactPoint);
            return this;
        }

        public Builder defaultValueCount(final Count defaultValueCount) {
            b.add(PROPERTY_DEFAULTVALUECOUNT, defaultValueCount);
            return this;
        }

        public Builder defaultValueDistance(final Distance defaultValueDistance) {
            b.add(PROPERTY_DEFAULTVALUEDISTANCE, defaultValueDistance);
            return this;
        }

        public Builder defaultValueDuration(final Duration defaultValueDuration) {
            b.add(PROPERTY_DEFAULTVALUEDURATION, defaultValueDuration);
            return this;
        }

        public Builder defaultValueHumanName(final HumanName defaultValueHumanName) {
            b.add(PROPERTY_DEFAULTVALUEHUMANNAME, defaultValueHumanName);
            return this;
        }

        public Builder defaultValueIdentifier(final Identifier defaultValueIdentifier) {
            b.add(PROPERTY_DEFAULTVALUEIDENTIFIER, defaultValueIdentifier);
            return this;
        }

        public Builder defaultValueMoney(final Money defaultValueMoney) {
            b.add(PROPERTY_DEFAULTVALUEMONEY, defaultValueMoney);
            return this;
        }

        public Builder defaultValuePeriod(final Period defaultValuePeriod) {
            b.add(PROPERTY_DEFAULTVALUEPERIOD, defaultValuePeriod);
            return this;
        }

        public Builder defaultValueQuantity(final Quantity defaultValueQuantity) {
            b.add(PROPERTY_DEFAULTVALUEQUANTITY, defaultValueQuantity);
            return this;
        }

        public Builder defaultValueRange(final Range defaultValueRange) {
            b.add(PROPERTY_DEFAULTVALUERANGE, defaultValueRange);
            return this;
        }

        public Builder defaultValueRatio(final Ratio defaultValueRatio) {
            b.add(PROPERTY_DEFAULTVALUERATIO, defaultValueRatio);
            return this;
        }

        public Builder defaultValueReference(final Reference defaultValueReference) {
            b.add(PROPERTY_DEFAULTVALUEREFERENCE, defaultValueReference);
            return this;
        }

        public Builder defaultValueSampledData(final SampledData defaultValueSampledData) {
            b.add(PROPERTY_DEFAULTVALUESAMPLEDDATA, defaultValueSampledData);
            return this;
        }

        public Builder defaultValueSignature(final Signature defaultValueSignature) {
            b.add(PROPERTY_DEFAULTVALUESIGNATURE, defaultValueSignature);
            return this;
        }

        public Builder defaultValueTiming(final Timing defaultValueTiming) {
            b.add(PROPERTY_DEFAULTVALUETIMING, defaultValueTiming);
            return this;
        }

        public Builder defaultValueContactDetail(final ContactDetail defaultValueContactDetail) {
            b.add(PROPERTY_DEFAULTVALUECONTACTDETAIL, defaultValueContactDetail);
            return this;
        }

        public Builder defaultValueContributor(final Contributor defaultValueContributor) {
            b.add(PROPERTY_DEFAULTVALUECONTRIBUTOR, defaultValueContributor);
            return this;
        }

        public Builder defaultValueDataRequirement(final DataRequirement defaultValueDataRequirement) {
            b.add(PROPERTY_DEFAULTVALUEDATAREQUIREMENT, defaultValueDataRequirement);
            return this;
        }

        public Builder defaultValueExpression(final Expression defaultValueExpression) {
            b.add(PROPERTY_DEFAULTVALUEEXPRESSION, defaultValueExpression);
            return this;
        }

        public Builder defaultValueParameterDefinition(final ParameterDefinition defaultValueParameterDefinition) {
            b.add(PROPERTY_DEFAULTVALUEPARAMETERDEFINITION, defaultValueParameterDefinition);
            return this;
        }

        public Builder defaultValueRelatedArtifact(final RelatedArtifact defaultValueRelatedArtifact) {
            b.add(PROPERTY_DEFAULTVALUERELATEDARTIFACT, defaultValueRelatedArtifact);
            return this;
        }

        public Builder defaultValueTriggerDefinition(final TriggerDefinition defaultValueTriggerDefinition) {
            b.add(PROPERTY_DEFAULTVALUETRIGGERDEFINITION, defaultValueTriggerDefinition);
            return this;
        }

        public Builder defaultValueUsageContext(final UsageContext defaultValueUsageContext) {
            b.add(PROPERTY_DEFAULTVALUEUSAGECONTEXT, defaultValueUsageContext);
            return this;
        }

        public Builder defaultValueDosage(final Dosage defaultValueDosage) {
            b.add(PROPERTY_DEFAULTVALUEDOSAGE, defaultValueDosage);
            return this;
        }

        public Builder defaultValueMeta(final Meta defaultValueMeta) {
            b.add(PROPERTY_DEFAULTVALUEMETA, defaultValueMeta);
            return this;
        }

        public Builder meaningWhenMissing(final String meaningWhenMissing) {
            b.add(PROPERTY_MEANINGWHENMISSING, meaningWhenMissing);
            return this;
        }

        public Builder orderMeaning(final String orderMeaning) {
            b.add(PROPERTY_ORDERMEANING, orderMeaning);
            return this;
        }

        public Builder fixedBase64Binary(final String fixedBase64Binary) {
            b.add(PROPERTY_FIXEDBASE64BINARY, fixedBase64Binary);
            return this;
        }

        public Builder fixedBoolean(final Boolean fixedBoolean) {
            b.add(PROPERTY_FIXEDBOOLEAN, fixedBoolean);
            return this;
        }

        public Builder fixedCanonical(final String fixedCanonical) {
            b.add(PROPERTY_FIXEDCANONICAL, fixedCanonical);
            return this;
        }

        public Builder fixedCode(final String fixedCode) {
            b.add(PROPERTY_FIXEDCODE, fixedCode);
            return this;
        }

        public Builder fixedDate(final String fixedDate) {
            b.add(PROPERTY_FIXEDDATE, fixedDate);
            return this;
        }

        public Builder fixedDateTime(final String fixedDateTime) {
            b.add(PROPERTY_FIXEDDATETIME, fixedDateTime);
            return this;
        }

        public Builder fixedDecimal(final Integer fixedDecimal) {
            b.add(PROPERTY_FIXEDDECIMAL, fixedDecimal);
            return this;
        }

        public Builder fixedId(final String fixedId) {
            b.add(PROPERTY_FIXEDID, fixedId);
            return this;
        }

        public Builder fixedInstant(final String fixedInstant) {
            b.add(PROPERTY_FIXEDINSTANT, fixedInstant);
            return this;
        }

        public Builder fixedInteger(final Integer fixedInteger) {
            b.add(PROPERTY_FIXEDINTEGER, fixedInteger);
            return this;
        }

        public Builder fixedMarkdown(final String fixedMarkdown) {
            b.add(PROPERTY_FIXEDMARKDOWN, fixedMarkdown);
            return this;
        }

        public Builder fixedOid(final String fixedOid) {
            b.add(PROPERTY_FIXEDOID, fixedOid);
            return this;
        }

        public Builder fixedPositiveInt(final Integer fixedPositiveInt) {
            b.add(PROPERTY_FIXEDPOSITIVEINT, fixedPositiveInt);
            return this;
        }

        public Builder fixedString(final String fixedString) {
            b.add(PROPERTY_FIXEDSTRING, fixedString);
            return this;
        }

        public Builder fixedTime(final String fixedTime) {
            b.add(PROPERTY_FIXEDTIME, fixedTime);
            return this;
        }

        public Builder fixedUnsignedInt(final Integer fixedUnsignedInt) {
            b.add(PROPERTY_FIXEDUNSIGNEDINT, fixedUnsignedInt);
            return this;
        }

        public Builder fixedUri(final String fixedUri) {
            b.add(PROPERTY_FIXEDURI, fixedUri);
            return this;
        }

        public Builder fixedUrl(final String fixedUrl) {
            b.add(PROPERTY_FIXEDURL, fixedUrl);
            return this;
        }

        public Builder fixedUuid(final String fixedUuid) {
            b.add(PROPERTY_FIXEDUUID, fixedUuid);
            return this;
        }

        public Builder fixedAddress(final Address fixedAddress) {
            b.add(PROPERTY_FIXEDADDRESS, fixedAddress);
            return this;
        }

        public Builder fixedAge(final Age fixedAge) {
            b.add(PROPERTY_FIXEDAGE, fixedAge);
            return this;
        }

        public Builder fixedAnnotation(final Annotation fixedAnnotation) {
            b.add(PROPERTY_FIXEDANNOTATION, fixedAnnotation);
            return this;
        }

        public Builder fixedAttachment(final Attachment fixedAttachment) {
            b.add(PROPERTY_FIXEDATTACHMENT, fixedAttachment);
            return this;
        }

        public Builder fixedCodeableConcept(final CodeableConcept fixedCodeableConcept) {
            b.add(PROPERTY_FIXEDCODEABLECONCEPT, fixedCodeableConcept);
            return this;
        }

        public Builder fixedCoding(final Coding fixedCoding) {
            b.add(PROPERTY_FIXEDCODING, fixedCoding);
            return this;
        }

        public Builder fixedContactPoint(final ContactPoint fixedContactPoint) {
            b.add(PROPERTY_FIXEDCONTACTPOINT, fixedContactPoint);
            return this;
        }

        public Builder fixedCount(final Count fixedCount) {
            b.add(PROPERTY_FIXEDCOUNT, fixedCount);
            return this;
        }

        public Builder fixedDistance(final Distance fixedDistance) {
            b.add(PROPERTY_FIXEDDISTANCE, fixedDistance);
            return this;
        }

        public Builder fixedDuration(final Duration fixedDuration) {
            b.add(PROPERTY_FIXEDDURATION, fixedDuration);
            return this;
        }

        public Builder fixedHumanName(final HumanName fixedHumanName) {
            b.add(PROPERTY_FIXEDHUMANNAME, fixedHumanName);
            return this;
        }

        public Builder fixedIdentifier(final Identifier fixedIdentifier) {
            b.add(PROPERTY_FIXEDIDENTIFIER, fixedIdentifier);
            return this;
        }

        public Builder fixedMoney(final Money fixedMoney) {
            b.add(PROPERTY_FIXEDMONEY, fixedMoney);
            return this;
        }

        public Builder fixedPeriod(final Period fixedPeriod) {
            b.add(PROPERTY_FIXEDPERIOD, fixedPeriod);
            return this;
        }

        public Builder fixedQuantity(final Quantity fixedQuantity) {
            b.add(PROPERTY_FIXEDQUANTITY, fixedQuantity);
            return this;
        }

        public Builder fixedRange(final Range fixedRange) {
            b.add(PROPERTY_FIXEDRANGE, fixedRange);
            return this;
        }

        public Builder fixedRatio(final Ratio fixedRatio) {
            b.add(PROPERTY_FIXEDRATIO, fixedRatio);
            return this;
        }

        public Builder fixedReference(final Reference fixedReference) {
            b.add(PROPERTY_FIXEDREFERENCE, fixedReference);
            return this;
        }

        public Builder fixedSampledData(final SampledData fixedSampledData) {
            b.add(PROPERTY_FIXEDSAMPLEDDATA, fixedSampledData);
            return this;
        }

        public Builder fixedSignature(final Signature fixedSignature) {
            b.add(PROPERTY_FIXEDSIGNATURE, fixedSignature);
            return this;
        }

        public Builder fixedTiming(final Timing fixedTiming) {
            b.add(PROPERTY_FIXEDTIMING, fixedTiming);
            return this;
        }

        public Builder fixedContactDetail(final ContactDetail fixedContactDetail) {
            b.add(PROPERTY_FIXEDCONTACTDETAIL, fixedContactDetail);
            return this;
        }

        public Builder fixedContributor(final Contributor fixedContributor) {
            b.add(PROPERTY_FIXEDCONTRIBUTOR, fixedContributor);
            return this;
        }

        public Builder fixedDataRequirement(final DataRequirement fixedDataRequirement) {
            b.add(PROPERTY_FIXEDDATAREQUIREMENT, fixedDataRequirement);
            return this;
        }

        public Builder fixedExpression(final Expression fixedExpression) {
            b.add(PROPERTY_FIXEDEXPRESSION, fixedExpression);
            return this;
        }

        public Builder fixedParameterDefinition(final ParameterDefinition fixedParameterDefinition) {
            b.add(PROPERTY_FIXEDPARAMETERDEFINITION, fixedParameterDefinition);
            return this;
        }

        public Builder fixedRelatedArtifact(final RelatedArtifact fixedRelatedArtifact) {
            b.add(PROPERTY_FIXEDRELATEDARTIFACT, fixedRelatedArtifact);
            return this;
        }

        public Builder fixedTriggerDefinition(final TriggerDefinition fixedTriggerDefinition) {
            b.add(PROPERTY_FIXEDTRIGGERDEFINITION, fixedTriggerDefinition);
            return this;
        }

        public Builder fixedUsageContext(final UsageContext fixedUsageContext) {
            b.add(PROPERTY_FIXEDUSAGECONTEXT, fixedUsageContext);
            return this;
        }

        public Builder fixedDosage(final Dosage fixedDosage) {
            b.add(PROPERTY_FIXEDDOSAGE, fixedDosage);
            return this;
        }

        public Builder fixedMeta(final Meta fixedMeta) {
            b.add(PROPERTY_FIXEDMETA, fixedMeta);
            return this;
        }

        public Builder patternBase64Binary(final String patternBase64Binary) {
            b.add(PROPERTY_PATTERNBASE64BINARY, patternBase64Binary);
            return this;
        }

        public Builder patternBoolean(final Boolean patternBoolean) {
            b.add(PROPERTY_PATTERNBOOLEAN, patternBoolean);
            return this;
        }

        public Builder patternCanonical(final String patternCanonical) {
            b.add(PROPERTY_PATTERNCANONICAL, patternCanonical);
            return this;
        }

        public Builder patternCode(final String patternCode) {
            b.add(PROPERTY_PATTERNCODE, patternCode);
            return this;
        }

        public Builder patternDate(final String patternDate) {
            b.add(PROPERTY_PATTERNDATE, patternDate);
            return this;
        }

        public Builder patternDateTime(final String patternDateTime) {
            b.add(PROPERTY_PATTERNDATETIME, patternDateTime);
            return this;
        }

        public Builder patternDecimal(final Integer patternDecimal) {
            b.add(PROPERTY_PATTERNDECIMAL, patternDecimal);
            return this;
        }

        public Builder patternId(final String patternId) {
            b.add(PROPERTY_PATTERNID, patternId);
            return this;
        }

        public Builder patternInstant(final String patternInstant) {
            b.add(PROPERTY_PATTERNINSTANT, patternInstant);
            return this;
        }

        public Builder patternInteger(final Integer patternInteger) {
            b.add(PROPERTY_PATTERNINTEGER, patternInteger);
            return this;
        }

        public Builder patternMarkdown(final String patternMarkdown) {
            b.add(PROPERTY_PATTERNMARKDOWN, patternMarkdown);
            return this;
        }

        public Builder patternOid(final String patternOid) {
            b.add(PROPERTY_PATTERNOID, patternOid);
            return this;
        }

        public Builder patternPositiveInt(final Integer patternPositiveInt) {
            b.add(PROPERTY_PATTERNPOSITIVEINT, patternPositiveInt);
            return this;
        }

        public Builder patternString(final String patternString) {
            b.add(PROPERTY_PATTERNSTRING, patternString);
            return this;
        }

        public Builder patternTime(final String patternTime) {
            b.add(PROPERTY_PATTERNTIME, patternTime);
            return this;
        }

        public Builder patternUnsignedInt(final Integer patternUnsignedInt) {
            b.add(PROPERTY_PATTERNUNSIGNEDINT, patternUnsignedInt);
            return this;
        }

        public Builder patternUri(final String patternUri) {
            b.add(PROPERTY_PATTERNURI, patternUri);
            return this;
        }

        public Builder patternUrl(final String patternUrl) {
            b.add(PROPERTY_PATTERNURL, patternUrl);
            return this;
        }

        public Builder patternUuid(final String patternUuid) {
            b.add(PROPERTY_PATTERNUUID, patternUuid);
            return this;
        }

        public Builder patternAddress(final Address patternAddress) {
            b.add(PROPERTY_PATTERNADDRESS, patternAddress);
            return this;
        }

        public Builder patternAge(final Age patternAge) {
            b.add(PROPERTY_PATTERNAGE, patternAge);
            return this;
        }

        public Builder patternAnnotation(final Annotation patternAnnotation) {
            b.add(PROPERTY_PATTERNANNOTATION, patternAnnotation);
            return this;
        }

        public Builder patternAttachment(final Attachment patternAttachment) {
            b.add(PROPERTY_PATTERNATTACHMENT, patternAttachment);
            return this;
        }

        public Builder patternCodeableConcept(final CodeableConcept patternCodeableConcept) {
            b.add(PROPERTY_PATTERNCODEABLECONCEPT, patternCodeableConcept);
            return this;
        }

        public Builder patternCoding(final Coding patternCoding) {
            b.add(PROPERTY_PATTERNCODING, patternCoding);
            return this;
        }

        public Builder patternContactPoint(final ContactPoint patternContactPoint) {
            b.add(PROPERTY_PATTERNCONTACTPOINT, patternContactPoint);
            return this;
        }

        public Builder patternCount(final Count patternCount) {
            b.add(PROPERTY_PATTERNCOUNT, patternCount);
            return this;
        }

        public Builder patternDistance(final Distance patternDistance) {
            b.add(PROPERTY_PATTERNDISTANCE, patternDistance);
            return this;
        }

        public Builder patternDuration(final Duration patternDuration) {
            b.add(PROPERTY_PATTERNDURATION, patternDuration);
            return this;
        }

        public Builder patternHumanName(final HumanName patternHumanName) {
            b.add(PROPERTY_PATTERNHUMANNAME, patternHumanName);
            return this;
        }

        public Builder patternIdentifier(final Identifier patternIdentifier) {
            b.add(PROPERTY_PATTERNIDENTIFIER, patternIdentifier);
            return this;
        }

        public Builder patternMoney(final Money patternMoney) {
            b.add(PROPERTY_PATTERNMONEY, patternMoney);
            return this;
        }

        public Builder patternPeriod(final Period patternPeriod) {
            b.add(PROPERTY_PATTERNPERIOD, patternPeriod);
            return this;
        }

        public Builder patternQuantity(final Quantity patternQuantity) {
            b.add(PROPERTY_PATTERNQUANTITY, patternQuantity);
            return this;
        }

        public Builder patternRange(final Range patternRange) {
            b.add(PROPERTY_PATTERNRANGE, patternRange);
            return this;
        }

        public Builder patternRatio(final Ratio patternRatio) {
            b.add(PROPERTY_PATTERNRATIO, patternRatio);
            return this;
        }

        public Builder patternReference(final Reference patternReference) {
            b.add(PROPERTY_PATTERNREFERENCE, patternReference);
            return this;
        }

        public Builder patternSampledData(final SampledData patternSampledData) {
            b.add(PROPERTY_PATTERNSAMPLEDDATA, patternSampledData);
            return this;
        }

        public Builder patternSignature(final Signature patternSignature) {
            b.add(PROPERTY_PATTERNSIGNATURE, patternSignature);
            return this;
        }

        public Builder patternTiming(final Timing patternTiming) {
            b.add(PROPERTY_PATTERNTIMING, patternTiming);
            return this;
        }

        public Builder patternContactDetail(final ContactDetail patternContactDetail) {
            b.add(PROPERTY_PATTERNCONTACTDETAIL, patternContactDetail);
            return this;
        }

        public Builder patternContributor(final Contributor patternContributor) {
            b.add(PROPERTY_PATTERNCONTRIBUTOR, patternContributor);
            return this;
        }

        public Builder patternDataRequirement(final DataRequirement patternDataRequirement) {
            b.add(PROPERTY_PATTERNDATAREQUIREMENT, patternDataRequirement);
            return this;
        }

        public Builder patternExpression(final Expression patternExpression) {
            b.add(PROPERTY_PATTERNEXPRESSION, patternExpression);
            return this;
        }

        public Builder patternParameterDefinition(final ParameterDefinition patternParameterDefinition) {
            b.add(PROPERTY_PATTERNPARAMETERDEFINITION, patternParameterDefinition);
            return this;
        }

        public Builder patternRelatedArtifact(final RelatedArtifact patternRelatedArtifact) {
            b.add(PROPERTY_PATTERNRELATEDARTIFACT, patternRelatedArtifact);
            return this;
        }

        public Builder patternTriggerDefinition(final TriggerDefinition patternTriggerDefinition) {
            b.add(PROPERTY_PATTERNTRIGGERDEFINITION, patternTriggerDefinition);
            return this;
        }

        public Builder patternUsageContext(final UsageContext patternUsageContext) {
            b.add(PROPERTY_PATTERNUSAGECONTEXT, patternUsageContext);
            return this;
        }

        public Builder patternDosage(final Dosage patternDosage) {
            b.add(PROPERTY_PATTERNDOSAGE, patternDosage);
            return this;
        }

        public Builder patternMeta(final Meta patternMeta) {
            b.add(PROPERTY_PATTERNMETA, patternMeta);
            return this;
        }

        public Builder example(final java.util.List<ElementDefinitionExample> example) {
            b.add(PROPERTY_EXAMPLE, FhirObject.toArray(example));
            return this;
        }

        public Builder minValueDate(final String minValueDate) {
            b.add(PROPERTY_MINVALUEDATE, minValueDate);
            return this;
        }

        public Builder minValueDateTime(final String minValueDateTime) {
            b.add(PROPERTY_MINVALUEDATETIME, minValueDateTime);
            return this;
        }

        public Builder minValueInstant(final String minValueInstant) {
            b.add(PROPERTY_MINVALUEINSTANT, minValueInstant);
            return this;
        }

        public Builder minValueTime(final String minValueTime) {
            b.add(PROPERTY_MINVALUETIME, minValueTime);
            return this;
        }

        public Builder minValueDecimal(final Integer minValueDecimal) {
            b.add(PROPERTY_MINVALUEDECIMAL, minValueDecimal);
            return this;
        }

        public Builder minValueInteger(final Integer minValueInteger) {
            b.add(PROPERTY_MINVALUEINTEGER, minValueInteger);
            return this;
        }

        public Builder minValuePositiveInt(final Integer minValuePositiveInt) {
            b.add(PROPERTY_MINVALUEPOSITIVEINT, minValuePositiveInt);
            return this;
        }

        public Builder minValueUnsignedInt(final Integer minValueUnsignedInt) {
            b.add(PROPERTY_MINVALUEUNSIGNEDINT, minValueUnsignedInt);
            return this;
        }

        public Builder minValueQuantity(final Quantity minValueQuantity) {
            b.add(PROPERTY_MINVALUEQUANTITY, minValueQuantity);
            return this;
        }

        public Builder maxValueDate(final String maxValueDate) {
            b.add(PROPERTY_MAXVALUEDATE, maxValueDate);
            return this;
        }

        public Builder maxValueDateTime(final String maxValueDateTime) {
            b.add(PROPERTY_MAXVALUEDATETIME, maxValueDateTime);
            return this;
        }

        public Builder maxValueInstant(final String maxValueInstant) {
            b.add(PROPERTY_MAXVALUEINSTANT, maxValueInstant);
            return this;
        }

        public Builder maxValueTime(final String maxValueTime) {
            b.add(PROPERTY_MAXVALUETIME, maxValueTime);
            return this;
        }

        public Builder maxValueDecimal(final Integer maxValueDecimal) {
            b.add(PROPERTY_MAXVALUEDECIMAL, maxValueDecimal);
            return this;
        }

        public Builder maxValueInteger(final Integer maxValueInteger) {
            b.add(PROPERTY_MAXVALUEINTEGER, maxValueInteger);
            return this;
        }

        public Builder maxValuePositiveInt(final Integer maxValuePositiveInt) {
            b.add(PROPERTY_MAXVALUEPOSITIVEINT, maxValuePositiveInt);
            return this;
        }

        public Builder maxValueUnsignedInt(final Integer maxValueUnsignedInt) {
            b.add(PROPERTY_MAXVALUEUNSIGNEDINT, maxValueUnsignedInt);
            return this;
        }

        public Builder maxValueQuantity(final Quantity maxValueQuantity) {
            b.add(PROPERTY_MAXVALUEQUANTITY, maxValueQuantity);
            return this;
        }

        public Builder maxLength(final Integer maxLength) {
            b.add(PROPERTY_MAXLENGTH, maxLength);
            return this;
        }

        public Builder condition(final java.util.List<String> condition) {
            b.add(PROPERTY_CONDITION, FhirObject.toStringArray(condition));
            return this;
        }

        public Builder constraint(final java.util.List<ElementDefinitionConstraint> constraint) {
            b.add(PROPERTY_CONSTRAINT, FhirObject.toArray(constraint));
            return this;
        }

        public Builder mustSupport(final Boolean mustSupport) {
            b.add(PROPERTY_MUSTSUPPORT, mustSupport);
            return this;
        }

        public Builder isModifier(final Boolean isModifier) {
            b.add(PROPERTY_ISMODIFIER, isModifier);
            return this;
        }

        public Builder isModifierReason(final String isModifierReason) {
            b.add(PROPERTY_ISMODIFIERREASON, isModifierReason);
            return this;
        }

        public Builder isSummary(final Boolean isSummary) {
            b.add(PROPERTY_ISSUMMARY, isSummary);
            return this;
        }

        public Builder binding(final ElementDefinitionBinding binding) {
            b.add(PROPERTY_BINDING, binding);
            return this;
        }

        public Builder mapping(final java.util.List<ElementDefinitionMapping> mapping) {
            b.add(PROPERTY_MAPPING, FhirObject.toArray(mapping));
            return this;
        }

        public ElementDefinition build() {
            return new ElementDefinition(b.build());
        }
    }

    public static class ElementDefinitionBase extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionBase";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_PATH = "path";
        public static final String PROPERTY_MIN = "min";
        public static final String PROPERTY_MAX = "max";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionBase(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The Path that identifies the base element - this matches the
         * ElementDefinition.path for that element. Across FHIR, there is only
         * one base definition of any element - that is, an element definition on
         * a [[[StructureDefinition]]] without a StructureDefinition.base.
         */
        public String path() {
            return getString(PROPERTY_PATH);
        }

        /**
         * Minimum cardinality of the base element identified by the path.
         */
        public Integer min() {
            return data.getInt(PROPERTY_MIN);
        }

        /**
         * Maximum cardinality of the base element identified by the path.
         */
        public String max() {
            return getString(PROPERTY_MAX);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder path(final String path) {
                b.add(PROPERTY_PATH, path);
                return this;
            }

            public Builder min(final Integer min) {
                b.add(PROPERTY_MIN, min);
                return this;
            }

            public Builder max(final String max) {
                b.add(PROPERTY_MAX, max);
                return this;
            }

            public ElementDefinitionBase build() {
                return new ElementDefinitionBase(b.build());
            }
        }
    }

    public static class ElementDefinitionBinding extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionBinding";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_STRENGTH = "strength";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_VALUESET = "valueSet";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionBinding(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Indicates the degree of conformance expectations associated with this
         * binding - that is, the degree to which the provided value set must be
         * adhered to in the instances.
         */
        public String strength() {
            return getString(PROPERTY_STRENGTH);
        }

        /**
         * Describes the intended use of this particular set of codes.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * Refers to the value set that identifies the set of codes the binding
         * refers to.
         */
        public String valueSet() {
            return getString(PROPERTY_VALUESET);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder strength(final String strength) {
                b.add(PROPERTY_STRENGTH, strength);
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder valueSet(final String valueSet) {
                b.add(PROPERTY_VALUESET, valueSet);
                return this;
            }

            public ElementDefinitionBinding build() {
                return new ElementDefinitionBinding(b.build());
            }
        }
    }

    public static class ElementDefinitionConstraint extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionConstraint";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_KEY = "key";
        public static final String PROPERTY_REQUIREMENTS = "requirements";
        public static final String PROPERTY_SEVERITY = "severity";
        public static final String PROPERTY_HUMAN = "human";
        public static final String PROPERTY_EXPRESSION = "expression";
        public static final String PROPERTY_XPATH = "xpath";
        public static final String PROPERTY_SOURCE = "source";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionConstraint(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Allows identification of which elements have their cardinalities
         * impacted by the constraint.  Will not be referenced for constraints
         * that do not affect cardinality.
         */
        public String key() {
            return getString(PROPERTY_KEY);
        }

        /**
         * Description of why this constraint is necessary or appropriate.
         */
        public String requirements() {
            return getString(PROPERTY_REQUIREMENTS);
        }

        /**
         * Identifies the impact constraint violation has on the conformance of
         * the instance.
         */
        public String severity() {
            return getString(PROPERTY_SEVERITY);
        }

        /**
         * Text that can be used to describe the constraint in messages
         * identifying that the constraint has been violated.
         */
        public String human() {
            return getString(PROPERTY_HUMAN);
        }

        /**
         * A [FHIRPath](fhirpath.html) expression of constraint that can be
         * executed to see if this constraint is met.
         */
        public String expression() {
            return getString(PROPERTY_EXPRESSION);
        }

        /**
         * An XPath expression of constraint that can be executed to see if this
         * constraint is met.
         */
        public String xpath() {
            return getString(PROPERTY_XPATH);
        }

        /**
         * A reference to the original source of the constraint, for traceability
         * purposes.
         */
        public String source() {
            return getString(PROPERTY_SOURCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder key(final String key) {
                b.add(PROPERTY_KEY, key);
                return this;
            }

            public Builder requirements(final String requirements) {
                b.add(PROPERTY_REQUIREMENTS, requirements);
                return this;
            }

            public Builder severity(final String severity) {
                b.add(PROPERTY_SEVERITY, severity);
                return this;
            }

            public Builder human(final String human) {
                b.add(PROPERTY_HUMAN, human);
                return this;
            }

            public Builder expression(final String expression) {
                b.add(PROPERTY_EXPRESSION, expression);
                return this;
            }

            public Builder xpath(final String xpath) {
                b.add(PROPERTY_XPATH, xpath);
                return this;
            }

            public Builder source(final String source) {
                b.add(PROPERTY_SOURCE, source);
                return this;
            }

            public ElementDefinitionConstraint build() {
                return new ElementDefinitionConstraint(b.build());
            }
        }
    }

    public static class ElementDefinitionDiscriminator extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionDiscriminator";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_PATH = "path";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionDiscriminator(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * How the element value is interpreted when discrimination is evaluated.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * A FHIRPath expression, using [the simple subset of
         * FHIRPath](fhirpath.html#simple), that is used to identify the element
         * on which discrimination is based.
         */
        public String path() {
            return getString(PROPERTY_PATH);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder path(final String path) {
                b.add(PROPERTY_PATH, path);
                return this;
            }

            public ElementDefinitionDiscriminator build() {
                return new ElementDefinitionDiscriminator(b.build());
            }
        }
    }

    public static class ElementDefinitionExample extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionExample";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_LABEL = "label";
        public static final String PROPERTY_VALUEBASE64BINARY = "valueBase64Binary";
        public static final String PROPERTY_VALUEBOOLEAN = "valueBoolean";
        public static final String PROPERTY_VALUECANONICAL = "valueCanonical";
        public static final String PROPERTY_VALUECODE = "valueCode";
        public static final String PROPERTY_VALUEDATE = "valueDate";
        public static final String PROPERTY_VALUEDATETIME = "valueDateTime";
        public static final String PROPERTY_VALUEDECIMAL = "valueDecimal";
        public static final String PROPERTY_VALUEID = "valueId";
        public static final String PROPERTY_VALUEINSTANT = "valueInstant";
        public static final String PROPERTY_VALUEINTEGER = "valueInteger";
        public static final String PROPERTY_VALUEMARKDOWN = "valueMarkdown";
        public static final String PROPERTY_VALUEOID = "valueOid";
        public static final String PROPERTY_VALUEPOSITIVEINT = "valuePositiveInt";
        public static final String PROPERTY_VALUESTRING = "valueString";
        public static final String PROPERTY_VALUETIME = "valueTime";
        public static final String PROPERTY_VALUEUNSIGNEDINT = "valueUnsignedInt";
        public static final String PROPERTY_VALUEURI = "valueUri";
        public static final String PROPERTY_VALUEURL = "valueUrl";
        public static final String PROPERTY_VALUEUUID = "valueUuid";
        public static final String PROPERTY_VALUEADDRESS = "valueAddress";
        public static final String PROPERTY_VALUEAGE = "valueAge";
        public static final String PROPERTY_VALUEANNOTATION = "valueAnnotation";
        public static final String PROPERTY_VALUEATTACHMENT = "valueAttachment";
        public static final String PROPERTY_VALUECODEABLECONCEPT = "valueCodeableConcept";
        public static final String PROPERTY_VALUECODING = "valueCoding";
        public static final String PROPERTY_VALUECONTACTPOINT = "valueContactPoint";
        public static final String PROPERTY_VALUECOUNT = "valueCount";
        public static final String PROPERTY_VALUEDISTANCE = "valueDistance";
        public static final String PROPERTY_VALUEDURATION = "valueDuration";
        public static final String PROPERTY_VALUEHUMANNAME = "valueHumanName";
        public static final String PROPERTY_VALUEIDENTIFIER = "valueIdentifier";
        public static final String PROPERTY_VALUEMONEY = "valueMoney";
        public static final String PROPERTY_VALUEPERIOD = "valuePeriod";
        public static final String PROPERTY_VALUEQUANTITY = "valueQuantity";
        public static final String PROPERTY_VALUERANGE = "valueRange";
        public static final String PROPERTY_VALUERATIO = "valueRatio";
        public static final String PROPERTY_VALUEREFERENCE = "valueReference";
        public static final String PROPERTY_VALUESAMPLEDDATA = "valueSampledData";
        public static final String PROPERTY_VALUESIGNATURE = "valueSignature";
        public static final String PROPERTY_VALUETIMING = "valueTiming";
        public static final String PROPERTY_VALUECONTACTDETAIL = "valueContactDetail";
        public static final String PROPERTY_VALUECONTRIBUTOR = "valueContributor";
        public static final String PROPERTY_VALUEDATAREQUIREMENT = "valueDataRequirement";
        public static final String PROPERTY_VALUEEXPRESSION = "valueExpression";
        public static final String PROPERTY_VALUEPARAMETERDEFINITION = "valueParameterDefinition";
        public static final String PROPERTY_VALUERELATEDARTIFACT = "valueRelatedArtifact";
        public static final String PROPERTY_VALUETRIGGERDEFINITION = "valueTriggerDefinition";
        public static final String PROPERTY_VALUEUSAGECONTEXT = "valueUsageContext";
        public static final String PROPERTY_VALUEDOSAGE = "valueDosage";
        public static final String PROPERTY_VALUEMETA = "valueMeta";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionExample(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Describes the purpose of this example amoung the set of examples.
         */
        public String label() {
            return getString(PROPERTY_LABEL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueBase64Binary() {
            return getString(PROPERTY_VALUEBASE64BINARY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(PROPERTY_VALUEBOOLEAN);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueCanonical() {
            return getString(PROPERTY_VALUECANONICAL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueCode() {
            return getString(PROPERTY_VALUECODE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueDate() {
            return getString(PROPERTY_VALUEDATE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueDateTime() {
            return getString(PROPERTY_VALUEDATETIME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueDecimal() {
            return data.getInt(PROPERTY_VALUEDECIMAL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueId() {
            return getString(PROPERTY_VALUEID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueInstant() {
            return getString(PROPERTY_VALUEINSTANT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueInteger() {
            return data.getInt(PROPERTY_VALUEINTEGER);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueMarkdown() {
            return getString(PROPERTY_VALUEMARKDOWN);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueOid() {
            return getString(PROPERTY_VALUEOID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valuePositiveInt() {
            return data.getInt(PROPERTY_VALUEPOSITIVEINT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueString() {
            return getString(PROPERTY_VALUESTRING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueTime() {
            return getString(PROPERTY_VALUETIME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueUnsignedInt() {
            return data.getInt(PROPERTY_VALUEUNSIGNEDINT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUri() {
            return getString(PROPERTY_VALUEURI);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUrl() {
            return getString(PROPERTY_VALUEURL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUuid() {
            return getString(PROPERTY_VALUEUUID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Address valueAddress() {
            return getObject(Address.class, PROPERTY_VALUEADDRESS);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Age valueAge() {
            return getObject(Age.class, PROPERTY_VALUEAGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Annotation valueAnnotation() {
            return getObject(Annotation.class, PROPERTY_VALUEANNOTATION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Attachment valueAttachment() {
            return getObject(Attachment.class, PROPERTY_VALUEATTACHMENT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public CodeableConcept valueCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_VALUECODEABLECONCEPT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Coding valueCoding() {
            return getObject(Coding.class, PROPERTY_VALUECODING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ContactPoint valueContactPoint() {
            return getObject(ContactPoint.class, PROPERTY_VALUECONTACTPOINT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Count valueCount() {
            return getObject(Count.class, PROPERTY_VALUECOUNT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Distance valueDistance() {
            return getObject(Distance.class, PROPERTY_VALUEDISTANCE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Duration valueDuration() {
            return getObject(Duration.class, PROPERTY_VALUEDURATION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public HumanName valueHumanName() {
            return getObject(HumanName.class, PROPERTY_VALUEHUMANNAME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Identifier valueIdentifier() {
            return getObject(Identifier.class, PROPERTY_VALUEIDENTIFIER);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Money valueMoney() {
            return getObject(Money.class, PROPERTY_VALUEMONEY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Period valuePeriod() {
            return getObject(Period.class, PROPERTY_VALUEPERIOD);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Quantity valueQuantity() {
            return getObject(Quantity.class, PROPERTY_VALUEQUANTITY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Range valueRange() {
            return getObject(Range.class, PROPERTY_VALUERANGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Ratio valueRatio() {
            return getObject(Ratio.class, PROPERTY_VALUERATIO);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Reference valueReference() {
            return getObject(Reference.class, PROPERTY_VALUEREFERENCE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public SampledData valueSampledData() {
            return getObject(SampledData.class, PROPERTY_VALUESAMPLEDDATA);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Signature valueSignature() {
            return getObject(Signature.class, PROPERTY_VALUESIGNATURE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Timing valueTiming() {
            return getObject(Timing.class, PROPERTY_VALUETIMING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ContactDetail valueContactDetail() {
            return getObject(ContactDetail.class, PROPERTY_VALUECONTACTDETAIL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Contributor valueContributor() {
            return getObject(Contributor.class, PROPERTY_VALUECONTRIBUTOR);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public DataRequirement valueDataRequirement() {
            return getObject(DataRequirement.class, PROPERTY_VALUEDATAREQUIREMENT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Expression valueExpression() {
            return getObject(Expression.class, PROPERTY_VALUEEXPRESSION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ParameterDefinition valueParameterDefinition() {
            return getObject(ParameterDefinition.class, PROPERTY_VALUEPARAMETERDEFINITION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public RelatedArtifact valueRelatedArtifact() {
            return getObject(RelatedArtifact.class, PROPERTY_VALUERELATEDARTIFACT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public TriggerDefinition valueTriggerDefinition() {
            return getObject(TriggerDefinition.class, PROPERTY_VALUETRIGGERDEFINITION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public UsageContext valueUsageContext() {
            return getObject(UsageContext.class, PROPERTY_VALUEUSAGECONTEXT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Dosage valueDosage() {
            return getObject(Dosage.class, PROPERTY_VALUEDOSAGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Meta valueMeta() {
            return getObject(Meta.class, PROPERTY_VALUEMETA);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder label(final String label) {
                b.add(PROPERTY_LABEL, label);
                return this;
            }

            public Builder valueBase64Binary(final String valueBase64Binary) {
                b.add(PROPERTY_VALUEBASE64BINARY, valueBase64Binary);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(PROPERTY_VALUEBOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueCanonical(final String valueCanonical) {
                b.add(PROPERTY_VALUECANONICAL, valueCanonical);
                return this;
            }

            public Builder valueCode(final String valueCode) {
                b.add(PROPERTY_VALUECODE, valueCode);
                return this;
            }

            public Builder valueDate(final String valueDate) {
                b.add(PROPERTY_VALUEDATE, valueDate);
                return this;
            }

            public Builder valueDateTime(final String valueDateTime) {
                b.add(PROPERTY_VALUEDATETIME, valueDateTime);
                return this;
            }

            public Builder valueDecimal(final Integer valueDecimal) {
                b.add(PROPERTY_VALUEDECIMAL, valueDecimal);
                return this;
            }

            public Builder valueId(final String valueId) {
                b.add(PROPERTY_VALUEID, valueId);
                return this;
            }

            public Builder valueInstant(final String valueInstant) {
                b.add(PROPERTY_VALUEINSTANT, valueInstant);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(PROPERTY_VALUEINTEGER, valueInteger);
                return this;
            }

            public Builder valueMarkdown(final String valueMarkdown) {
                b.add(PROPERTY_VALUEMARKDOWN, valueMarkdown);
                return this;
            }

            public Builder valueOid(final String valueOid) {
                b.add(PROPERTY_VALUEOID, valueOid);
                return this;
            }

            public Builder valuePositiveInt(final Integer valuePositiveInt) {
                b.add(PROPERTY_VALUEPOSITIVEINT, valuePositiveInt);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(PROPERTY_VALUESTRING, valueString);
                return this;
            }

            public Builder valueTime(final String valueTime) {
                b.add(PROPERTY_VALUETIME, valueTime);
                return this;
            }

            public Builder valueUnsignedInt(final Integer valueUnsignedInt) {
                b.add(PROPERTY_VALUEUNSIGNEDINT, valueUnsignedInt);
                return this;
            }

            public Builder valueUri(final String valueUri) {
                b.add(PROPERTY_VALUEURI, valueUri);
                return this;
            }

            public Builder valueUrl(final String valueUrl) {
                b.add(PROPERTY_VALUEURL, valueUrl);
                return this;
            }

            public Builder valueUuid(final String valueUuid) {
                b.add(PROPERTY_VALUEUUID, valueUuid);
                return this;
            }

            public Builder valueAddress(final Address valueAddress) {
                b.add(PROPERTY_VALUEADDRESS, valueAddress);
                return this;
            }

            public Builder valueAge(final Age valueAge) {
                b.add(PROPERTY_VALUEAGE, valueAge);
                return this;
            }

            public Builder valueAnnotation(final Annotation valueAnnotation) {
                b.add(PROPERTY_VALUEANNOTATION, valueAnnotation);
                return this;
            }

            public Builder valueAttachment(final Attachment valueAttachment) {
                b.add(PROPERTY_VALUEATTACHMENT, valueAttachment);
                return this;
            }

            public Builder valueCodeableConcept(final CodeableConcept valueCodeableConcept) {
                b.add(PROPERTY_VALUECODEABLECONCEPT, valueCodeableConcept);
                return this;
            }

            public Builder valueCoding(final Coding valueCoding) {
                b.add(PROPERTY_VALUECODING, valueCoding);
                return this;
            }

            public Builder valueContactPoint(final ContactPoint valueContactPoint) {
                b.add(PROPERTY_VALUECONTACTPOINT, valueContactPoint);
                return this;
            }

            public Builder valueCount(final Count valueCount) {
                b.add(PROPERTY_VALUECOUNT, valueCount);
                return this;
            }

            public Builder valueDistance(final Distance valueDistance) {
                b.add(PROPERTY_VALUEDISTANCE, valueDistance);
                return this;
            }

            public Builder valueDuration(final Duration valueDuration) {
                b.add(PROPERTY_VALUEDURATION, valueDuration);
                return this;
            }

            public Builder valueHumanName(final HumanName valueHumanName) {
                b.add(PROPERTY_VALUEHUMANNAME, valueHumanName);
                return this;
            }

            public Builder valueIdentifier(final Identifier valueIdentifier) {
                b.add(PROPERTY_VALUEIDENTIFIER, valueIdentifier);
                return this;
            }

            public Builder valueMoney(final Money valueMoney) {
                b.add(PROPERTY_VALUEMONEY, valueMoney);
                return this;
            }

            public Builder valuePeriod(final Period valuePeriod) {
                b.add(PROPERTY_VALUEPERIOD, valuePeriod);
                return this;
            }

            public Builder valueQuantity(final Quantity valueQuantity) {
                b.add(PROPERTY_VALUEQUANTITY, valueQuantity);
                return this;
            }

            public Builder valueRange(final Range valueRange) {
                b.add(PROPERTY_VALUERANGE, valueRange);
                return this;
            }

            public Builder valueRatio(final Ratio valueRatio) {
                b.add(PROPERTY_VALUERATIO, valueRatio);
                return this;
            }

            public Builder valueReference(final Reference valueReference) {
                b.add(PROPERTY_VALUEREFERENCE, valueReference);
                return this;
            }

            public Builder valueSampledData(final SampledData valueSampledData) {
                b.add(PROPERTY_VALUESAMPLEDDATA, valueSampledData);
                return this;
            }

            public Builder valueSignature(final Signature valueSignature) {
                b.add(PROPERTY_VALUESIGNATURE, valueSignature);
                return this;
            }

            public Builder valueTiming(final Timing valueTiming) {
                b.add(PROPERTY_VALUETIMING, valueTiming);
                return this;
            }

            public Builder valueContactDetail(final ContactDetail valueContactDetail) {
                b.add(PROPERTY_VALUECONTACTDETAIL, valueContactDetail);
                return this;
            }

            public Builder valueContributor(final Contributor valueContributor) {
                b.add(PROPERTY_VALUECONTRIBUTOR, valueContributor);
                return this;
            }

            public Builder valueDataRequirement(final DataRequirement valueDataRequirement) {
                b.add(PROPERTY_VALUEDATAREQUIREMENT, valueDataRequirement);
                return this;
            }

            public Builder valueExpression(final Expression valueExpression) {
                b.add(PROPERTY_VALUEEXPRESSION, valueExpression);
                return this;
            }

            public Builder valueParameterDefinition(final ParameterDefinition valueParameterDefinition) {
                b.add(PROPERTY_VALUEPARAMETERDEFINITION, valueParameterDefinition);
                return this;
            }

            public Builder valueRelatedArtifact(final RelatedArtifact valueRelatedArtifact) {
                b.add(PROPERTY_VALUERELATEDARTIFACT, valueRelatedArtifact);
                return this;
            }

            public Builder valueTriggerDefinition(final TriggerDefinition valueTriggerDefinition) {
                b.add(PROPERTY_VALUETRIGGERDEFINITION, valueTriggerDefinition);
                return this;
            }

            public Builder valueUsageContext(final UsageContext valueUsageContext) {
                b.add(PROPERTY_VALUEUSAGECONTEXT, valueUsageContext);
                return this;
            }

            public Builder valueDosage(final Dosage valueDosage) {
                b.add(PROPERTY_VALUEDOSAGE, valueDosage);
                return this;
            }

            public Builder valueMeta(final Meta valueMeta) {
                b.add(PROPERTY_VALUEMETA, valueMeta);
                return this;
            }

            public ElementDefinitionExample build() {
                return new ElementDefinitionExample(b.build());
            }
        }
    }

    public static class ElementDefinitionMapping extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionMapping";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_IDENTITY = "identity";
        public static final String PROPERTY_LANGUAGE = "language";
        public static final String PROPERTY_MAP = "map";
        public static final String PROPERTY_COMMENT = "comment";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionMapping(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * An internal reference to the definition of a mapping.
         */
        public String identity() {
            return getString(PROPERTY_IDENTITY);
        }

        /**
         * Identifies the computable language in which mapping.map is expressed.
         */
        public String language() {
            return getString(PROPERTY_LANGUAGE);
        }

        /**
         * Expresses what part of the target specification corresponds to this
         * element.
         */
        public String map() {
            return getString(PROPERTY_MAP);
        }

        /**
         * Comments that provide information about the mapping or its use.
         */
        public String comment() {
            return getString(PROPERTY_COMMENT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder identity(final String identity) {
                b.add(PROPERTY_IDENTITY, identity);
                return this;
            }

            public Builder language(final String language) {
                b.add(PROPERTY_LANGUAGE, language);
                return this;
            }

            public Builder map(final String map) {
                b.add(PROPERTY_MAP, map);
                return this;
            }

            public Builder comment(final String comment) {
                b.add(PROPERTY_COMMENT, comment);
                return this;
            }

            public ElementDefinitionMapping build() {
                return new ElementDefinitionMapping(b.build());
            }
        }
    }

    public static class ElementDefinitionSlicing extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionSlicing";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_DISCRIMINATOR = "discriminator";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_ORDERED = "ordered";
        public static final String PROPERTY_RULES = "rules";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionSlicing(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Designates which child elements are used to discriminate between the
         * slices when processing an instance. If one or more discriminators are
         * provided, the value of the child elements in the instance data SHALL
         * completely distinguish which slice the element in the resource matches
         * based on the allowed values for those elements in each of the slices.
         */
        public java.util.List<ElementDefinitionDiscriminator> discriminator() {
            return getList(ElementDefinitionDiscriminator.class, PROPERTY_DISCRIMINATOR);
        }

        /**
         * A human-readable text description of how the slicing works. If there
         * is no discriminator, this is required to be present to provide
         * whatever information is possible about how the slices can be
         * differentiated.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * If the matching elements have to occur in the same order as defined in
         * the profile.
         */
        public Boolean ordered() {
            return data.getBoolean(PROPERTY_ORDERED);
        }

        /**
         * Whether additional slices are allowed or not. When the slices are
         * ordered, profile authors can also say that additional slices are only
         * allowed at the end.
         */
        public String rules() {
            return getString(PROPERTY_RULES);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder discriminator(final java.util.List<ElementDefinitionDiscriminator> discriminator) {
                b.add(PROPERTY_DISCRIMINATOR, FhirObject.toArray(discriminator));
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder ordered(final Boolean ordered) {
                b.add(PROPERTY_ORDERED, ordered);
                return this;
            }

            public Builder rules(final String rules) {
                b.add(PROPERTY_RULES, rules);
                return this;
            }

            public ElementDefinitionSlicing build() {
                return new ElementDefinitionSlicing(b.build());
            }
        }
    }

    public static class ElementDefinitionType extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionType";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_PROFILE = "profile";
        public static final String PROPERTY_TARGETPROFILE = "targetProfile";
        public static final String PROPERTY_AGGREGATION = "aggregation";
        public static final String PROPERTY_VERSIONING = "versioning";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionType(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * URL of Data type or Resource that is a(or the) type used for this
         * element. References are URLs that are relative to
         * http://hl7.org/fhir/StructureDefinition e.g. "string" is a reference
         * to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are
         * only allowed in logical models.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * Identifies a profile structure or implementation Guide that applies to
         * the datatype this element refers to. If any profiles are specified,
         * then the content must conform to at least one of them. The URL can be
         * a local reference - to a contained StructureDefinition, or a reference
         * to another StructureDefinition or Implementation Guide by a canonical
         * URL. When an implementation guide is specified, the type SHALL conform
         * to at least one profile defined in the implementation guide.
         */
        public java.util.List<String> profile() {
            return getList(String.class, PROPERTY_PROFILE);
        }

        /**
         * Used when the type is "Reference" or "canonical", and identifies a
         * profile structure or implementation Guide that applies to the target
         * of the reference this element refers to. If any profiles are
         * specified, then the content must conform to at least one of them. The
         * URL can be a local reference - to a contained StructureDefinition, or
         * a reference to another StructureDefinition or Implementation Guide by
         * a canonical URL. When an implementation guide is specified, the target
         * resource SHALL conform to at least one profile defined in the
         * implementation guide.
         */
        public java.util.List<String> targetProfile() {
            return getList(String.class, PROPERTY_TARGETPROFILE);
        }

        /**
         * If the type is a reference to another resource, how the resource is or
         * can be aggregated - is it a contained resource, or a reference, and if
         * the context is a bundle, is it included in the bundle.
         */
        public java.util.List<String> aggregation() {
            return getList(String.class, PROPERTY_AGGREGATION);
        }

        /**
         * Whether this reference needs to be version specific or version
         * independent, or whether either can be used.
         */
        public String versioning() {
            return getString(PROPERTY_VERSIONING);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder profile(final java.util.List<String> profile) {
                b.add(PROPERTY_PROFILE, FhirObject.toStringArray(profile));
                return this;
            }

            public Builder targetProfile(final java.util.List<String> targetProfile) {
                b.add(PROPERTY_TARGETPROFILE, FhirObject.toStringArray(targetProfile));
                return this;
            }

            public Builder aggregation(final java.util.List<String> aggregation) {
                b.add(PROPERTY_AGGREGATION, FhirObject.toStringArray(aggregation));
                return this;
            }

            public Builder versioning(final String versioning) {
                b.add(PROPERTY_VERSIONING, versioning);
                return this;
            }

            public ElementDefinitionType build() {
                return new ElementDefinitionType(b.build());
            }
        }
    }
}
