/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class Encounter extends FhirResource {
    public static final String RESOURCE_TYPE = "Encounter";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_STATUS_HISTORY = "statusHistory";
    public static final String PROPERTY_CLASS = "class";
    public static final String PROPERTY_CLASS_HISTORY = "classHistory";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_SERVICE_TYPE = "serviceType";
    public static final String PROPERTY_PRIORITY = "priority";
    public static final String PROPERTY_SUBJECT = "subject";
    public static final String PROPERTY_EPISODE_OF_CARE = "episodeOfCare";
    public static final String PROPERTY_BASED_ON = "basedOn";
    public static final String PROPERTY_PARTICIPANT = "participant";
    public static final String PROPERTY_APPOINTMENT = "appointment";
    public static final String PROPERTY_PERIOD = "period";
    public static final String PROPERTY_LENGTH = "length";
    public static final String PROPERTY_REASON_CODE = "reasonCode";
    public static final String PROPERTY_REASON_REFERENCE = "reasonReference";
    public static final String PROPERTY_DIAGNOSIS = "diagnosis";
    public static final String PROPERTY_ACCOUNT = "account";
    public static final String PROPERTY_HOSPITALIZATION = "hospitalization";
    public static final String PROPERTY_LOCATION = "location";
    public static final String PROPERTY_SERVICE_PROVIDER = "serviceProvider";
    public static final String PROPERTY_PART_OF = "partOf";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Encounter(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Identifier(s) by which this encounter is known.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * planned | arrived | triaged | in-progress | onleave | finished |
     * cancelled +.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * The status history permits the encounter resource to contain the
     * status history without needing to read through the historical versions
     * of the resource, or even have the server store them.
     */
    public java.util.List<EncounterStatusHistory> statusHistory() {
        return getList(EncounterStatusHistory.class, PROPERTY_STATUS_HISTORY);
    }

    /**
     * Concepts representing classification of patient encounter such as
     * ambulatory (outpatient), inpatient, emergency, home health or others
     * due to local variations.
     */
    public Coding classValue() {
        return getObject(Coding.class, PROPERTY_CLASS);
    }

    /**
     * The class history permits the tracking of the encounters transitions
     * without needing to go  through the resource history.  This would be
     * used for a case where an admission starts of as an emergency
     * encounter, then transitions into an inpatient scenario. Doing this and
     * not restarting a new encounter ensures that any lab/diagnostic results
     * can more easily follow the patient and not require re-processing and
     * not get lost or cancelled during a kind of discharge from emergency to
     * inpatient.
     */
    public java.util.List<EncounterClassHistory> classHistory() {
        return getList(EncounterClassHistory.class, PROPERTY_CLASS_HISTORY);
    }

    /**
     * Specific type of encounter (e.g. e-mail consultation, surgical
     * day-care, skilled nursing, rehabilitation).
     */
    public java.util.List<CodeableConcept> type() {
        return getList(CodeableConcept.class, PROPERTY_TYPE);
    }

    /**
     * Broad categorization of the service that is to be provided (e.g.
     * cardiology).
     */
    public CodeableConcept serviceType() {
        return getObject(CodeableConcept.class, PROPERTY_SERVICE_TYPE);
    }

    /**
     * Indicates the urgency of the encounter.
     */
    public CodeableConcept priority() {
        return getObject(CodeableConcept.class, PROPERTY_PRIORITY);
    }

    /**
     * The patient or group present at the encounter.
     */
    public Reference subject() {
        return getObject(Reference.class, PROPERTY_SUBJECT);
    }

    /**
     * Where a specific encounter should be classified as a part of a
     * specific episode(s) of care this field should be used. This
     * association can facilitate grouping of related encounters together for
     * a specific purpose, such as government reporting, issue tracking,
     * association via a common problem.  The association is recorded on the
     * encounter as these are typically created after the episode of care and
     * grouped on entry rather than editing the episode of care to append
     * another encounter to it (the episode of care could span years).
     */
    public java.util.List<Reference> episodeOfCare() {
        return getList(Reference.class, PROPERTY_EPISODE_OF_CARE);
    }

    /**
     * The request this encounter satisfies (e.g. incoming referral or
     * procedure request).
     */
    public java.util.List<Reference> basedOn() {
        return getList(Reference.class, PROPERTY_BASED_ON);
    }

    /**
     * The list of people responsible for providing the service.
     */
    public java.util.List<EncounterParticipant> participant() {
        return getList(EncounterParticipant.class, PROPERTY_PARTICIPANT);
    }

    /**
     * The appointment that scheduled this encounter.
     */
    public java.util.List<Reference> appointment() {
        return getList(Reference.class, PROPERTY_APPOINTMENT);
    }

    /**
     * The start and end time of the encounter.
     */
    public Period period() {
        return getObject(Period.class, PROPERTY_PERIOD);
    }

    /**
     * Quantity of time the encounter lasted. This excludes the time during
     * leaves of absence.
     */
    public Duration length() {
        return getObject(Duration.class, PROPERTY_LENGTH);
    }

    /**
     * Reason the encounter takes place, expressed as a code. For admissions,
     * this can be used for a coded admission diagnosis.
     */
    public java.util.List<CodeableConcept> reasonCode() {
        return getList(CodeableConcept.class, PROPERTY_REASON_CODE);
    }

    /**
     * Reason the encounter takes place, expressed as a code. For admissions,
     * this can be used for a coded admission diagnosis.
     */
    public java.util.List<Reference> reasonReference() {
        return getList(Reference.class, PROPERTY_REASON_REFERENCE);
    }

    /**
     * The list of diagnosis relevant to this encounter.
     */
    public java.util.List<EncounterDiagnosis> diagnosis() {
        return getList(EncounterDiagnosis.class, PROPERTY_DIAGNOSIS);
    }

    /**
     * The set of accounts that may be used for billing for this Encounter.
     */
    public java.util.List<Reference> account() {
        return getList(Reference.class, PROPERTY_ACCOUNT);
    }

    /**
     * Details about the admission to a healthcare service.
     */
    public EncounterHospitalization hospitalization() {
        return getObject(EncounterHospitalization.class, PROPERTY_HOSPITALIZATION);
    }

    /**
     * List of locations where  the patient has been during this encounter.
     */
    public java.util.List<EncounterLocation> location() {
        return getList(EncounterLocation.class, PROPERTY_LOCATION);
    }

    /**
     * The organization that is primarily responsible for this Encounter's
     * services. This MAY be the same as the organization on the Patient
     * record, however it could be different, such as if the actor performing
     * the services was from an external organization (which may be billed
     * seperately) for an external consultation.  Refer to the example bundle
     * showing an abbreviated set of Encounters for a colonoscopy.
     */
    public Reference serviceProvider() {
        return getObject(Reference.class, PROPERTY_SERVICE_PROVIDER);
    }

    /**
     * Another Encounter of which this encounter is a part of
     * (administratively or in time).
     */
    public Reference partOf() {
        return getObject(Reference.class, PROPERTY_PART_OF);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder statusHistory(final java.util.List<EncounterStatusHistory> statusHistory) {
            b.add(PROPERTY_STATUS_HISTORY, FhirObject.toArray(statusHistory));
            return this;
        }

        public Builder classValue(final Coding classValue) {
            b.add(PROPERTY_CLASS, classValue);
            return this;
        }

        public Builder classHistory(final java.util.List<EncounterClassHistory> classHistory) {
            b.add(PROPERTY_CLASS_HISTORY, FhirObject.toArray(classHistory));
            return this;
        }

        public Builder type(final java.util.List<CodeableConcept> type) {
            b.add(PROPERTY_TYPE, FhirObject.toArray(type));
            return this;
        }

        public Builder serviceType(final CodeableConcept serviceType) {
            b.add(PROPERTY_SERVICE_TYPE, serviceType);
            return this;
        }

        public Builder priority(final CodeableConcept priority) {
            b.add(PROPERTY_PRIORITY, priority);
            return this;
        }

        public Builder subject(final Reference subject) {
            b.add(PROPERTY_SUBJECT, subject);
            return this;
        }

        public Builder episodeOfCare(final java.util.List<Reference> episodeOfCare) {
            b.add(PROPERTY_EPISODE_OF_CARE, FhirObject.toArray(episodeOfCare));
            return this;
        }

        public Builder basedOn(final java.util.List<Reference> basedOn) {
            b.add(PROPERTY_BASED_ON, FhirObject.toArray(basedOn));
            return this;
        }

        public Builder participant(final java.util.List<EncounterParticipant> participant) {
            b.add(PROPERTY_PARTICIPANT, FhirObject.toArray(participant));
            return this;
        }

        public Builder appointment(final java.util.List<Reference> appointment) {
            b.add(PROPERTY_APPOINTMENT, FhirObject.toArray(appointment));
            return this;
        }

        public Builder period(final Period period) {
            b.add(PROPERTY_PERIOD, period);
            return this;
        }

        public Builder length(final Duration length) {
            b.add(PROPERTY_LENGTH, length);
            return this;
        }

        public Builder reasonCode(final java.util.List<CodeableConcept> reasonCode) {
            b.add(PROPERTY_REASON_CODE, FhirObject.toArray(reasonCode));
            return this;
        }

        public Builder reasonReference(final java.util.List<Reference> reasonReference) {
            b.add(PROPERTY_REASON_REFERENCE, FhirObject.toArray(reasonReference));
            return this;
        }

        public Builder diagnosis(final java.util.List<EncounterDiagnosis> diagnosis) {
            b.add(PROPERTY_DIAGNOSIS, FhirObject.toArray(diagnosis));
            return this;
        }

        public Builder account(final java.util.List<Reference> account) {
            b.add(PROPERTY_ACCOUNT, FhirObject.toArray(account));
            return this;
        }

        public Builder hospitalization(final EncounterHospitalization hospitalization) {
            b.add(PROPERTY_HOSPITALIZATION, hospitalization);
            return this;
        }

        public Builder location(final java.util.List<EncounterLocation> location) {
            b.add(PROPERTY_LOCATION, FhirObject.toArray(location));
            return this;
        }

        public Builder serviceProvider(final Reference serviceProvider) {
            b.add(PROPERTY_SERVICE_PROVIDER, serviceProvider);
            return this;
        }

        public Builder partOf(final Reference partOf) {
            b.add(PROPERTY_PART_OF, partOf);
            return this;
        }

        public Encounter build() {
            return new Encounter(b.build());
        }
    }

    public static class EncounterClassHistory extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterClassHistory";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CLASS = "class";
        public static final String PROPERTY_PERIOD = "period";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterClassHistory(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * inpatient | outpatient | ambulatory | emergency +.
         */
        public Coding classValue() {
            return getObject(Coding.class, PROPERTY_CLASS);
        }

        /**
         * The time that the episode was in the specified class.
         */
        public Period period() {
            return getObject(Period.class, PROPERTY_PERIOD);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder classValue(final Coding classValue) {
                b.add(PROPERTY_CLASS, classValue);
                return this;
            }

            public Builder period(final Period period) {
                b.add(PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterClassHistory build() {
                return new EncounterClassHistory(b.build());
            }
        }
    }

    public static class EncounterDiagnosis extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterDiagnosis";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CONDITION = "condition";
        public static final String PROPERTY_USE = "use";
        public static final String PROPERTY_RANK = "rank";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterDiagnosis(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Reason the encounter takes place, as specified using information from
         * another resource. For admissions, this is the admission diagnosis. The
         * indication will typically be a Condition (with other resources
         * referenced in the evidence.detail), or a Procedure.
         */
        public Reference condition() {
            return getObject(Reference.class, PROPERTY_CONDITION);
        }

        /**
         * Role that this diagnosis has within the encounter (e.g. admission,
         * billing, discharge &hellip;).
         */
        public CodeableConcept use() {
            return getObject(CodeableConcept.class, PROPERTY_USE);
        }

        /**
         * Ranking of the diagnosis (for each role type).
         */
        public Integer rank() {
            return data.getInt(PROPERTY_RANK);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder condition(final Reference condition) {
                b.add(PROPERTY_CONDITION, condition);
                return this;
            }

            public Builder use(final CodeableConcept use) {
                b.add(PROPERTY_USE, use);
                return this;
            }

            public Builder rank(final Integer rank) {
                b.add(PROPERTY_RANK, rank);
                return this;
            }

            public EncounterDiagnosis build() {
                return new EncounterDiagnosis(b.build());
            }
        }
    }

    public static class EncounterHospitalization extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterHospitalization";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_PRE_ADMISSION_IDENTIFIER = "preAdmissionIdentifier";
        public static final String PROPERTY_ORIGIN = "origin";
        public static final String PROPERTY_ADMIT_SOURCE = "admitSource";
        public static final String PROPERTY_RE_ADMISSION = "reAdmission";
        public static final String PROPERTY_DIET_PREFERENCE = "dietPreference";
        public static final String PROPERTY_SPECIAL_COURTESY = "specialCourtesy";
        public static final String PROPERTY_SPECIAL_ARRANGEMENT = "specialArrangement";
        public static final String PROPERTY_DESTINATION = "destination";
        public static final String PROPERTY_DISCHARGE_DISPOSITION = "dischargeDisposition";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterHospitalization(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Pre-admission identifier.
         */
        public Identifier preAdmissionIdentifier() {
            return getObject(Identifier.class, PROPERTY_PRE_ADMISSION_IDENTIFIER);
        }

        /**
         * The location/organization from which the patient came before
         * admission.
         */
        public Reference origin() {
            return getObject(Reference.class, PROPERTY_ORIGIN);
        }

        /**
         * From where patient was admitted (physician referral, transfer).
         */
        public CodeableConcept admitSource() {
            return getObject(CodeableConcept.class, PROPERTY_ADMIT_SOURCE);
        }

        /**
         * Whether this hospitalization is a readmission and why if known.
         */
        public CodeableConcept reAdmission() {
            return getObject(CodeableConcept.class, PROPERTY_RE_ADMISSION);
        }

        /**
         * Diet preferences reported by the patient.
         */
        public java.util.List<CodeableConcept> dietPreference() {
            return getList(CodeableConcept.class, PROPERTY_DIET_PREFERENCE);
        }

        /**
         * Special courtesies (VIP, board member).
         */
        public java.util.List<CodeableConcept> specialCourtesy() {
            return getList(CodeableConcept.class, PROPERTY_SPECIAL_COURTESY);
        }

        /**
         * Any special requests that have been made for this hospitalization
         * encounter, such as the provision of specific equipment or other
         * things.
         */
        public java.util.List<CodeableConcept> specialArrangement() {
            return getList(CodeableConcept.class, PROPERTY_SPECIAL_ARRANGEMENT);
        }

        /**
         * Location/organization to which the patient is discharged.
         */
        public Reference destination() {
            return getObject(Reference.class, PROPERTY_DESTINATION);
        }

        /**
         * Category or kind of location after discharge.
         */
        public CodeableConcept dischargeDisposition() {
            return getObject(CodeableConcept.class, PROPERTY_DISCHARGE_DISPOSITION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder preAdmissionIdentifier(final Identifier preAdmissionIdentifier) {
                b.add(PROPERTY_PRE_ADMISSION_IDENTIFIER, preAdmissionIdentifier);
                return this;
            }

            public Builder origin(final Reference origin) {
                b.add(PROPERTY_ORIGIN, origin);
                return this;
            }

            public Builder admitSource(final CodeableConcept admitSource) {
                b.add(PROPERTY_ADMIT_SOURCE, admitSource);
                return this;
            }

            public Builder reAdmission(final CodeableConcept reAdmission) {
                b.add(PROPERTY_RE_ADMISSION, reAdmission);
                return this;
            }

            public Builder dietPreference(final java.util.List<CodeableConcept> dietPreference) {
                b.add(PROPERTY_DIET_PREFERENCE, FhirObject.toArray(dietPreference));
                return this;
            }

            public Builder specialCourtesy(final java.util.List<CodeableConcept> specialCourtesy) {
                b.add(PROPERTY_SPECIAL_COURTESY, FhirObject.toArray(specialCourtesy));
                return this;
            }

            public Builder specialArrangement(final java.util.List<CodeableConcept> specialArrangement) {
                b.add(PROPERTY_SPECIAL_ARRANGEMENT, FhirObject.toArray(specialArrangement));
                return this;
            }

            public Builder destination(final Reference destination) {
                b.add(PROPERTY_DESTINATION, destination);
                return this;
            }

            public Builder dischargeDisposition(final CodeableConcept dischargeDisposition) {
                b.add(PROPERTY_DISCHARGE_DISPOSITION, dischargeDisposition);
                return this;
            }

            public EncounterHospitalization build() {
                return new EncounterHospitalization(b.build());
            }
        }
    }

    public static class EncounterLocation extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterLocation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_LOCATION = "location";
        public static final String PROPERTY_STATUS = "status";
        public static final String PROPERTY_PHYSICAL_TYPE = "physicalType";
        public static final String PROPERTY_PERIOD = "period";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterLocation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The location where the encounter takes place.
         */
        public Reference location() {
            return getObject(Reference.class, PROPERTY_LOCATION);
        }

        /**
         * The status of the participants' presence at the specified location
         * during the period specified. If the participant is no longer at the
         * location, then the period will have an end date/time.
         */
        public String status() {
            return getString(PROPERTY_STATUS);
        }

        /**
         * This will be used to specify the required levels (bed/ward/room/etc.)
         * desired to be recorded to simplify either messaging or query.
         */
        public CodeableConcept physicalType() {
            return getObject(CodeableConcept.class, PROPERTY_PHYSICAL_TYPE);
        }

        /**
         * Time period during which the patient was present at the location.
         */
        public Period period() {
            return getObject(Period.class, PROPERTY_PERIOD);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder location(final Reference location) {
                b.add(PROPERTY_LOCATION, location);
                return this;
            }

            public Builder status(final String status) {
                b.add(PROPERTY_STATUS, status);
                return this;
            }

            public Builder physicalType(final CodeableConcept physicalType) {
                b.add(PROPERTY_PHYSICAL_TYPE, physicalType);
                return this;
            }

            public Builder period(final Period period) {
                b.add(PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterLocation build() {
                return new EncounterLocation(b.build());
            }
        }
    }

    public static class EncounterParticipant extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterParticipant";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_PERIOD = "period";
        public static final String PROPERTY_INDIVIDUAL = "individual";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterParticipant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Role of participant in encounter.
         */
        public java.util.List<CodeableConcept> type() {
            return getList(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * The period of time that the specified participant participated in the
         * encounter. These can overlap or be sub-sets of the overall encounter's
         * period.
         */
        public Period period() {
            return getObject(Period.class, PROPERTY_PERIOD);
        }

        /**
         * Persons involved in the encounter other than the patient.
         */
        public Reference individual() {
            return getObject(Reference.class, PROPERTY_INDIVIDUAL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final java.util.List<CodeableConcept> type) {
                b.add(PROPERTY_TYPE, FhirObject.toArray(type));
                return this;
            }

            public Builder period(final Period period) {
                b.add(PROPERTY_PERIOD, period);
                return this;
            }

            public Builder individual(final Reference individual) {
                b.add(PROPERTY_INDIVIDUAL, individual);
                return this;
            }

            public EncounterParticipant build() {
                return new EncounterParticipant(b.build());
            }
        }
    }

    public static class EncounterStatusHistory extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterStatusHistory";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_STATUS = "status";
        public static final String PROPERTY_PERIOD = "period";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterStatusHistory(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * planned | arrived | triaged | in-progress | onleave | finished |
         * cancelled +.
         */
        public String status() {
            return getString(PROPERTY_STATUS);
        }

        /**
         * The time that the episode was in the specified status.
         */
        public Period period() {
            return getObject(Period.class, PROPERTY_PERIOD);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder status(final String status) {
                b.add(PROPERTY_STATUS, status);
                return this;
            }

            public Builder period(final Period period) {
                b.add(PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterStatusHistory build() {
                return new EncounterStatusHistory(b.build());
            }
        }
    }
}
