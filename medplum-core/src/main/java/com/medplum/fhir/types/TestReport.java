/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class TestReport extends FhirResource {
    public static final String RESOURCE_TYPE = "TestReport";
    public static final String PROPERTY_RESOURCETYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICITRULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_TESTSCRIPT = "testScript";
    public static final String PROPERTY_RESULT = "result";
    public static final String PROPERTY_SCORE = "score";
    public static final String PROPERTY_TESTER = "tester";
    public static final String PROPERTY_ISSUED = "issued";
    public static final String PROPERTY_PARTICIPANT = "participant";
    public static final String PROPERTY_SETUP = "setup";
    public static final String PROPERTY_TEST = "test";
    public static final String PROPERTY_TEARDOWN = "teardown";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public TestReport(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICITRULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * Identifier for the TestScript assigned for external purposes outside the context of FHIR.
     */
    public Identifier identifier() {
        return getObject(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * A free text natural language name identifying the executed TestScript.
     */
    public String name() {
        return getString(PROPERTY_NAME);
    }

    /**
     * The current state of this test report.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
     */
    public Reference testScript() {
        return getObject(Reference.class, PROPERTY_TESTSCRIPT);
    }

    /**
     * The overall result from the execution of the TestScript.
     */
    public String result() {
        return getString(PROPERTY_RESULT);
    }

    /**
     * The final score (percentage of tests passed) resulting from the execution of the TestScript.
     */
    public Double score() {
        return data.getJsonNumber(PROPERTY_SCORE).doubleValue();
    }

    /**
     * Name of the tester producing this report (Organization or individual).
     */
    public String tester() {
        return getString(PROPERTY_TESTER);
    }

    /**
     * When the TestScript was executed and this TestReport was generated.
     */
    public java.time.Instant issued() {
        return java.time.Instant.parse(data.getString(PROPERTY_ISSUED));
    }

    /**
     * A participant in the test execution, either the execution engine, a client, or a server.
     */
    public java.util.List<TestReportParticipant> participant() {
        return getList(TestReportParticipant.class, PROPERTY_PARTICIPANT);
    }

    /**
     * The results of the series of required setup operations before the tests were executed.
     */
    public TestReportSetup setup() {
        return getObject(TestReportSetup.class, PROPERTY_SETUP);
    }

    /**
     * A test executed from the test script.
     */
    public java.util.List<TestReportTest> test() {
        return getList(TestReportTest.class, PROPERTY_TEST);
    }

    /**
     * The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
     */
    public TestReportTeardown teardown() {
        return getObject(TestReportTeardown.class, PROPERTY_TEARDOWN);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCETYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICITRULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final Identifier identifier) {
            b.add(PROPERTY_IDENTIFIER, identifier);
            return this;
        }

        public Builder name(final String name) {
            b.add(PROPERTY_NAME, name);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder testScript(final Reference testScript) {
            b.add(PROPERTY_TESTSCRIPT, testScript);
            return this;
        }

        public Builder result(final String result) {
            b.add(PROPERTY_RESULT, result);
            return this;
        }

        public Builder score(final Double score) {
            b.add(PROPERTY_SCORE, score);
            return this;
        }

        public Builder tester(final String tester) {
            b.add(PROPERTY_TESTER, tester);
            return this;
        }

        public Builder issued(final java.time.Instant issued) {
            b.add(PROPERTY_ISSUED, issued.toString());
            return this;
        }

        public Builder participant(final java.util.List<TestReportParticipant> participant) {
            b.add(PROPERTY_PARTICIPANT, FhirObject.toArray(participant));
            return this;
        }

        public Builder setup(final TestReportSetup setup) {
            b.add(PROPERTY_SETUP, setup);
            return this;
        }

        public Builder test(final java.util.List<TestReportTest> test) {
            b.add(PROPERTY_TEST, FhirObject.toArray(test));
            return this;
        }

        public Builder teardown(final TestReportTeardown teardown) {
            b.add(PROPERTY_TEARDOWN, teardown);
            return this;
        }

        public TestReport build() {
            return new TestReport(b.build());
        }
    }

    public static class TestReportAction extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_OPERATION = "operation";
        public static final String PROPERTY_ASSERT = "assert";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The operation performed.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, PROPERTY_OPERATION);
        }

        /**
         * The results of the assertion performed on the previous operations.
         */
        public TestReportAssert assert_() {
            return getObject(TestReportAssert.class, PROPERTY_ASSERT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(PROPERTY_OPERATION, operation);
                return this;
            }

            public Builder assert_(final TestReportAssert assert_) {
                b.add(PROPERTY_ASSERT, assert_);
                return this;
            }

            public TestReportAction build() {
                return new TestReportAction(b.build());
            }
        }
    }

    public static class TestReportAction1 extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction1";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_OPERATION = "operation";
        public static final String PROPERTY_ASSERT = "assert";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * An operation would involve a REST request to a server.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, PROPERTY_OPERATION);
        }

        /**
         * The results of the assertion performed on the previous operations.
         */
        public TestReportAssert assert_() {
            return getObject(TestReportAssert.class, PROPERTY_ASSERT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(PROPERTY_OPERATION, operation);
                return this;
            }

            public Builder assert_(final TestReportAssert assert_) {
                b.add(PROPERTY_ASSERT, assert_);
                return this;
            }

            public TestReportAction1 build() {
                return new TestReportAction1(b.build());
            }
        }
    }

    public static class TestReportAction2 extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction2";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_OPERATION = "operation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction2(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * An operation would involve a REST request to a server.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, PROPERTY_OPERATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(PROPERTY_OPERATION, operation);
                return this;
            }

            public TestReportAction2 build() {
                return new TestReportAction2(b.build());
            }
        }
    }

    public static class TestReportAssert extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAssert";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_RESULT = "result";
        public static final String PROPERTY_MESSAGE = "message";
        public static final String PROPERTY_DETAIL = "detail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAssert(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The result of this assertion.
         */
        public String result() {
            return getString(PROPERTY_RESULT);
        }

        /**
         * An explanatory message associated with the result.
         */
        public String message() {
            return getString(PROPERTY_MESSAGE);
        }

        /**
         * A link to further details on the result.
         */
        public String detail() {
            return getString(PROPERTY_DETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder result(final String result) {
                b.add(PROPERTY_RESULT, result);
                return this;
            }

            public Builder message(final String message) {
                b.add(PROPERTY_MESSAGE, message);
                return this;
            }

            public Builder detail(final String detail) {
                b.add(PROPERTY_DETAIL, detail);
                return this;
            }

            public TestReportAssert build() {
                return new TestReportAssert(b.build());
            }
        }
    }

    public static class TestReportOperation extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportOperation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_RESULT = "result";
        public static final String PROPERTY_MESSAGE = "message";
        public static final String PROPERTY_DETAIL = "detail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportOperation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The result of this operation.
         */
        public String result() {
            return getString(PROPERTY_RESULT);
        }

        /**
         * An explanatory message associated with the result.
         */
        public String message() {
            return getString(PROPERTY_MESSAGE);
        }

        /**
         * A link to further details on the result.
         */
        public String detail() {
            return getString(PROPERTY_DETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder result(final String result) {
                b.add(PROPERTY_RESULT, result);
                return this;
            }

            public Builder message(final String message) {
                b.add(PROPERTY_MESSAGE, message);
                return this;
            }

            public Builder detail(final String detail) {
                b.add(PROPERTY_DETAIL, detail);
                return this;
            }

            public TestReportOperation build() {
                return new TestReportOperation(b.build());
            }
        }
    }

    public static class TestReportParticipant extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportParticipant";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_URI = "uri";
        public static final String PROPERTY_DISPLAY = "display";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportParticipant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The type of participant.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * The uri of the participant. An absolute URL is preferred.
         */
        public String uri() {
            return getString(PROPERTY_URI);
        }

        /**
         * The display name of the participant.
         */
        public String display() {
            return getString(PROPERTY_DISPLAY);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder uri(final String uri) {
                b.add(PROPERTY_URI, uri);
                return this;
            }

            public Builder display(final String display) {
                b.add(PROPERTY_DISPLAY, display);
                return this;
            }

            public TestReportParticipant build() {
                return new TestReportParticipant(b.build());
            }
        }
    }

    public static class TestReportSetup extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportSetup";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_ACTION = "action";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportSetup(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Action would contain either an operation or an assertion.
         */
        public java.util.List<TestReportAction> action() {
            return getList(TestReportAction.class, PROPERTY_ACTION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder action(final java.util.List<TestReportAction> action) {
                b.add(PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportSetup build() {
                return new TestReportSetup(b.build());
            }
        }
    }

    public static class TestReportTeardown extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportTeardown";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_ACTION = "action";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportTeardown(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The teardown action will only contain an operation.
         */
        public java.util.List<TestReportAction2> action() {
            return getList(TestReportAction2.class, PROPERTY_ACTION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder action(final java.util.List<TestReportAction2> action) {
                b.add(PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportTeardown build() {
                return new TestReportTeardown(b.build());
            }
        }
    }

    public static class TestReportTest extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportTest";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_ACTION = "action";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportTest(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The name of this test used for tracking/logging purposes by test engines.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * A short description of the test used by test engines for tracking and reporting purposes.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * Action would contain either an operation or an assertion.
         */
        public java.util.List<TestReportAction1> action() {
            return getList(TestReportAction1.class, PROPERTY_ACTION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder action(final java.util.List<TestReportAction1> action) {
                b.add(PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportTest build() {
                return new TestReportTest(b.build());
            }
        }
    }
}
