/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class Goal extends FhirResource {
    public static final String RESOURCE_TYPE = "Goal";
    public static final String PROPERTY_RESOURCETYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICITRULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_LIFECYCLESTATUS = "lifecycleStatus";
    public static final String PROPERTY_ACHIEVEMENTSTATUS = "achievementStatus";
    public static final String PROPERTY_CATEGORY = "category";
    public static final String PROPERTY_PRIORITY = "priority";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_SUBJECT = "subject";
    public static final String PROPERTY_STARTDATE = "startDate";
    public static final String PROPERTY_STARTCODEABLECONCEPT = "startCodeableConcept";
    public static final String PROPERTY_TARGET = "target";
    public static final String PROPERTY_STATUSDATE = "statusDate";
    public static final String PROPERTY_STATUSREASON = "statusReason";
    public static final String PROPERTY_EXPRESSEDBY = "expressedBy";
    public static final String PROPERTY_ADDRESSES = "addresses";
    public static final String PROPERTY_NOTE = "note";
    public static final String PROPERTY_OUTCOMECODE = "outcomeCode";
    public static final String PROPERTY_OUTCOMEREFERENCE = "outcomeReference";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Goal(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICITRULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * Business identifiers assigned to this goal by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * The state of the goal throughout its lifecycle.
     */
    public String lifecycleStatus() {
        return getString(PROPERTY_LIFECYCLESTATUS);
    }

    /**
     * Describes the progression, or lack thereof, towards the goal against the target.
     */
    public CodeableConcept achievementStatus() {
        return getObject(CodeableConcept.class, PROPERTY_ACHIEVEMENTSTATUS);
    }

    /**
     * Indicates a category the goal falls within.
     */
    public java.util.List<CodeableConcept> category() {
        return getList(CodeableConcept.class, PROPERTY_CATEGORY);
    }

    /**
     * Identifies the mutually agreed level of importance associated with reaching/sustaining the goal.
     */
    public CodeableConcept priority() {
        return getObject(CodeableConcept.class, PROPERTY_PRIORITY);
    }

    /**
     * Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
     */
    public CodeableConcept description() {
        return getObject(CodeableConcept.class, PROPERTY_DESCRIPTION);
    }

    /**
     * Identifies the patient, group or organization for whom the goal is being established.
     */
    public Reference subject() {
        return getObject(Reference.class, PROPERTY_SUBJECT);
    }

    /**
     * The date or event after which the goal should begin being pursued.
     */
    public String startDate() {
        return getString(PROPERTY_STARTDATE);
    }

    /**
     * The date or event after which the goal should begin being pursued.
     */
    public CodeableConcept startCodeableConcept() {
        return getObject(CodeableConcept.class, PROPERTY_STARTCODEABLECONCEPT);
    }

    /**
     * Indicates what should be done by when.
     */
    public java.util.List<GoalTarget> target() {
        return getList(GoalTarget.class, PROPERTY_TARGET);
    }

    /**
     * Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
     */
    public java.time.Instant statusDate() {
        return java.time.Instant.parse(data.getString(PROPERTY_STATUSDATE));
    }

    /**
     * Captures the reason for the current status.
     */
    public String statusReason() {
        return getString(PROPERTY_STATUSREASON);
    }

    /**
     * Indicates whose goal this is - patient goal, practitioner goal, etc.
     */
    public Reference expressedBy() {
        return getObject(Reference.class, PROPERTY_EXPRESSEDBY);
    }

    /**
     * The identified conditions and other health record elements that are intended to be addressed by the goal.
     */
    public java.util.List<Reference> addresses() {
        return getList(Reference.class, PROPERTY_ADDRESSES);
    }

    /**
     * Any comments related to the goal.
     */
    public java.util.List<Annotation> note() {
        return getList(Annotation.class, PROPERTY_NOTE);
    }

    /**
     * Identifies the change (or lack of change) at the point when the status of the goal is assessed.
     */
    public java.util.List<CodeableConcept> outcomeCode() {
        return getList(CodeableConcept.class, PROPERTY_OUTCOMECODE);
    }

    /**
     * Details of what's changed (or not changed).
     */
    public java.util.List<Reference> outcomeReference() {
        return getList(Reference.class, PROPERTY_OUTCOMEREFERENCE);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCETYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICITRULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder lifecycleStatus(final String lifecycleStatus) {
            b.add(PROPERTY_LIFECYCLESTATUS, lifecycleStatus);
            return this;
        }

        public Builder achievementStatus(final CodeableConcept achievementStatus) {
            b.add(PROPERTY_ACHIEVEMENTSTATUS, achievementStatus);
            return this;
        }

        public Builder category(final java.util.List<CodeableConcept> category) {
            b.add(PROPERTY_CATEGORY, FhirObject.toArray(category));
            return this;
        }

        public Builder priority(final CodeableConcept priority) {
            b.add(PROPERTY_PRIORITY, priority);
            return this;
        }

        public Builder description(final CodeableConcept description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder subject(final Reference subject) {
            b.add(PROPERTY_SUBJECT, subject);
            return this;
        }

        public Builder startDate(final String startDate) {
            b.add(PROPERTY_STARTDATE, startDate);
            return this;
        }

        public Builder startCodeableConcept(final CodeableConcept startCodeableConcept) {
            b.add(PROPERTY_STARTCODEABLECONCEPT, startCodeableConcept);
            return this;
        }

        public Builder target(final java.util.List<GoalTarget> target) {
            b.add(PROPERTY_TARGET, FhirObject.toArray(target));
            return this;
        }

        public Builder statusDate(final java.time.Instant statusDate) {
            b.add(PROPERTY_STATUSDATE, statusDate.toString());
            return this;
        }

        public Builder statusReason(final String statusReason) {
            b.add(PROPERTY_STATUSREASON, statusReason);
            return this;
        }

        public Builder expressedBy(final Reference expressedBy) {
            b.add(PROPERTY_EXPRESSEDBY, expressedBy);
            return this;
        }

        public Builder addresses(final java.util.List<Reference> addresses) {
            b.add(PROPERTY_ADDRESSES, FhirObject.toArray(addresses));
            return this;
        }

        public Builder note(final java.util.List<Annotation> note) {
            b.add(PROPERTY_NOTE, FhirObject.toArray(note));
            return this;
        }

        public Builder outcomeCode(final java.util.List<CodeableConcept> outcomeCode) {
            b.add(PROPERTY_OUTCOMECODE, FhirObject.toArray(outcomeCode));
            return this;
        }

        public Builder outcomeReference(final java.util.List<Reference> outcomeReference) {
            b.add(PROPERTY_OUTCOMEREFERENCE, FhirObject.toArray(outcomeReference));
            return this;
        }

        public Goal build() {
            return new Goal(b.build());
        }
    }

    public static class GoalTarget extends FhirObject {
        public static final String RESOURCE_TYPE = "GoalTarget";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_MEASURE = "measure";
        public static final String PROPERTY_DETAILQUANTITY = "detailQuantity";
        public static final String PROPERTY_DETAILRANGE = "detailRange";
        public static final String PROPERTY_DETAILCODEABLECONCEPT = "detailCodeableConcept";
        public static final String PROPERTY_DETAILSTRING = "detailString";
        public static final String PROPERTY_DETAILBOOLEAN = "detailBoolean";
        public static final String PROPERTY_DETAILINTEGER = "detailInteger";
        public static final String PROPERTY_DETAILRATIO = "detailRatio";
        public static final String PROPERTY_DUEDATE = "dueDate";
        public static final String PROPERTY_DUEDURATION = "dueDuration";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public GoalTarget(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
         */
        public CodeableConcept measure() {
            return getObject(CodeableConcept.class, PROPERTY_MEASURE);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public Quantity detailQuantity() {
            return getObject(Quantity.class, PROPERTY_DETAILQUANTITY);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public Range detailRange() {
            return getObject(Range.class, PROPERTY_DETAILRANGE);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public CodeableConcept detailCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_DETAILCODEABLECONCEPT);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public String detailString() {
            return getString(PROPERTY_DETAILSTRING);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public Boolean detailBoolean() {
            return data.getBoolean(PROPERTY_DETAILBOOLEAN);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public Integer detailInteger() {
            return data.getInt(PROPERTY_DETAILINTEGER);
        }

        /**
         * The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
         */
        public Ratio detailRatio() {
            return getObject(Ratio.class, PROPERTY_DETAILRATIO);
        }

        /**
         * Indicates either the date or the duration after start by which the goal should be met.
         */
        public String dueDate() {
            return getString(PROPERTY_DUEDATE);
        }

        /**
         * Indicates either the date or the duration after start by which the goal should be met.
         */
        public Duration dueDuration() {
            return getObject(Duration.class, PROPERTY_DUEDURATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder measure(final CodeableConcept measure) {
                b.add(PROPERTY_MEASURE, measure);
                return this;
            }

            public Builder detailQuantity(final Quantity detailQuantity) {
                b.add(PROPERTY_DETAILQUANTITY, detailQuantity);
                return this;
            }

            public Builder detailRange(final Range detailRange) {
                b.add(PROPERTY_DETAILRANGE, detailRange);
                return this;
            }

            public Builder detailCodeableConcept(final CodeableConcept detailCodeableConcept) {
                b.add(PROPERTY_DETAILCODEABLECONCEPT, detailCodeableConcept);
                return this;
            }

            public Builder detailString(final String detailString) {
                b.add(PROPERTY_DETAILSTRING, detailString);
                return this;
            }

            public Builder detailBoolean(final Boolean detailBoolean) {
                b.add(PROPERTY_DETAILBOOLEAN, detailBoolean);
                return this;
            }

            public Builder detailInteger(final Integer detailInteger) {
                b.add(PROPERTY_DETAILINTEGER, detailInteger);
                return this;
            }

            public Builder detailRatio(final Ratio detailRatio) {
                b.add(PROPERTY_DETAILRATIO, detailRatio);
                return this;
            }

            public Builder dueDate(final String dueDate) {
                b.add(PROPERTY_DUEDATE, dueDate);
                return this;
            }

            public Builder dueDuration(final Duration dueDuration) {
                b.add(PROPERTY_DUEDURATION, dueDuration);
                return this;
            }

            public GoalTarget build() {
                return new GoalTarget(b.build());
            }
        }
    }
}
