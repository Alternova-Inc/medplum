/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class ExplanationOfBenefit extends FhirResource {
    public static final String RESOURCE_TYPE = "ExplanationOfBenefit";
    public static final String PROPERTY_RESOURCETYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICITRULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_SUBTYPE = "subType";
    public static final String PROPERTY_USE = "use";
    public static final String PROPERTY_PATIENT = "patient";
    public static final String PROPERTY_BILLABLEPERIOD = "billablePeriod";
    public static final String PROPERTY_CREATED = "created";
    public static final String PROPERTY_ENTERER = "enterer";
    public static final String PROPERTY_INSURER = "insurer";
    public static final String PROPERTY_PROVIDER = "provider";
    public static final String PROPERTY_PRIORITY = "priority";
    public static final String PROPERTY_FUNDSRESERVEREQUESTED = "fundsReserveRequested";
    public static final String PROPERTY_FUNDSRESERVE = "fundsReserve";
    public static final String PROPERTY_RELATED = "related";
    public static final String PROPERTY_PRESCRIPTION = "prescription";
    public static final String PROPERTY_ORIGINALPRESCRIPTION = "originalPrescription";
    public static final String PROPERTY_PAYEE = "payee";
    public static final String PROPERTY_REFERRAL = "referral";
    public static final String PROPERTY_FACILITY = "facility";
    public static final String PROPERTY_CLAIM = "claim";
    public static final String PROPERTY_CLAIMRESPONSE = "claimResponse";
    public static final String PROPERTY_OUTCOME = "outcome";
    public static final String PROPERTY_DISPOSITION = "disposition";
    public static final String PROPERTY_PREAUTHREF = "preAuthRef";
    public static final String PROPERTY_PREAUTHREFPERIOD = "preAuthRefPeriod";
    public static final String PROPERTY_CARETEAM = "careTeam";
    public static final String PROPERTY_SUPPORTINGINFO = "supportingInfo";
    public static final String PROPERTY_DIAGNOSIS = "diagnosis";
    public static final String PROPERTY_PROCEDURE = "procedure";
    public static final String PROPERTY_PRECEDENCE = "precedence";
    public static final String PROPERTY_INSURANCE = "insurance";
    public static final String PROPERTY_ACCIDENT = "accident";
    public static final String PROPERTY_ITEM = "item";
    public static final String PROPERTY_ADDITEM = "addItem";
    public static final String PROPERTY_ADJUDICATION = "adjudication";
    public static final String PROPERTY_TOTAL = "total";
    public static final String PROPERTY_PAYMENT = "payment";
    public static final String PROPERTY_FORMCODE = "formCode";
    public static final String PROPERTY_FORM = "form";
    public static final String PROPERTY_PROCESSNOTE = "processNote";
    public static final String PROPERTY_BENEFITPERIOD = "benefitPeriod";
    public static final String PROPERTY_BENEFITBALANCE = "benefitBalance";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public ExplanationOfBenefit(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICITRULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * A unique identifier assigned to this explanation of benefit.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * The status of the resource instance.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * The category of claim, e.g. oral, pharmacy, vision, institutional, professional.
     */
    public CodeableConcept type() {
        return getObject(CodeableConcept.class, PROPERTY_TYPE);
    }

    /**
     * A finer grained suite of claim type codes which may convey additional information such as Inpatient vs Outpatient and/or a specialty service.
     */
    public CodeableConcept subType() {
        return getObject(CodeableConcept.class, PROPERTY_SUBTYPE);
    }

    /**
     * A code to indicate whether the nature of the request is: to request adjudication of products and services previously rendered; or requesting authorization and adjudication for provision in the future; or requesting the non-binding adjudication of the listed products and services which could be provided in the future.
     */
    public String use() {
        return getString(PROPERTY_USE);
    }

    /**
     * The party to whom the professional services and/or products have been supplied or are being considered and for whom actual for forecast reimbursement is sought.
     */
    public Reference patient() {
        return getObject(Reference.class, PROPERTY_PATIENT);
    }

    /**
     * The period for which charges are being submitted.
     */
    public Period billablePeriod() {
        return getObject(Period.class, PROPERTY_BILLABLEPERIOD);
    }

    /**
     * The date this resource was created.
     */
    public java.time.Instant created() {
        return java.time.Instant.parse(data.getString(PROPERTY_CREATED));
    }

    /**
     * Individual who created the claim, predetermination or preauthorization.
     */
    public Reference enterer() {
        return getObject(Reference.class, PROPERTY_ENTERER);
    }

    /**
     * The party responsible for authorization, adjudication and reimbursement.
     */
    public Reference insurer() {
        return getObject(Reference.class, PROPERTY_INSURER);
    }

    /**
     * The provider which is responsible for the claim, predetermination or preauthorization.
     */
    public Reference provider() {
        return getObject(Reference.class, PROPERTY_PROVIDER);
    }

    /**
     * The provider-required urgency of processing the request. Typical values include: stat, routine deferred.
     */
    public CodeableConcept priority() {
        return getObject(CodeableConcept.class, PROPERTY_PRIORITY);
    }

    /**
     * A code to indicate whether and for whom funds are to be reserved for future claims.
     */
    public CodeableConcept fundsReserveRequested() {
        return getObject(CodeableConcept.class, PROPERTY_FUNDSRESERVEREQUESTED);
    }

    /**
     * A code, used only on a response to a preauthorization, to indicate whether the benefits payable have been reserved and for whom.
     */
    public CodeableConcept fundsReserve() {
        return getObject(CodeableConcept.class, PROPERTY_FUNDSRESERVE);
    }

    /**
     * Other claims which are related to this claim such as prior submissions or claims for related services or for the same event.
     */
    public java.util.List<ExplanationOfBenefitRelated> related() {
        return getList(ExplanationOfBenefitRelated.class, PROPERTY_RELATED);
    }

    /**
     * Prescription to support the dispensing of pharmacy, device or vision products.
     */
    public Reference prescription() {
        return getObject(Reference.class, PROPERTY_PRESCRIPTION);
    }

    /**
     * Original prescription which has been superseded by this prescription to support the dispensing of pharmacy services, medications or products.
     */
    public Reference originalPrescription() {
        return getObject(Reference.class, PROPERTY_ORIGINALPRESCRIPTION);
    }

    /**
     * The party to be reimbursed for cost of the products and services according to the terms of the policy.
     */
    public ExplanationOfBenefitPayee payee() {
        return getObject(ExplanationOfBenefitPayee.class, PROPERTY_PAYEE);
    }

    /**
     * A reference to a referral resource.
     */
    public Reference referral() {
        return getObject(Reference.class, PROPERTY_REFERRAL);
    }

    /**
     * Facility where the services were provided.
     */
    public Reference facility() {
        return getObject(Reference.class, PROPERTY_FACILITY);
    }

    /**
     * The business identifier for the instance of the adjudication request: claim predetermination or preauthorization.
     */
    public Reference claim() {
        return getObject(Reference.class, PROPERTY_CLAIM);
    }

    /**
     * The business identifier for the instance of the adjudication response: claim, predetermination or preauthorization response.
     */
    public Reference claimResponse() {
        return getObject(Reference.class, PROPERTY_CLAIMRESPONSE);
    }

    /**
     * The outcome of the claim, predetermination, or preauthorization processing.
     */
    public String outcome() {
        return getString(PROPERTY_OUTCOME);
    }

    /**
     * A human readable description of the status of the adjudication.
     */
    public String disposition() {
        return getString(PROPERTY_DISPOSITION);
    }

    /**
     * Reference from the Insurer which is used in later communications which refers to this adjudication.
     */
    public java.util.List<String> preAuthRef() {
        return getList(String.class, PROPERTY_PREAUTHREF);
    }

    /**
     * The timeframe during which the supplied preauthorization reference may be quoted on claims to obtain the adjudication as provided.
     */
    public java.util.List<Period> preAuthRefPeriod() {
        return getList(Period.class, PROPERTY_PREAUTHREFPERIOD);
    }

    /**
     * The members of the team who provided the products and services.
     */
    public java.util.List<ExplanationOfBenefitCareTeam> careTeam() {
        return getList(ExplanationOfBenefitCareTeam.class, PROPERTY_CARETEAM);
    }

    /**
     * Additional information codes regarding exceptions, special considerations, the condition, situation, prior or concurrent issues.
     */
    public java.util.List<ExplanationOfBenefitSupportingInfo> supportingInfo() {
        return getList(ExplanationOfBenefitSupportingInfo.class, PROPERTY_SUPPORTINGINFO);
    }

    /**
     * Information about diagnoses relevant to the claim items.
     */
    public java.util.List<ExplanationOfBenefitDiagnosis> diagnosis() {
        return getList(ExplanationOfBenefitDiagnosis.class, PROPERTY_DIAGNOSIS);
    }

    /**
     * Procedures performed on the patient relevant to the billing items with the claim.
     */
    public java.util.List<ExplanationOfBenefitProcedure> procedure() {
        return getList(ExplanationOfBenefitProcedure.class, PROPERTY_PROCEDURE);
    }

    /**
     * This indicates the relative order of a series of EOBs related to different coverages for the same suite of services.
     */
    public Integer precedence() {
        return data.getInt(PROPERTY_PRECEDENCE);
    }

    /**
     * Financial instruments for reimbursement for the health care products and services specified on the claim.
     */
    public java.util.List<ExplanationOfBenefitInsurance> insurance() {
        return getList(ExplanationOfBenefitInsurance.class, PROPERTY_INSURANCE);
    }

    /**
     * Details of a accident which resulted in injuries which required the products and services listed in the claim.
     */
    public ExplanationOfBenefitAccident accident() {
        return getObject(ExplanationOfBenefitAccident.class, PROPERTY_ACCIDENT);
    }

    /**
     * A claim line. Either a simple (a product or service) or a 'group' of details which can also be a simple items or groups of sub-details.
     */
    public java.util.List<ExplanationOfBenefitItem> item() {
        return getList(ExplanationOfBenefitItem.class, PROPERTY_ITEM);
    }

    /**
     * The first-tier service adjudications for payor added product or service lines.
     */
    public java.util.List<ExplanationOfBenefitAddItem> addItem() {
        return getList(ExplanationOfBenefitAddItem.class, PROPERTY_ADDITEM);
    }

    /**
     * The adjudication results which are presented at the header level rather than at the line-item or add-item levels.
     */
    public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
        return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
    }

    /**
     * Categorized monetary totals for the adjudication.
     */
    public java.util.List<ExplanationOfBenefitTotal> total() {
        return getList(ExplanationOfBenefitTotal.class, PROPERTY_TOTAL);
    }

    /**
     * Payment details for the adjudication of the claim.
     */
    public ExplanationOfBenefitPayment payment() {
        return getObject(ExplanationOfBenefitPayment.class, PROPERTY_PAYMENT);
    }

    /**
     * A code for the form to be used for printing the content.
     */
    public CodeableConcept formCode() {
        return getObject(CodeableConcept.class, PROPERTY_FORMCODE);
    }

    /**
     * The actual form, by reference or inclusion, for printing the content or an EOB.
     */
    public Attachment form() {
        return getObject(Attachment.class, PROPERTY_FORM);
    }

    /**
     * A note that describes or explains adjudication results in a human readable form.
     */
    public java.util.List<ExplanationOfBenefitProcessNote> processNote() {
        return getList(ExplanationOfBenefitProcessNote.class, PROPERTY_PROCESSNOTE);
    }

    /**
     * The term of the benefits documented in this response.
     */
    public Period benefitPeriod() {
        return getObject(Period.class, PROPERTY_BENEFITPERIOD);
    }

    /**
     * Balance by Benefit Category.
     */
    public java.util.List<ExplanationOfBenefitBenefitBalance> benefitBalance() {
        return getList(ExplanationOfBenefitBenefitBalance.class, PROPERTY_BENEFITBALANCE);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCETYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICITRULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder type(final CodeableConcept type) {
            b.add(PROPERTY_TYPE, type);
            return this;
        }

        public Builder subType(final CodeableConcept subType) {
            b.add(PROPERTY_SUBTYPE, subType);
            return this;
        }

        public Builder use(final String use) {
            b.add(PROPERTY_USE, use);
            return this;
        }

        public Builder patient(final Reference patient) {
            b.add(PROPERTY_PATIENT, patient);
            return this;
        }

        public Builder billablePeriod(final Period billablePeriod) {
            b.add(PROPERTY_BILLABLEPERIOD, billablePeriod);
            return this;
        }

        public Builder created(final java.time.Instant created) {
            b.add(PROPERTY_CREATED, created.toString());
            return this;
        }

        public Builder enterer(final Reference enterer) {
            b.add(PROPERTY_ENTERER, enterer);
            return this;
        }

        public Builder insurer(final Reference insurer) {
            b.add(PROPERTY_INSURER, insurer);
            return this;
        }

        public Builder provider(final Reference provider) {
            b.add(PROPERTY_PROVIDER, provider);
            return this;
        }

        public Builder priority(final CodeableConcept priority) {
            b.add(PROPERTY_PRIORITY, priority);
            return this;
        }

        public Builder fundsReserveRequested(final CodeableConcept fundsReserveRequested) {
            b.add(PROPERTY_FUNDSRESERVEREQUESTED, fundsReserveRequested);
            return this;
        }

        public Builder fundsReserve(final CodeableConcept fundsReserve) {
            b.add(PROPERTY_FUNDSRESERVE, fundsReserve);
            return this;
        }

        public Builder related(final java.util.List<ExplanationOfBenefitRelated> related) {
            b.add(PROPERTY_RELATED, FhirObject.toArray(related));
            return this;
        }

        public Builder prescription(final Reference prescription) {
            b.add(PROPERTY_PRESCRIPTION, prescription);
            return this;
        }

        public Builder originalPrescription(final Reference originalPrescription) {
            b.add(PROPERTY_ORIGINALPRESCRIPTION, originalPrescription);
            return this;
        }

        public Builder payee(final ExplanationOfBenefitPayee payee) {
            b.add(PROPERTY_PAYEE, payee);
            return this;
        }

        public Builder referral(final Reference referral) {
            b.add(PROPERTY_REFERRAL, referral);
            return this;
        }

        public Builder facility(final Reference facility) {
            b.add(PROPERTY_FACILITY, facility);
            return this;
        }

        public Builder claim(final Reference claim) {
            b.add(PROPERTY_CLAIM, claim);
            return this;
        }

        public Builder claimResponse(final Reference claimResponse) {
            b.add(PROPERTY_CLAIMRESPONSE, claimResponse);
            return this;
        }

        public Builder outcome(final String outcome) {
            b.add(PROPERTY_OUTCOME, outcome);
            return this;
        }

        public Builder disposition(final String disposition) {
            b.add(PROPERTY_DISPOSITION, disposition);
            return this;
        }

        public Builder preAuthRef(final java.util.List<String> preAuthRef) {
            b.add(PROPERTY_PREAUTHREF, FhirObject.toStringArray(preAuthRef));
            return this;
        }

        public Builder preAuthRefPeriod(final java.util.List<Period> preAuthRefPeriod) {
            b.add(PROPERTY_PREAUTHREFPERIOD, FhirObject.toArray(preAuthRefPeriod));
            return this;
        }

        public Builder careTeam(final java.util.List<ExplanationOfBenefitCareTeam> careTeam) {
            b.add(PROPERTY_CARETEAM, FhirObject.toArray(careTeam));
            return this;
        }

        public Builder supportingInfo(final java.util.List<ExplanationOfBenefitSupportingInfo> supportingInfo) {
            b.add(PROPERTY_SUPPORTINGINFO, FhirObject.toArray(supportingInfo));
            return this;
        }

        public Builder diagnosis(final java.util.List<ExplanationOfBenefitDiagnosis> diagnosis) {
            b.add(PROPERTY_DIAGNOSIS, FhirObject.toArray(diagnosis));
            return this;
        }

        public Builder procedure(final java.util.List<ExplanationOfBenefitProcedure> procedure) {
            b.add(PROPERTY_PROCEDURE, FhirObject.toArray(procedure));
            return this;
        }

        public Builder precedence(final Integer precedence) {
            b.add(PROPERTY_PRECEDENCE, precedence);
            return this;
        }

        public Builder insurance(final java.util.List<ExplanationOfBenefitInsurance> insurance) {
            b.add(PROPERTY_INSURANCE, FhirObject.toArray(insurance));
            return this;
        }

        public Builder accident(final ExplanationOfBenefitAccident accident) {
            b.add(PROPERTY_ACCIDENT, accident);
            return this;
        }

        public Builder item(final java.util.List<ExplanationOfBenefitItem> item) {
            b.add(PROPERTY_ITEM, FhirObject.toArray(item));
            return this;
        }

        public Builder addItem(final java.util.List<ExplanationOfBenefitAddItem> addItem) {
            b.add(PROPERTY_ADDITEM, FhirObject.toArray(addItem));
            return this;
        }

        public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
            b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
            return this;
        }

        public Builder total(final java.util.List<ExplanationOfBenefitTotal> total) {
            b.add(PROPERTY_TOTAL, FhirObject.toArray(total));
            return this;
        }

        public Builder payment(final ExplanationOfBenefitPayment payment) {
            b.add(PROPERTY_PAYMENT, payment);
            return this;
        }

        public Builder formCode(final CodeableConcept formCode) {
            b.add(PROPERTY_FORMCODE, formCode);
            return this;
        }

        public Builder form(final Attachment form) {
            b.add(PROPERTY_FORM, form);
            return this;
        }

        public Builder processNote(final java.util.List<ExplanationOfBenefitProcessNote> processNote) {
            b.add(PROPERTY_PROCESSNOTE, FhirObject.toArray(processNote));
            return this;
        }

        public Builder benefitPeriod(final Period benefitPeriod) {
            b.add(PROPERTY_BENEFITPERIOD, benefitPeriod);
            return this;
        }

        public Builder benefitBalance(final java.util.List<ExplanationOfBenefitBenefitBalance> benefitBalance) {
            b.add(PROPERTY_BENEFITBALANCE, FhirObject.toArray(benefitBalance));
            return this;
        }

        public ExplanationOfBenefit build() {
            return new ExplanationOfBenefit(b.build());
        }
    }

    public static class ExplanationOfBenefitAccident extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitAccident";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_DATE = "date";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_LOCATIONADDRESS = "locationAddress";
        public static final String PROPERTY_LOCATIONREFERENCE = "locationReference";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitAccident(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Date of an accident event  related to the products and services contained in the claim.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        /**
         * The type or context of the accident event for the purposes of selection of potential insurance coverages and determination of coordination between insurers.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * The physical location of the accident event.
         */
        public Address locationAddress() {
            return getObject(Address.class, PROPERTY_LOCATIONADDRESS);
        }

        /**
         * The physical location of the accident event.
         */
        public Reference locationReference() {
            return getObject(Reference.class, PROPERTY_LOCATIONREFERENCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder locationAddress(final Address locationAddress) {
                b.add(PROPERTY_LOCATIONADDRESS, locationAddress);
                return this;
            }

            public Builder locationReference(final Reference locationReference) {
                b.add(PROPERTY_LOCATIONREFERENCE, locationReference);
                return this;
            }

            public ExplanationOfBenefitAccident build() {
                return new ExplanationOfBenefitAccident(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitAddItem extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitAddItem";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_ITEMSEQUENCE = "itemSequence";
        public static final String PROPERTY_DETAILSEQUENCE = "detailSequence";
        public static final String PROPERTY_SUBDETAILSEQUENCE = "subDetailSequence";
        public static final String PROPERTY_PROVIDER = "provider";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_PROGRAMCODE = "programCode";
        public static final String PROPERTY_SERVICEDDATE = "servicedDate";
        public static final String PROPERTY_SERVICEDPERIOD = "servicedPeriod";
        public static final String PROPERTY_LOCATIONCODEABLECONCEPT = "locationCodeableConcept";
        public static final String PROPERTY_LOCATIONADDRESS = "locationAddress";
        public static final String PROPERTY_LOCATIONREFERENCE = "locationReference";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_BODYSITE = "bodySite";
        public static final String PROPERTY_SUBSITE = "subSite";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";
        public static final String PROPERTY_DETAIL = "detail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitAddItem(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Claim items which this service line is intended to replace.
         */
        public java.util.List<Integer> itemSequence() {
            return getList(Integer.class, PROPERTY_ITEMSEQUENCE);
        }

        /**
         * The sequence number of the details within the claim item which this line is intended to replace.
         */
        public java.util.List<Integer> detailSequence() {
            return getList(Integer.class, PROPERTY_DETAILSEQUENCE);
        }

        /**
         * The sequence number of the sub-details woithin the details within the claim item which this line is intended to replace.
         */
        public java.util.List<Integer> subDetailSequence() {
            return getList(Integer.class, PROPERTY_SUBDETAILSEQUENCE);
        }

        /**
         * The providers who are authorized for the services rendered to the patient.
         */
        public java.util.List<Reference> provider() {
            return getList(Reference.class, PROPERTY_PROVIDER);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * Identifies the program under which this may be recovered.
         */
        public java.util.List<CodeableConcept> programCode() {
            return getList(CodeableConcept.class, PROPERTY_PROGRAMCODE);
        }

        /**
         * The date or dates when the service or product was supplied, performed or completed.
         */
        public String servicedDate() {
            return getString(PROPERTY_SERVICEDDATE);
        }

        /**
         * The date or dates when the service or product was supplied, performed or completed.
         */
        public Period servicedPeriod() {
            return getObject(Period.class, PROPERTY_SERVICEDPERIOD);
        }

        /**
         * Where the product or service was provided.
         */
        public CodeableConcept locationCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_LOCATIONCODEABLECONCEPT);
        }

        /**
         * Where the product or service was provided.
         */
        public Address locationAddress() {
            return getObject(Address.class, PROPERTY_LOCATIONADDRESS);
        }

        /**
         * Where the product or service was provided.
         */
        public Reference locationReference() {
            return getObject(Reference.class, PROPERTY_LOCATIONREFERENCE);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * Physical service site on the patient (limb, tooth, etc.).
         */
        public CodeableConcept bodySite() {
            return getObject(CodeableConcept.class, PROPERTY_BODYSITE);
        }

        /**
         * A region or surface of the bodySite, e.g. limb region or tooth surface(s).
         */
        public java.util.List<CodeableConcept> subSite() {
            return getList(CodeableConcept.class, PROPERTY_SUBSITE);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * The adjudication results.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        /**
         * The second-tier service adjudications for payor added services.
         */
        public java.util.List<ExplanationOfBenefitDetail1> detail() {
            return getList(ExplanationOfBenefitDetail1.class, PROPERTY_DETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder itemSequence(final java.util.List<Integer> itemSequence) {
                b.add(PROPERTY_ITEMSEQUENCE, FhirObject.toIntegerArray(itemSequence));
                return this;
            }

            public Builder detailSequence(final java.util.List<Integer> detailSequence) {
                b.add(PROPERTY_DETAILSEQUENCE, FhirObject.toIntegerArray(detailSequence));
                return this;
            }

            public Builder subDetailSequence(final java.util.List<Integer> subDetailSequence) {
                b.add(PROPERTY_SUBDETAILSEQUENCE, FhirObject.toIntegerArray(subDetailSequence));
                return this;
            }

            public Builder provider(final java.util.List<Reference> provider) {
                b.add(PROPERTY_PROVIDER, FhirObject.toArray(provider));
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder programCode(final java.util.List<CodeableConcept> programCode) {
                b.add(PROPERTY_PROGRAMCODE, FhirObject.toArray(programCode));
                return this;
            }

            public Builder servicedDate(final String servicedDate) {
                b.add(PROPERTY_SERVICEDDATE, servicedDate);
                return this;
            }

            public Builder servicedPeriod(final Period servicedPeriod) {
                b.add(PROPERTY_SERVICEDPERIOD, servicedPeriod);
                return this;
            }

            public Builder locationCodeableConcept(final CodeableConcept locationCodeableConcept) {
                b.add(PROPERTY_LOCATIONCODEABLECONCEPT, locationCodeableConcept);
                return this;
            }

            public Builder locationAddress(final Address locationAddress) {
                b.add(PROPERTY_LOCATIONADDRESS, locationAddress);
                return this;
            }

            public Builder locationReference(final Reference locationReference) {
                b.add(PROPERTY_LOCATIONREFERENCE, locationReference);
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder bodySite(final CodeableConcept bodySite) {
                b.add(PROPERTY_BODYSITE, bodySite);
                return this;
            }

            public Builder subSite(final java.util.List<CodeableConcept> subSite) {
                b.add(PROPERTY_SUBSITE, FhirObject.toArray(subSite));
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public Builder detail(final java.util.List<ExplanationOfBenefitDetail1> detail) {
                b.add(PROPERTY_DETAIL, FhirObject.toArray(detail));
                return this;
            }

            public ExplanationOfBenefitAddItem build() {
                return new ExplanationOfBenefitAddItem(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitAdjudication extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitAdjudication";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_REASON = "reason";
        public static final String PROPERTY_AMOUNT = "amount";
        public static final String PROPERTY_VALUE = "value";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitAdjudication(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in-aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * A code supporting the understanding of the adjudication result and explaining variance from expected amount.
         */
        public CodeableConcept reason() {
            return getObject(CodeableConcept.class, PROPERTY_REASON);
        }

        /**
         * Monetary amount associated with the category.
         */
        public Money amount() {
            return getObject(Money.class, PROPERTY_AMOUNT);
        }

        /**
         * A non-monetary value associated with the category. Mutually exclusive to the amount element above.
         */
        public Double value() {
            return data.getJsonNumber(PROPERTY_VALUE).doubleValue();
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder reason(final CodeableConcept reason) {
                b.add(PROPERTY_REASON, reason);
                return this;
            }

            public Builder amount(final Money amount) {
                b.add(PROPERTY_AMOUNT, amount);
                return this;
            }

            public Builder value(final Double value) {
                b.add(PROPERTY_VALUE, value);
                return this;
            }

            public ExplanationOfBenefitAdjudication build() {
                return new ExplanationOfBenefitAdjudication(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitBenefitBalance extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitBenefitBalance";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_EXCLUDED = "excluded";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_NETWORK = "network";
        public static final String PROPERTY_UNIT = "unit";
        public static final String PROPERTY_TERM = "term";
        public static final String PROPERTY_FINANCIAL = "financial";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitBenefitBalance(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Code to identify the general type of benefits under which products and services are provided.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * True if the indicated class of service is excluded from the plan, missing or False indicates the product or service is included in the coverage.
         */
        public Boolean excluded() {
            return data.getBoolean(PROPERTY_EXCLUDED);
        }

        /**
         * A short name or tag for the benefit.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * A richer description of the benefit or services covered.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * Is a flag to indicate whether the benefits refer to in-network providers or out-of-network providers.
         */
        public CodeableConcept network() {
            return getObject(CodeableConcept.class, PROPERTY_NETWORK);
        }

        /**
         * Indicates if the benefits apply to an individual or to the family.
         */
        public CodeableConcept unit() {
            return getObject(CodeableConcept.class, PROPERTY_UNIT);
        }

        /**
         * The term or period of the values such as 'maximum lifetime benefit' or 'maximum annual visits'.
         */
        public CodeableConcept term() {
            return getObject(CodeableConcept.class, PROPERTY_TERM);
        }

        /**
         * Benefits Used to date.
         */
        public java.util.List<ExplanationOfBenefitFinancial> financial() {
            return getList(ExplanationOfBenefitFinancial.class, PROPERTY_FINANCIAL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder excluded(final Boolean excluded) {
                b.add(PROPERTY_EXCLUDED, excluded);
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder network(final CodeableConcept network) {
                b.add(PROPERTY_NETWORK, network);
                return this;
            }

            public Builder unit(final CodeableConcept unit) {
                b.add(PROPERTY_UNIT, unit);
                return this;
            }

            public Builder term(final CodeableConcept term) {
                b.add(PROPERTY_TERM, term);
                return this;
            }

            public Builder financial(final java.util.List<ExplanationOfBenefitFinancial> financial) {
                b.add(PROPERTY_FINANCIAL, FhirObject.toArray(financial));
                return this;
            }

            public ExplanationOfBenefitBenefitBalance build() {
                return new ExplanationOfBenefitBenefitBalance(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitCareTeam extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitCareTeam";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_PROVIDER = "provider";
        public static final String PROPERTY_RESPONSIBLE = "responsible";
        public static final String PROPERTY_ROLE = "role";
        public static final String PROPERTY_QUALIFICATION = "qualification";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitCareTeam(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify care team entries.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * Member of the team who provided the product or service.
         */
        public Reference provider() {
            return getObject(Reference.class, PROPERTY_PROVIDER);
        }

        /**
         * The party who is billing and/or responsible for the claimed products or services.
         */
        public Boolean responsible() {
            return data.getBoolean(PROPERTY_RESPONSIBLE);
        }

        /**
         * The lead, assisting or supervising practitioner and their discipline if a multidisciplinary team.
         */
        public CodeableConcept role() {
            return getObject(CodeableConcept.class, PROPERTY_ROLE);
        }

        /**
         * The qualification of the practitioner which is applicable for this service.
         */
        public CodeableConcept qualification() {
            return getObject(CodeableConcept.class, PROPERTY_QUALIFICATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder provider(final Reference provider) {
                b.add(PROPERTY_PROVIDER, provider);
                return this;
            }

            public Builder responsible(final Boolean responsible) {
                b.add(PROPERTY_RESPONSIBLE, responsible);
                return this;
            }

            public Builder role(final CodeableConcept role) {
                b.add(PROPERTY_ROLE, role);
                return this;
            }

            public Builder qualification(final CodeableConcept qualification) {
                b.add(PROPERTY_QUALIFICATION, qualification);
                return this;
            }

            public ExplanationOfBenefitCareTeam build() {
                return new ExplanationOfBenefitCareTeam(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitDetail extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitDetail";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_REVENUE = "revenue";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_PROGRAMCODE = "programCode";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_UDI = "udi";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";
        public static final String PROPERTY_SUBDETAIL = "subDetail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitDetail(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * The type of revenue or cost center providing the product and/or service.
         */
        public CodeableConcept revenue() {
            return getObject(CodeableConcept.class, PROPERTY_REVENUE);
        }

        /**
         * Code to identify the general type of benefits under which products and services are provided.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * Identifies the program under which this may be recovered.
         */
        public java.util.List<CodeableConcept> programCode() {
            return getList(CodeableConcept.class, PROPERTY_PROGRAMCODE);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * Unique Device Identifiers associated with this line item.
         */
        public java.util.List<Reference> udi() {
            return getList(Reference.class, PROPERTY_UDI);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * The adjudication results.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        /**
         * Third-tier of goods and services.
         */
        public java.util.List<ExplanationOfBenefitSubDetail> subDetail() {
            return getList(ExplanationOfBenefitSubDetail.class, PROPERTY_SUBDETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder revenue(final CodeableConcept revenue) {
                b.add(PROPERTY_REVENUE, revenue);
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder programCode(final java.util.List<CodeableConcept> programCode) {
                b.add(PROPERTY_PROGRAMCODE, FhirObject.toArray(programCode));
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder udi(final java.util.List<Reference> udi) {
                b.add(PROPERTY_UDI, FhirObject.toArray(udi));
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public Builder subDetail(final java.util.List<ExplanationOfBenefitSubDetail> subDetail) {
                b.add(PROPERTY_SUBDETAIL, FhirObject.toArray(subDetail));
                return this;
            }

            public ExplanationOfBenefitDetail build() {
                return new ExplanationOfBenefitDetail(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitDetail1 extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitDetail1";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";
        public static final String PROPERTY_SUBDETAIL = "subDetail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitDetail1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * The adjudication results.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        /**
         * The third-tier service adjudications for payor added services.
         */
        public java.util.List<ExplanationOfBenefitSubDetail1> subDetail() {
            return getList(ExplanationOfBenefitSubDetail1.class, PROPERTY_SUBDETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public Builder subDetail(final java.util.List<ExplanationOfBenefitSubDetail1> subDetail) {
                b.add(PROPERTY_SUBDETAIL, FhirObject.toArray(subDetail));
                return this;
            }

            public ExplanationOfBenefitDetail1 build() {
                return new ExplanationOfBenefitDetail1(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitDiagnosis extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitDiagnosis";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_DIAGNOSISCODEABLECONCEPT = "diagnosisCodeableConcept";
        public static final String PROPERTY_DIAGNOSISREFERENCE = "diagnosisReference";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_ONADMISSION = "onAdmission";
        public static final String PROPERTY_PACKAGECODE = "packageCode";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitDiagnosis(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify diagnosis entries.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * The nature of illness or problem in a coded form or as a reference to an external defined Condition.
         */
        public CodeableConcept diagnosisCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_DIAGNOSISCODEABLECONCEPT);
        }

        /**
         * The nature of illness or problem in a coded form or as a reference to an external defined Condition.
         */
        public Reference diagnosisReference() {
            return getObject(Reference.class, PROPERTY_DIAGNOSISREFERENCE);
        }

        /**
         * When the condition was observed or the relative ranking.
         */
        public java.util.List<CodeableConcept> type() {
            return getList(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Indication of whether the diagnosis was present on admission to a facility.
         */
        public CodeableConcept onAdmission() {
            return getObject(CodeableConcept.class, PROPERTY_ONADMISSION);
        }

        /**
         * A package billing code or bundle code used to group products and services to a particular health condition (such as heart attack) which is based on a predetermined grouping code system.
         */
        public CodeableConcept packageCode() {
            return getObject(CodeableConcept.class, PROPERTY_PACKAGECODE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder diagnosisCodeableConcept(final CodeableConcept diagnosisCodeableConcept) {
                b.add(PROPERTY_DIAGNOSISCODEABLECONCEPT, diagnosisCodeableConcept);
                return this;
            }

            public Builder diagnosisReference(final Reference diagnosisReference) {
                b.add(PROPERTY_DIAGNOSISREFERENCE, diagnosisReference);
                return this;
            }

            public Builder type(final java.util.List<CodeableConcept> type) {
                b.add(PROPERTY_TYPE, FhirObject.toArray(type));
                return this;
            }

            public Builder onAdmission(final CodeableConcept onAdmission) {
                b.add(PROPERTY_ONADMISSION, onAdmission);
                return this;
            }

            public Builder packageCode(final CodeableConcept packageCode) {
                b.add(PROPERTY_PACKAGECODE, packageCode);
                return this;
            }

            public ExplanationOfBenefitDiagnosis build() {
                return new ExplanationOfBenefitDiagnosis(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitFinancial extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitFinancial";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_ALLOWEDUNSIGNEDINT = "allowedUnsignedInt";
        public static final String PROPERTY_ALLOWEDSTRING = "allowedString";
        public static final String PROPERTY_ALLOWEDMONEY = "allowedMoney";
        public static final String PROPERTY_USEDUNSIGNEDINT = "usedUnsignedInt";
        public static final String PROPERTY_USEDMONEY = "usedMoney";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitFinancial(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Classification of benefit being provided.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * The quantity of the benefit which is permitted under the coverage.
         */
        public Integer allowedUnsignedInt() {
            return data.getInt(PROPERTY_ALLOWEDUNSIGNEDINT);
        }

        /**
         * The quantity of the benefit which is permitted under the coverage.
         */
        public String allowedString() {
            return getString(PROPERTY_ALLOWEDSTRING);
        }

        /**
         * The quantity of the benefit which is permitted under the coverage.
         */
        public Money allowedMoney() {
            return getObject(Money.class, PROPERTY_ALLOWEDMONEY);
        }

        /**
         * The quantity of the benefit which have been consumed to date.
         */
        public Integer usedUnsignedInt() {
            return data.getInt(PROPERTY_USEDUNSIGNEDINT);
        }

        /**
         * The quantity of the benefit which have been consumed to date.
         */
        public Money usedMoney() {
            return getObject(Money.class, PROPERTY_USEDMONEY);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder allowedUnsignedInt(final Integer allowedUnsignedInt) {
                b.add(PROPERTY_ALLOWEDUNSIGNEDINT, allowedUnsignedInt);
                return this;
            }

            public Builder allowedString(final String allowedString) {
                b.add(PROPERTY_ALLOWEDSTRING, allowedString);
                return this;
            }

            public Builder allowedMoney(final Money allowedMoney) {
                b.add(PROPERTY_ALLOWEDMONEY, allowedMoney);
                return this;
            }

            public Builder usedUnsignedInt(final Integer usedUnsignedInt) {
                b.add(PROPERTY_USEDUNSIGNEDINT, usedUnsignedInt);
                return this;
            }

            public Builder usedMoney(final Money usedMoney) {
                b.add(PROPERTY_USEDMONEY, usedMoney);
                return this;
            }

            public ExplanationOfBenefitFinancial build() {
                return new ExplanationOfBenefitFinancial(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitInsurance extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitInsurance";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_FOCAL = "focal";
        public static final String PROPERTY_COVERAGE = "coverage";
        public static final String PROPERTY_PREAUTHREF = "preAuthRef";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitInsurance(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A flag to indicate that this Coverage is to be used for adjudication of this claim when set to true.
         */
        public Boolean focal() {
            return data.getBoolean(PROPERTY_FOCAL);
        }

        /**
         * Reference to the insurance card level information contained in the Coverage resource. The coverage issuing insurer will use these details to locate the patient's actual coverage within the insurer's information system.
         */
        public Reference coverage() {
            return getObject(Reference.class, PROPERTY_COVERAGE);
        }

        /**
         * Reference numbers previously provided by the insurer to the provider to be quoted on subsequent claims containing services or products related to the prior authorization.
         */
        public java.util.List<String> preAuthRef() {
            return getList(String.class, PROPERTY_PREAUTHREF);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder focal(final Boolean focal) {
                b.add(PROPERTY_FOCAL, focal);
                return this;
            }

            public Builder coverage(final Reference coverage) {
                b.add(PROPERTY_COVERAGE, coverage);
                return this;
            }

            public Builder preAuthRef(final java.util.List<String> preAuthRef) {
                b.add(PROPERTY_PREAUTHREF, FhirObject.toStringArray(preAuthRef));
                return this;
            }

            public ExplanationOfBenefitInsurance build() {
                return new ExplanationOfBenefitInsurance(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitItem extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitItem";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_CARETEAMSEQUENCE = "careTeamSequence";
        public static final String PROPERTY_DIAGNOSISSEQUENCE = "diagnosisSequence";
        public static final String PROPERTY_PROCEDURESEQUENCE = "procedureSequence";
        public static final String PROPERTY_INFORMATIONSEQUENCE = "informationSequence";
        public static final String PROPERTY_REVENUE = "revenue";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_PROGRAMCODE = "programCode";
        public static final String PROPERTY_SERVICEDDATE = "servicedDate";
        public static final String PROPERTY_SERVICEDPERIOD = "servicedPeriod";
        public static final String PROPERTY_LOCATIONCODEABLECONCEPT = "locationCodeableConcept";
        public static final String PROPERTY_LOCATIONADDRESS = "locationAddress";
        public static final String PROPERTY_LOCATIONREFERENCE = "locationReference";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_UDI = "udi";
        public static final String PROPERTY_BODYSITE = "bodySite";
        public static final String PROPERTY_SUBSITE = "subSite";
        public static final String PROPERTY_ENCOUNTER = "encounter";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";
        public static final String PROPERTY_DETAIL = "detail";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitItem(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify item entries.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * Care team members related to this service or product.
         */
        public java.util.List<Integer> careTeamSequence() {
            return getList(Integer.class, PROPERTY_CARETEAMSEQUENCE);
        }

        /**
         * Diagnoses applicable for this service or product.
         */
        public java.util.List<Integer> diagnosisSequence() {
            return getList(Integer.class, PROPERTY_DIAGNOSISSEQUENCE);
        }

        /**
         * Procedures applicable for this service or product.
         */
        public java.util.List<Integer> procedureSequence() {
            return getList(Integer.class, PROPERTY_PROCEDURESEQUENCE);
        }

        /**
         * Exceptions, special conditions and supporting information applicable for this service or product.
         */
        public java.util.List<Integer> informationSequence() {
            return getList(Integer.class, PROPERTY_INFORMATIONSEQUENCE);
        }

        /**
         * The type of revenue or cost center providing the product and/or service.
         */
        public CodeableConcept revenue() {
            return getObject(CodeableConcept.class, PROPERTY_REVENUE);
        }

        /**
         * Code to identify the general type of benefits under which products and services are provided.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * Identifies the program under which this may be recovered.
         */
        public java.util.List<CodeableConcept> programCode() {
            return getList(CodeableConcept.class, PROPERTY_PROGRAMCODE);
        }

        /**
         * The date or dates when the service or product was supplied, performed or completed.
         */
        public String servicedDate() {
            return getString(PROPERTY_SERVICEDDATE);
        }

        /**
         * The date or dates when the service or product was supplied, performed or completed.
         */
        public Period servicedPeriod() {
            return getObject(Period.class, PROPERTY_SERVICEDPERIOD);
        }

        /**
         * Where the product or service was provided.
         */
        public CodeableConcept locationCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_LOCATIONCODEABLECONCEPT);
        }

        /**
         * Where the product or service was provided.
         */
        public Address locationAddress() {
            return getObject(Address.class, PROPERTY_LOCATIONADDRESS);
        }

        /**
         * Where the product or service was provided.
         */
        public Reference locationReference() {
            return getObject(Reference.class, PROPERTY_LOCATIONREFERENCE);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * Unique Device Identifiers associated with this line item.
         */
        public java.util.List<Reference> udi() {
            return getList(Reference.class, PROPERTY_UDI);
        }

        /**
         * Physical service site on the patient (limb, tooth, etc.).
         */
        public CodeableConcept bodySite() {
            return getObject(CodeableConcept.class, PROPERTY_BODYSITE);
        }

        /**
         * A region or surface of the bodySite, e.g. limb region or tooth surface(s).
         */
        public java.util.List<CodeableConcept> subSite() {
            return getList(CodeableConcept.class, PROPERTY_SUBSITE);
        }

        /**
         * A billed item may include goods or services provided in multiple encounters.
         */
        public java.util.List<Reference> encounter() {
            return getList(Reference.class, PROPERTY_ENCOUNTER);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * If this item is a group then the values here are a summary of the adjudication of the detail items. If this item is a simple product or service then this is the result of the adjudication of this item.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        /**
         * Second-tier of goods and services.
         */
        public java.util.List<ExplanationOfBenefitDetail> detail() {
            return getList(ExplanationOfBenefitDetail.class, PROPERTY_DETAIL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder careTeamSequence(final java.util.List<Integer> careTeamSequence) {
                b.add(PROPERTY_CARETEAMSEQUENCE, FhirObject.toIntegerArray(careTeamSequence));
                return this;
            }

            public Builder diagnosisSequence(final java.util.List<Integer> diagnosisSequence) {
                b.add(PROPERTY_DIAGNOSISSEQUENCE, FhirObject.toIntegerArray(diagnosisSequence));
                return this;
            }

            public Builder procedureSequence(final java.util.List<Integer> procedureSequence) {
                b.add(PROPERTY_PROCEDURESEQUENCE, FhirObject.toIntegerArray(procedureSequence));
                return this;
            }

            public Builder informationSequence(final java.util.List<Integer> informationSequence) {
                b.add(PROPERTY_INFORMATIONSEQUENCE, FhirObject.toIntegerArray(informationSequence));
                return this;
            }

            public Builder revenue(final CodeableConcept revenue) {
                b.add(PROPERTY_REVENUE, revenue);
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder programCode(final java.util.List<CodeableConcept> programCode) {
                b.add(PROPERTY_PROGRAMCODE, FhirObject.toArray(programCode));
                return this;
            }

            public Builder servicedDate(final String servicedDate) {
                b.add(PROPERTY_SERVICEDDATE, servicedDate);
                return this;
            }

            public Builder servicedPeriod(final Period servicedPeriod) {
                b.add(PROPERTY_SERVICEDPERIOD, servicedPeriod);
                return this;
            }

            public Builder locationCodeableConcept(final CodeableConcept locationCodeableConcept) {
                b.add(PROPERTY_LOCATIONCODEABLECONCEPT, locationCodeableConcept);
                return this;
            }

            public Builder locationAddress(final Address locationAddress) {
                b.add(PROPERTY_LOCATIONADDRESS, locationAddress);
                return this;
            }

            public Builder locationReference(final Reference locationReference) {
                b.add(PROPERTY_LOCATIONREFERENCE, locationReference);
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder udi(final java.util.List<Reference> udi) {
                b.add(PROPERTY_UDI, FhirObject.toArray(udi));
                return this;
            }

            public Builder bodySite(final CodeableConcept bodySite) {
                b.add(PROPERTY_BODYSITE, bodySite);
                return this;
            }

            public Builder subSite(final java.util.List<CodeableConcept> subSite) {
                b.add(PROPERTY_SUBSITE, FhirObject.toArray(subSite));
                return this;
            }

            public Builder encounter(final java.util.List<Reference> encounter) {
                b.add(PROPERTY_ENCOUNTER, FhirObject.toArray(encounter));
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public Builder detail(final java.util.List<ExplanationOfBenefitDetail> detail) {
                b.add(PROPERTY_DETAIL, FhirObject.toArray(detail));
                return this;
            }

            public ExplanationOfBenefitItem build() {
                return new ExplanationOfBenefitItem(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitPayee extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitPayee";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_PARTY = "party";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitPayee(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Type of Party to be reimbursed: Subscriber, provider, other.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Reference to the individual or organization to whom any payment will be made.
         */
        public Reference party() {
            return getObject(Reference.class, PROPERTY_PARTY);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder party(final Reference party) {
                b.add(PROPERTY_PARTY, party);
                return this;
            }

            public ExplanationOfBenefitPayee build() {
                return new ExplanationOfBenefitPayee(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitPayment extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitPayment";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_ADJUSTMENT = "adjustment";
        public static final String PROPERTY_ADJUSTMENTREASON = "adjustmentReason";
        public static final String PROPERTY_DATE = "date";
        public static final String PROPERTY_AMOUNT = "amount";
        public static final String PROPERTY_IDENTIFIER = "identifier";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitPayment(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Whether this represents partial or complete payment of the benefits payable.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Total amount of all adjustments to this payment included in this transaction which are not related to this claim's adjudication.
         */
        public Money adjustment() {
            return getObject(Money.class, PROPERTY_ADJUSTMENT);
        }

        /**
         * Reason for the payment adjustment.
         */
        public CodeableConcept adjustmentReason() {
            return getObject(CodeableConcept.class, PROPERTY_ADJUSTMENTREASON);
        }

        /**
         * Estimated date the payment will be issued or the actual issue date of payment.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        /**
         * Benefits payable less any payment adjustment.
         */
        public Money amount() {
            return getObject(Money.class, PROPERTY_AMOUNT);
        }

        /**
         * Issuer's unique identifier for the payment instrument.
         */
        public Identifier identifier() {
            return getObject(Identifier.class, PROPERTY_IDENTIFIER);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder adjustment(final Money adjustment) {
                b.add(PROPERTY_ADJUSTMENT, adjustment);
                return this;
            }

            public Builder adjustmentReason(final CodeableConcept adjustmentReason) {
                b.add(PROPERTY_ADJUSTMENTREASON, adjustmentReason);
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public Builder amount(final Money amount) {
                b.add(PROPERTY_AMOUNT, amount);
                return this;
            }

            public Builder identifier(final Identifier identifier) {
                b.add(PROPERTY_IDENTIFIER, identifier);
                return this;
            }

            public ExplanationOfBenefitPayment build() {
                return new ExplanationOfBenefitPayment(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitProcedure extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitProcedure";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_DATE = "date";
        public static final String PROPERTY_PROCEDURECODEABLECONCEPT = "procedureCodeableConcept";
        public static final String PROPERTY_PROCEDUREREFERENCE = "procedureReference";
        public static final String PROPERTY_UDI = "udi";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitProcedure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify procedure entries.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * When the condition was observed or the relative ranking.
         */
        public java.util.List<CodeableConcept> type() {
            return getList(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Date and optionally time the procedure was performed.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        /**
         * The code or reference to a Procedure resource which identifies the clinical intervention performed.
         */
        public CodeableConcept procedureCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_PROCEDURECODEABLECONCEPT);
        }

        /**
         * The code or reference to a Procedure resource which identifies the clinical intervention performed.
         */
        public Reference procedureReference() {
            return getObject(Reference.class, PROPERTY_PROCEDUREREFERENCE);
        }

        /**
         * Unique Device Identifiers associated with this line item.
         */
        public java.util.List<Reference> udi() {
            return getList(Reference.class, PROPERTY_UDI);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder type(final java.util.List<CodeableConcept> type) {
                b.add(PROPERTY_TYPE, FhirObject.toArray(type));
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public Builder procedureCodeableConcept(final CodeableConcept procedureCodeableConcept) {
                b.add(PROPERTY_PROCEDURECODEABLECONCEPT, procedureCodeableConcept);
                return this;
            }

            public Builder procedureReference(final Reference procedureReference) {
                b.add(PROPERTY_PROCEDUREREFERENCE, procedureReference);
                return this;
            }

            public Builder udi(final java.util.List<Reference> udi) {
                b.add(PROPERTY_UDI, FhirObject.toArray(udi));
                return this;
            }

            public ExplanationOfBenefitProcedure build() {
                return new ExplanationOfBenefitProcedure(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitProcessNote extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitProcessNote";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_NUMBER = "number";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_TEXT = "text";
        public static final String PROPERTY_LANGUAGE = "language";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitProcessNote(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify a note entry.
         */
        public Integer number() {
            return data.getInt(PROPERTY_NUMBER);
        }

        /**
         * The business purpose of the note text.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        /**
         * The explanation or description associated with the processing.
         */
        public String text() {
            return getString(PROPERTY_TEXT);
        }

        /**
         * A code to define the language used in the text of the note.
         */
        public CodeableConcept language() {
            return getObject(CodeableConcept.class, PROPERTY_LANGUAGE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder number(final Integer number) {
                b.add(PROPERTY_NUMBER, number);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder text(final String text) {
                b.add(PROPERTY_TEXT, text);
                return this;
            }

            public Builder language(final CodeableConcept language) {
                b.add(PROPERTY_LANGUAGE, language);
                return this;
            }

            public ExplanationOfBenefitProcessNote build() {
                return new ExplanationOfBenefitProcessNote(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitRelated extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitRelated";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_CLAIM = "claim";
        public static final String PROPERTY_RELATIONSHIP = "relationship";
        public static final String PROPERTY_REFERENCE = "reference";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitRelated(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Reference to a related claim.
         */
        public Reference claim() {
            return getObject(Reference.class, PROPERTY_CLAIM);
        }

        /**
         * A code to convey how the claims are related.
         */
        public CodeableConcept relationship() {
            return getObject(CodeableConcept.class, PROPERTY_RELATIONSHIP);
        }

        /**
         * An alternate organizational reference to the case or file to which this particular claim pertains.
         */
        public Identifier reference() {
            return getObject(Identifier.class, PROPERTY_REFERENCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder claim(final Reference claim) {
                b.add(PROPERTY_CLAIM, claim);
                return this;
            }

            public Builder relationship(final CodeableConcept relationship) {
                b.add(PROPERTY_RELATIONSHIP, relationship);
                return this;
            }

            public Builder reference(final Identifier reference) {
                b.add(PROPERTY_REFERENCE, reference);
                return this;
            }

            public ExplanationOfBenefitRelated build() {
                return new ExplanationOfBenefitRelated(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitSubDetail extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitSubDetail";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_REVENUE = "revenue";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_PROGRAMCODE = "programCode";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_UDI = "udi";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitSubDetail(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A claim detail line. Either a simple (a product or service) or a 'group' of sub-details which are simple items.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * The type of revenue or cost center providing the product and/or service.
         */
        public CodeableConcept revenue() {
            return getObject(CodeableConcept.class, PROPERTY_REVENUE);
        }

        /**
         * Code to identify the general type of benefits under which products and services are provided.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * Identifies the program under which this may be recovered.
         */
        public java.util.List<CodeableConcept> programCode() {
            return getList(CodeableConcept.class, PROPERTY_PROGRAMCODE);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * Unique Device Identifiers associated with this line item.
         */
        public java.util.List<Reference> udi() {
            return getList(Reference.class, PROPERTY_UDI);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * The adjudication results.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder revenue(final CodeableConcept revenue) {
                b.add(PROPERTY_REVENUE, revenue);
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder programCode(final java.util.List<CodeableConcept> programCode) {
                b.add(PROPERTY_PROGRAMCODE, FhirObject.toArray(programCode));
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder udi(final java.util.List<Reference> udi) {
                b.add(PROPERTY_UDI, FhirObject.toArray(udi));
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public ExplanationOfBenefitSubDetail build() {
                return new ExplanationOfBenefitSubDetail(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitSubDetail1 extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitSubDetail1";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_PRODUCTORSERVICE = "productOrService";
        public static final String PROPERTY_MODIFIER = "modifier";
        public static final String PROPERTY_QUANTITY = "quantity";
        public static final String PROPERTY_UNITPRICE = "unitPrice";
        public static final String PROPERTY_FACTOR = "factor";
        public static final String PROPERTY_NET = "net";
        public static final String PROPERTY_NOTENUMBER = "noteNumber";
        public static final String PROPERTY_ADJUDICATION = "adjudication";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitSubDetail1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * When the value is a group code then this item collects a set of related claim details, otherwise this contains the product, service, drug or other billing code for the item.
         */
        public CodeableConcept productOrService() {
            return getObject(CodeableConcept.class, PROPERTY_PRODUCTORSERVICE);
        }

        /**
         * Item typification or modifiers codes to convey additional context for the product or service.
         */
        public java.util.List<CodeableConcept> modifier() {
            return getList(CodeableConcept.class, PROPERTY_MODIFIER);
        }

        /**
         * The number of repetitions of a service or product.
         */
        public Quantity quantity() {
            return getObject(Quantity.class, PROPERTY_QUANTITY);
        }

        /**
         * If the item is not a group then this is the fee for the product or service, otherwise this is the total of the fees for the details of the group.
         */
        public Money unitPrice() {
            return getObject(Money.class, PROPERTY_UNITPRICE);
        }

        /**
         * A real number that represents a multiplier used in determining the overall value of services delivered and/or goods received. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
         */
        public Double factor() {
            return data.getJsonNumber(PROPERTY_FACTOR).doubleValue();
        }

        /**
         * The quantity times the unit price for an additional service or product or charge.
         */
        public Money net() {
            return getObject(Money.class, PROPERTY_NET);
        }

        /**
         * The numbers associated with notes below which apply to the adjudication of this item.
         */
        public java.util.List<Integer> noteNumber() {
            return getList(Integer.class, PROPERTY_NOTENUMBER);
        }

        /**
         * The adjudication results.
         */
        public java.util.List<ExplanationOfBenefitAdjudication> adjudication() {
            return getList(ExplanationOfBenefitAdjudication.class, PROPERTY_ADJUDICATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder productOrService(final CodeableConcept productOrService) {
                b.add(PROPERTY_PRODUCTORSERVICE, productOrService);
                return this;
            }

            public Builder modifier(final java.util.List<CodeableConcept> modifier) {
                b.add(PROPERTY_MODIFIER, FhirObject.toArray(modifier));
                return this;
            }

            public Builder quantity(final Quantity quantity) {
                b.add(PROPERTY_QUANTITY, quantity);
                return this;
            }

            public Builder unitPrice(final Money unitPrice) {
                b.add(PROPERTY_UNITPRICE, unitPrice);
                return this;
            }

            public Builder factor(final Double factor) {
                b.add(PROPERTY_FACTOR, factor);
                return this;
            }

            public Builder net(final Money net) {
                b.add(PROPERTY_NET, net);
                return this;
            }

            public Builder noteNumber(final java.util.List<Integer> noteNumber) {
                b.add(PROPERTY_NOTENUMBER, FhirObject.toIntegerArray(noteNumber));
                return this;
            }

            public Builder adjudication(final java.util.List<ExplanationOfBenefitAdjudication> adjudication) {
                b.add(PROPERTY_ADJUDICATION, FhirObject.toArray(adjudication));
                return this;
            }

            public ExplanationOfBenefitSubDetail1 build() {
                return new ExplanationOfBenefitSubDetail1(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitSupportingInfo extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitSupportingInfo";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SEQUENCE = "sequence";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_TIMINGDATE = "timingDate";
        public static final String PROPERTY_TIMINGPERIOD = "timingPeriod";
        public static final String PROPERTY_VALUEBOOLEAN = "valueBoolean";
        public static final String PROPERTY_VALUESTRING = "valueString";
        public static final String PROPERTY_VALUEQUANTITY = "valueQuantity";
        public static final String PROPERTY_VALUEATTACHMENT = "valueAttachment";
        public static final String PROPERTY_VALUEREFERENCE = "valueReference";
        public static final String PROPERTY_REASON = "reason";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitSupportingInfo(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A number to uniquely identify supporting information entries.
         */
        public Integer sequence() {
            return data.getInt(PROPERTY_SEQUENCE);
        }

        /**
         * The general class of the information supplied: information; exception; accident, employment; onset, etc.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * System and code pertaining to the specific information regarding special conditions relating to the setting, treatment or patient  for which care is sought.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, PROPERTY_CODE);
        }

        /**
         * The date when or period to which this information refers.
         */
        public String timingDate() {
            return getString(PROPERTY_TIMINGDATE);
        }

        /**
         * The date when or period to which this information refers.
         */
        public Period timingPeriod() {
            return getObject(Period.class, PROPERTY_TIMINGPERIOD);
        }

        /**
         * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(PROPERTY_VALUEBOOLEAN);
        }

        /**
         * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
         */
        public String valueString() {
            return getString(PROPERTY_VALUESTRING);
        }

        /**
         * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
         */
        public Quantity valueQuantity() {
            return getObject(Quantity.class, PROPERTY_VALUEQUANTITY);
        }

        /**
         * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
         */
        public Attachment valueAttachment() {
            return getObject(Attachment.class, PROPERTY_VALUEATTACHMENT);
        }

        /**
         * Additional data or information such as resources, documents, images etc. including references to the data or the actual inclusion of the data.
         */
        public Reference valueReference() {
            return getObject(Reference.class, PROPERTY_VALUEREFERENCE);
        }

        /**
         * Provides the reason in the situation where a reason code is required in addition to the content.
         */
        public Coding reason() {
            return getObject(Coding.class, PROPERTY_REASON);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder sequence(final Integer sequence) {
                b.add(PROPERTY_SEQUENCE, sequence);
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder timingDate(final String timingDate) {
                b.add(PROPERTY_TIMINGDATE, timingDate);
                return this;
            }

            public Builder timingPeriod(final Period timingPeriod) {
                b.add(PROPERTY_TIMINGPERIOD, timingPeriod);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(PROPERTY_VALUEBOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(PROPERTY_VALUESTRING, valueString);
                return this;
            }

            public Builder valueQuantity(final Quantity valueQuantity) {
                b.add(PROPERTY_VALUEQUANTITY, valueQuantity);
                return this;
            }

            public Builder valueAttachment(final Attachment valueAttachment) {
                b.add(PROPERTY_VALUEATTACHMENT, valueAttachment);
                return this;
            }

            public Builder valueReference(final Reference valueReference) {
                b.add(PROPERTY_VALUEREFERENCE, valueReference);
                return this;
            }

            public Builder reason(final Coding reason) {
                b.add(PROPERTY_REASON, reason);
                return this;
            }

            public ExplanationOfBenefitSupportingInfo build() {
                return new ExplanationOfBenefitSupportingInfo(b.build());
            }
        }
    }

    public static class ExplanationOfBenefitTotal extends FhirObject {
        public static final String RESOURCE_TYPE = "ExplanationOfBenefitTotal";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_AMOUNT = "amount";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ExplanationOfBenefitTotal(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * A code to indicate the information type of this adjudication record. Information types may include: the value submitted, maximum values or percentages allowed or payable under the plan, amounts that the patient is responsible for in aggregate or pertaining to this item, amounts paid by other coverages, and the benefit payable for this item.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * Monetary total amount associated with the category.
         */
        public Money amount() {
            return getObject(Money.class, PROPERTY_AMOUNT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder amount(final Money amount) {
                b.add(PROPERTY_AMOUNT, amount);
                return this;
            }

            public ExplanationOfBenefitTotal build() {
                return new ExplanationOfBenefitTotal(b.build());
            }
        }
    }
}
