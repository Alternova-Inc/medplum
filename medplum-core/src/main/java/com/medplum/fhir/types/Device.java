/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

/**
 * A type of a manufactured item that is used in the provision of
 * healthcare without being substantially changed through that activity.
 * The device may be a medical or non-medical device.
 */
public class Device extends FhirResource {
    public static final String RESOURCE_TYPE = "Device";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_EXTENSION = "extension";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_DEFINITION = "definition";
    public static final String PROPERTY_UDI_CARRIER = "udiCarrier";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_STATUS_REASON = "statusReason";
    public static final String PROPERTY_DISTINCT_IDENTIFIER = "distinctIdentifier";
    public static final String PROPERTY_MANUFACTURER = "manufacturer";
    public static final String PROPERTY_MANUFACTURE_DATE = "manufactureDate";
    public static final String PROPERTY_EXPIRATION_DATE = "expirationDate";
    public static final String PROPERTY_LOT_NUMBER = "lotNumber";
    public static final String PROPERTY_SERIAL_NUMBER = "serialNumber";
    public static final String PROPERTY_DEVICE_NAME = "deviceName";
    public static final String PROPERTY_MODEL_NUMBER = "modelNumber";
    public static final String PROPERTY_PART_NUMBER = "partNumber";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_SPECIALIZATION = "specialization";
    public static final String PROPERTY_VERSION = "version";
    public static final String PROPERTY_PROPERTY = "property";
    public static final String PROPERTY_PATIENT = "patient";
    public static final String PROPERTY_OWNER = "owner";
    public static final String PROPERTY_CONTACT = "contact";
    public static final String PROPERTY_LOCATION = "location";
    public static final String PROPERTY_URL = "url";
    public static final String PROPERTY_NOTE = "note";
    public static final String PROPERTY_SAFETY = "safety";
    public static final String PROPERTY_PARENT = "parent";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Device(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public java.net.URI implicitRules() {
        return getUri(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Unique instance identifiers assigned to a device by manufacturers
     * other organizations or owners.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * The reference to the definition for the device.
     */
    public Reference definition() {
        return getObject(Reference.class, PROPERTY_DEFINITION);
    }

    /**
     * Unique device identifier (UDI) assigned to device label or package.
     * Note that the Device may include multiple udiCarriers as it either may
     * include just the udiCarrier for the jurisdiction it is sold, or for
     * multiple jurisdictions it could have been sold.
     */
    public java.util.List<DeviceUdiCarrier> udiCarrier() {
        return getList(DeviceUdiCarrier.class, PROPERTY_UDI_CARRIER);
    }

    /**
     * Status of the Device availability.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * Reason for the dtatus of the Device availability.
     */
    public java.util.List<CodeableConcept> statusReason() {
        return getList(CodeableConcept.class, PROPERTY_STATUS_REASON);
    }

    /**
     * The distinct identification string as required by regulation for a
     * human cell, tissue, or cellular and tissue-based product.
     */
    public String distinctIdentifier() {
        return getString(PROPERTY_DISTINCT_IDENTIFIER);
    }

    /**
     * A name of the manufacturer.
     */
    public String manufacturer() {
        return getString(PROPERTY_MANUFACTURER);
    }

    /**
     * The date and time when the device was manufactured.
     */
    public java.time.Instant manufactureDate() {
        return getInstant(PROPERTY_MANUFACTURE_DATE);
    }

    /**
     * The date and time beyond which this device is no longer valid or
     * should not be used (if applicable).
     */
    public java.time.Instant expirationDate() {
        return getInstant(PROPERTY_EXPIRATION_DATE);
    }

    /**
     * Lot number assigned by the manufacturer.
     */
    public String lotNumber() {
        return getString(PROPERTY_LOT_NUMBER);
    }

    /**
     * The serial number assigned by the organization when the device was
     * manufactured.
     */
    public String serialNumber() {
        return getString(PROPERTY_SERIAL_NUMBER);
    }

    /**
     * This represents the manufacturer's name of the device as provided by
     * the device, from a UDI label, or by a person describing the Device.
     * This typically would be used when a person provides the name(s) or
     * when the device represents one of the names available from
     * DeviceDefinition.
     */
    public java.util.List<DeviceDeviceName> deviceName() {
        return getList(DeviceDeviceName.class, PROPERTY_DEVICE_NAME);
    }

    /**
     * The model number for the device.
     */
    public String modelNumber() {
        return getString(PROPERTY_MODEL_NUMBER);
    }

    /**
     * The part number of the device.
     */
    public String partNumber() {
        return getString(PROPERTY_PART_NUMBER);
    }

    /**
     * The kind or type of device.
     */
    public CodeableConcept type() {
        return getObject(CodeableConcept.class, PROPERTY_TYPE);
    }

    /**
     * The capabilities supported on a  device, the standards to which the
     * device conforms for a particular purpose, and used for the
     * communication.
     */
    public java.util.List<DeviceSpecialization> specialization() {
        return getList(DeviceSpecialization.class, PROPERTY_SPECIALIZATION);
    }

    /**
     * The actual design of the device or software version running on the
     * device.
     */
    public java.util.List<DeviceVersion> version() {
        return getList(DeviceVersion.class, PROPERTY_VERSION);
    }

    /**
     * The actual configuration settings of a device as it actually operates,
     * e.g., regulation status, time properties.
     */
    public java.util.List<DeviceProperty> property() {
        return getList(DeviceProperty.class, PROPERTY_PROPERTY);
    }

    /**
     * Patient information, If the device is affixed to a person.
     */
    public Reference patient() {
        return getObject(Reference.class, PROPERTY_PATIENT);
    }

    /**
     * An organization that is responsible for the provision and ongoing
     * maintenance of the device.
     */
    public Reference owner() {
        return getObject(Reference.class, PROPERTY_OWNER);
    }

    /**
     * Contact details for an organization or a particular human that is
     * responsible for the device.
     */
    public java.util.List<ContactPoint> contact() {
        return getList(ContactPoint.class, PROPERTY_CONTACT);
    }

    /**
     * The place where the device can be found.
     */
    public Reference location() {
        return getObject(Reference.class, PROPERTY_LOCATION);
    }

    /**
     * A network address on which the device may be contacted directly.
     */
    public java.net.URI url() {
        return getUri(PROPERTY_URL);
    }

    /**
     * Descriptive information, usage information or implantation information
     * that is not captured in an existing element.
     */
    public java.util.List<Annotation> note() {
        return getList(Annotation.class, PROPERTY_NOTE);
    }

    /**
     * Provides additional safety characteristics about a medical device.
     * For example devices containing latex.
     */
    public java.util.List<CodeableConcept> safety() {
        return getList(CodeableConcept.class, PROPERTY_SAFETY);
    }

    /**
     * The parent device.
     */
    public Reference parent() {
        return getObject(Reference.class, PROPERTY_PARENT);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final java.net.URI implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules.toString());
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder definition(final Reference definition) {
            b.add(PROPERTY_DEFINITION, definition);
            return this;
        }

        public Builder udiCarrier(final java.util.List<DeviceUdiCarrier> udiCarrier) {
            b.add(PROPERTY_UDI_CARRIER, FhirObject.toArray(udiCarrier));
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder statusReason(final java.util.List<CodeableConcept> statusReason) {
            b.add(PROPERTY_STATUS_REASON, FhirObject.toArray(statusReason));
            return this;
        }

        public Builder distinctIdentifier(final String distinctIdentifier) {
            b.add(PROPERTY_DISTINCT_IDENTIFIER, distinctIdentifier);
            return this;
        }

        public Builder manufacturer(final String manufacturer) {
            b.add(PROPERTY_MANUFACTURER, manufacturer);
            return this;
        }

        public Builder manufactureDate(final java.time.Instant manufactureDate) {
            b.add(PROPERTY_MANUFACTURE_DATE, manufactureDate.toString());
            return this;
        }

        public Builder expirationDate(final java.time.Instant expirationDate) {
            b.add(PROPERTY_EXPIRATION_DATE, expirationDate.toString());
            return this;
        }

        public Builder lotNumber(final String lotNumber) {
            b.add(PROPERTY_LOT_NUMBER, lotNumber);
            return this;
        }

        public Builder serialNumber(final String serialNumber) {
            b.add(PROPERTY_SERIAL_NUMBER, serialNumber);
            return this;
        }

        public Builder deviceName(final java.util.List<DeviceDeviceName> deviceName) {
            b.add(PROPERTY_DEVICE_NAME, FhirObject.toArray(deviceName));
            return this;
        }

        public Builder modelNumber(final String modelNumber) {
            b.add(PROPERTY_MODEL_NUMBER, modelNumber);
            return this;
        }

        public Builder partNumber(final String partNumber) {
            b.add(PROPERTY_PART_NUMBER, partNumber);
            return this;
        }

        public Builder type(final CodeableConcept type) {
            b.add(PROPERTY_TYPE, type);
            return this;
        }

        public Builder specialization(final java.util.List<DeviceSpecialization> specialization) {
            b.add(PROPERTY_SPECIALIZATION, FhirObject.toArray(specialization));
            return this;
        }

        public Builder version(final java.util.List<DeviceVersion> version) {
            b.add(PROPERTY_VERSION, FhirObject.toArray(version));
            return this;
        }

        public Builder property(final java.util.List<DeviceProperty> property) {
            b.add(PROPERTY_PROPERTY, FhirObject.toArray(property));
            return this;
        }

        public Builder patient(final Reference patient) {
            b.add(PROPERTY_PATIENT, patient);
            return this;
        }

        public Builder owner(final Reference owner) {
            b.add(PROPERTY_OWNER, owner);
            return this;
        }

        public Builder contact(final java.util.List<ContactPoint> contact) {
            b.add(PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder location(final Reference location) {
            b.add(PROPERTY_LOCATION, location);
            return this;
        }

        public Builder url(final java.net.URI url) {
            b.add(PROPERTY_URL, url.toString());
            return this;
        }

        public Builder note(final java.util.List<Annotation> note) {
            b.add(PROPERTY_NOTE, FhirObject.toArray(note));
            return this;
        }

        public Builder safety(final java.util.List<CodeableConcept> safety) {
            b.add(PROPERTY_SAFETY, FhirObject.toArray(safety));
            return this;
        }

        public Builder parent(final Reference parent) {
            b.add(PROPERTY_PARENT, parent);
            return this;
        }

        public Device build() {
            return new Device(b.build());
        }
    }

    /**
     * A type of a manufactured item that is used in the provision of
     * healthcare without being substantially changed through that activity.
     * The device may be a medical or non-medical device.
     */
    public static class DeviceDeviceName extends FhirObject {
        public static final String RESOURCE_TYPE = "DeviceDeviceName";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_TYPE = "type";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DeviceDeviceName(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of the device.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * The type of deviceName.
         * UDILabelName | UserFriendlyName | PatientReportedName |
         * ManufactureDeviceName | ModelName.
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public DeviceDeviceName build() {
                return new DeviceDeviceName(b.build());
            }
        }
    }

    /**
     * A type of a manufactured item that is used in the provision of
     * healthcare without being substantially changed through that activity.
     * The device may be a medical or non-medical device.
     */
    public static class DeviceProperty extends FhirObject {
        public static final String RESOURCE_TYPE = "DeviceProperty";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_VALUE_QUANTITY = "valueQuantity";
        public static final String PROPERTY_VALUE_CODE = "valueCode";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DeviceProperty(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Code that specifies the property DeviceDefinitionPropetyCode
         * (Extensible).
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Property value as a quantity.
         */
        public java.util.List<Quantity> valueQuantity() {
            return getList(Quantity.class, PROPERTY_VALUE_QUANTITY);
        }

        /**
         * Property value as a code, e.g., NTP4 (synced to NTP).
         */
        public java.util.List<CodeableConcept> valueCode() {
            return getList(CodeableConcept.class, PROPERTY_VALUE_CODE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder valueQuantity(final java.util.List<Quantity> valueQuantity) {
                b.add(PROPERTY_VALUE_QUANTITY, FhirObject.toArray(valueQuantity));
                return this;
            }

            public Builder valueCode(final java.util.List<CodeableConcept> valueCode) {
                b.add(PROPERTY_VALUE_CODE, FhirObject.toArray(valueCode));
                return this;
            }

            public DeviceProperty build() {
                return new DeviceProperty(b.build());
            }
        }
    }

    /**
     * A type of a manufactured item that is used in the provision of
     * healthcare without being substantially changed through that activity.
     * The device may be a medical or non-medical device.
     */
    public static class DeviceSpecialization extends FhirObject {
        public static final String RESOURCE_TYPE = "DeviceSpecialization";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_SYSTEM_TYPE = "systemType";
        public static final String PROPERTY_VERSION = "version";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DeviceSpecialization(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The standard that is used to operate and communicate.
         */
        public CodeableConcept systemType() {
            return getObject(CodeableConcept.class, PROPERTY_SYSTEM_TYPE);
        }

        /**
         * The version of the standard that is used to operate and communicate.
         */
        public String version() {
            return getString(PROPERTY_VERSION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder systemType(final CodeableConcept systemType) {
                b.add(PROPERTY_SYSTEM_TYPE, systemType);
                return this;
            }

            public Builder version(final String version) {
                b.add(PROPERTY_VERSION, version);
                return this;
            }

            public DeviceSpecialization build() {
                return new DeviceSpecialization(b.build());
            }
        }
    }

    /**
     * A type of a manufactured item that is used in the provision of
     * healthcare without being substantially changed through that activity.
     * The device may be a medical or non-medical device.
     */
    public static class DeviceUdiCarrier extends FhirObject {
        public static final String RESOURCE_TYPE = "DeviceUdiCarrier";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_DEVICE_IDENTIFIER = "deviceIdentifier";
        public static final String PROPERTY_ISSUER = "issuer";
        public static final String PROPERTY_JURISDICTION = "jurisdiction";
        public static final String PROPERTY_CARRIER_A_I_D_C = "carrierAIDC";
        public static final String PROPERTY_CARRIER_H_R_F = "carrierHRF";
        public static final String PROPERTY_ENTRY_TYPE = "entryType";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DeviceUdiCarrier(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The device identifier (DI) is a mandatory, fixed portion of a UDI that
         * identifies the labeler and the specific version or model of a device.
         */
        public String deviceIdentifier() {
            return getString(PROPERTY_DEVICE_IDENTIFIER);
        }

        /**
         * Organization that is charged with issuing UDIs for devices.  For
         * example, the US FDA issuers include :
         * 1) GS1:
         * http://hl7.org/fhir/NamingSystem/gs1-di,
         * 2) HIBCC:
         * http://hl7.org/fhir/NamingSystem/hibcc-dI,
         * 3) ICCBBA for blood containers:
         * http://hl7.org/fhir/NamingSystem/iccbba-blood-di,
         * 4) ICCBA for other devices:
         * http://hl7.org/fhir/NamingSystem/iccbba-other-di.
         */
        public java.net.URI issuer() {
            return getUri(PROPERTY_ISSUER);
        }

        /**
         * The identity of the authoritative source for UDI generation within a
         * jurisdiction.  All UDIs are globally unique within a single namespace
         * with the appropriate repository uri as the system.  For example,  UDIs
         * of devices managed in the U.S. by the FDA, the value is
         * http://hl7.org/fhir/NamingSystem/fda-udi.
         */
        public java.net.URI jurisdiction() {
            return getUri(PROPERTY_JURISDICTION);
        }

        /**
         * The full UDI carrier of the Automatic Identification and Data Capture
         * (AIDC) technology representation of the barcode string as printed on
         * the packaging of the device - e.g., a barcode or RFID.   Because of
         * limitations on character sets in XML and the need to round-trip JSON
         * data through XML, AIDC Formats *SHALL* be base64 encoded.
         */
        public String carrierAIDC() {
            return getString(PROPERTY_CARRIER_A_I_D_C);
        }

        /**
         * The full UDI carrier as the human readable form (HRF) representation
         * of the barcode string as printed on the packaging of the device.
         */
        public String carrierHRF() {
            return getString(PROPERTY_CARRIER_H_R_F);
        }

        /**
         * A coded entry to indicate how the data was entered.
         */
        public String entryType() {
            return getString(PROPERTY_ENTRY_TYPE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder deviceIdentifier(final String deviceIdentifier) {
                b.add(PROPERTY_DEVICE_IDENTIFIER, deviceIdentifier);
                return this;
            }

            public Builder issuer(final java.net.URI issuer) {
                b.add(PROPERTY_ISSUER, issuer.toString());
                return this;
            }

            public Builder jurisdiction(final java.net.URI jurisdiction) {
                b.add(PROPERTY_JURISDICTION, jurisdiction.toString());
                return this;
            }

            public Builder carrierAIDC(final String carrierAIDC) {
                b.add(PROPERTY_CARRIER_A_I_D_C, carrierAIDC);
                return this;
            }

            public Builder carrierHRF(final String carrierHRF) {
                b.add(PROPERTY_CARRIER_H_R_F, carrierHRF);
                return this;
            }

            public Builder entryType(final String entryType) {
                b.add(PROPERTY_ENTRY_TYPE, entryType);
                return this;
            }

            public DeviceUdiCarrier build() {
                return new DeviceUdiCarrier(b.build());
            }
        }
    }

    /**
     * A type of a manufactured item that is used in the provision of
     * healthcare without being substantially changed through that activity.
     * The device may be a medical or non-medical device.
     */
    public static class DeviceVersion extends FhirObject {
        public static final String RESOURCE_TYPE = "DeviceVersion";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_COMPONENT = "component";
        public static final String PROPERTY_VALUE = "value";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DeviceVersion(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The type of the device version.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * A single component of the device version.
         */
        public Identifier component() {
            return getObject(Identifier.class, PROPERTY_COMPONENT);
        }

        /**
         * The version text.
         */
        public String value() {
            return getString(PROPERTY_VALUE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder component(final Identifier component) {
                b.add(PROPERTY_COMPONENT, component);
                return this;
            }

            public Builder value(final String value) {
                b.add(PROPERTY_VALUE, value);
                return this;
            }

            public DeviceVersion build() {
                return new DeviceVersion(b.build());
            }
        }
    }
}
