/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class SubstanceSpecification extends FhirResource {
    public static final String RESOURCE_TYPE = "SubstanceSpecification";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_EXTENSION = "extension";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_TYPE = "type";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_DOMAIN = "domain";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_SOURCE = "source";
    public static final String PROPERTY_COMMENT = "comment";
    public static final String PROPERTY_MOIETY = "moiety";
    public static final String PROPERTY_PROPERTY = "property";
    public static final String PROPERTY_REFERENCE_INFORMATION = "referenceInformation";
    public static final String PROPERTY_STRUCTURE = "structure";
    public static final String PROPERTY_CODE = "code";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_MOLECULAR_WEIGHT = "molecularWeight";
    public static final String PROPERTY_RELATIONSHIP = "relationship";
    public static final String PROPERTY_NUCLEIC_ACID = "nucleicAcid";
    public static final String PROPERTY_POLYMER = "polymer";
    public static final String PROPERTY_PROTEIN = "protein";
    public static final String PROPERTY_SOURCE_MATERIAL = "sourceMaterial";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public SubstanceSpecification(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Identifier by which this substance is known.
     */
    public Identifier identifier() {
        return getObject(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * High level categorization, e.g. polymer or nucleic acid.
     */
    public CodeableConcept type() {
        return getObject(CodeableConcept.class, PROPERTY_TYPE);
    }

    /**
     * Status of substance within the catalogue e.g. approved.
     */
    public CodeableConcept status() {
        return getObject(CodeableConcept.class, PROPERTY_STATUS);
    }

    /**
     * If the substance applies to only human or veterinary use.
     */
    public CodeableConcept domain() {
        return getObject(CodeableConcept.class, PROPERTY_DOMAIN);
    }

    /**
     * Textual description of the substance.
     */
    public String description() {
        return getString(PROPERTY_DESCRIPTION);
    }

    /**
     * Supporting literature.
     */
    public java.util.List<Reference> source() {
        return getList(Reference.class, PROPERTY_SOURCE);
    }

    /**
     * Textual comment about this record of a substance.
     */
    public String comment() {
        return getString(PROPERTY_COMMENT);
    }

    /**
     * Moiety, for structural modifications.
     */
    public java.util.List<SubstanceSpecificationMoiety> moiety() {
        return getList(SubstanceSpecificationMoiety.class, PROPERTY_MOIETY);
    }

    /**
     * General specifications for this substance, including how it is related
     * to other substances.
     */
    public java.util.List<SubstanceSpecificationProperty> property() {
        return getList(SubstanceSpecificationProperty.class, PROPERTY_PROPERTY);
    }

    /**
     * General information detailing this substance.
     */
    public Reference referenceInformation() {
        return getObject(Reference.class, PROPERTY_REFERENCE_INFORMATION);
    }

    /**
     * Structural information.
     */
    public SubstanceSpecificationStructure structure() {
        return getObject(SubstanceSpecificationStructure.class, PROPERTY_STRUCTURE);
    }

    /**
     * Codes associated with the substance.
     */
    public java.util.List<SubstanceSpecificationCode> code() {
        return getList(SubstanceSpecificationCode.class, PROPERTY_CODE);
    }

    /**
     * Names applicable to this substance.
     */
    public java.util.List<SubstanceSpecificationName> name() {
        return getList(SubstanceSpecificationName.class, PROPERTY_NAME);
    }

    /**
     * The molecular weight or weight range (for proteins, polymers or
     * nucleic acids).
     */
    public java.util.List<SubstanceSpecificationMolecularWeight> molecularWeight() {
        return getList(SubstanceSpecificationMolecularWeight.class, PROPERTY_MOLECULAR_WEIGHT);
    }

    /**
     * A link between this substance and another, with details of the
     * relationship.
     */
    public java.util.List<SubstanceSpecificationRelationship> relationship() {
        return getList(SubstanceSpecificationRelationship.class, PROPERTY_RELATIONSHIP);
    }

    /**
     * Data items specific to nucleic acids.
     */
    public Reference nucleicAcid() {
        return getObject(Reference.class, PROPERTY_NUCLEIC_ACID);
    }

    /**
     * Data items specific to polymers.
     */
    public Reference polymer() {
        return getObject(Reference.class, PROPERTY_POLYMER);
    }

    /**
     * Data items specific to proteins.
     */
    public Reference protein() {
        return getObject(Reference.class, PROPERTY_PROTEIN);
    }

    /**
     * Material or taxonomic/anatomical source for the substance.
     */
    public Reference sourceMaterial() {
        return getObject(Reference.class, PROPERTY_SOURCE_MATERIAL);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final Identifier identifier) {
            b.add(PROPERTY_IDENTIFIER, identifier);
            return this;
        }

        public Builder type(final CodeableConcept type) {
            b.add(PROPERTY_TYPE, type);
            return this;
        }

        public Builder status(final CodeableConcept status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder domain(final CodeableConcept domain) {
            b.add(PROPERTY_DOMAIN, domain);
            return this;
        }

        public Builder description(final String description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder source(final java.util.List<Reference> source) {
            b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
            return this;
        }

        public Builder comment(final String comment) {
            b.add(PROPERTY_COMMENT, comment);
            return this;
        }

        public Builder moiety(final java.util.List<SubstanceSpecificationMoiety> moiety) {
            b.add(PROPERTY_MOIETY, FhirObject.toArray(moiety));
            return this;
        }

        public Builder property(final java.util.List<SubstanceSpecificationProperty> property) {
            b.add(PROPERTY_PROPERTY, FhirObject.toArray(property));
            return this;
        }

        public Builder referenceInformation(final Reference referenceInformation) {
            b.add(PROPERTY_REFERENCE_INFORMATION, referenceInformation);
            return this;
        }

        public Builder structure(final SubstanceSpecificationStructure structure) {
            b.add(PROPERTY_STRUCTURE, structure);
            return this;
        }

        public Builder code(final java.util.List<SubstanceSpecificationCode> code) {
            b.add(PROPERTY_CODE, FhirObject.toArray(code));
            return this;
        }

        public Builder name(final java.util.List<SubstanceSpecificationName> name) {
            b.add(PROPERTY_NAME, FhirObject.toArray(name));
            return this;
        }

        public Builder molecularWeight(final java.util.List<SubstanceSpecificationMolecularWeight> molecularWeight) {
            b.add(PROPERTY_MOLECULAR_WEIGHT, FhirObject.toArray(molecularWeight));
            return this;
        }

        public Builder relationship(final java.util.List<SubstanceSpecificationRelationship> relationship) {
            b.add(PROPERTY_RELATIONSHIP, FhirObject.toArray(relationship));
            return this;
        }

        public Builder nucleicAcid(final Reference nucleicAcid) {
            b.add(PROPERTY_NUCLEIC_ACID, nucleicAcid);
            return this;
        }

        public Builder polymer(final Reference polymer) {
            b.add(PROPERTY_POLYMER, polymer);
            return this;
        }

        public Builder protein(final Reference protein) {
            b.add(PROPERTY_PROTEIN, protein);
            return this;
        }

        public Builder sourceMaterial(final Reference sourceMaterial) {
            b.add(PROPERTY_SOURCE_MATERIAL, sourceMaterial);
            return this;
        }

        public SubstanceSpecification build() {
            return new SubstanceSpecification(b.build());
        }
    }

    public static class SubstanceSpecificationCode extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationCode";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_STATUS = "status";
        public static final String PROPERTY_STATUS_DATE = "statusDate";
        public static final String PROPERTY_COMMENT = "comment";
        public static final String PROPERTY_SOURCE = "source";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationCode(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The specific code.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, PROPERTY_CODE);
        }

        /**
         * Status of the code assignment.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, PROPERTY_STATUS);
        }

        /**
         * The date at which the code status is changed as part of the
         * terminology maintenance.
         */
        public java.time.Instant statusDate() {
            return java.time.Instant.parse(data.getString(PROPERTY_STATUS_DATE));
        }

        /**
         * Any comment can be provided in this field, if necessary.
         */
        public String comment() {
            return getString(PROPERTY_COMMENT);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, PROPERTY_SOURCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(PROPERTY_STATUS, status);
                return this;
            }

            public Builder statusDate(final java.time.Instant statusDate) {
                b.add(PROPERTY_STATUS_DATE, statusDate.toString());
                return this;
            }

            public Builder comment(final String comment) {
                b.add(PROPERTY_COMMENT, comment);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationCode build() {
                return new SubstanceSpecificationCode(b.build());
            }
        }
    }

    public static class SubstanceSpecificationIsotope extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationIsotope";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_IDENTIFIER = "identifier";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_SUBSTITUTION = "substitution";
        public static final String PROPERTY_HALF_LIFE = "halfLife";
        public static final String PROPERTY_MOLECULAR_WEIGHT = "molecularWeight";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationIsotope(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Substance identifier for each non-natural or radioisotope.
         */
        public Identifier identifier() {
            return getObject(Identifier.class, PROPERTY_IDENTIFIER);
        }

        /**
         * Substance name for each non-natural or radioisotope.
         */
        public CodeableConcept name() {
            return getObject(CodeableConcept.class, PROPERTY_NAME);
        }

        /**
         * The type of isotopic substitution present in a single substance.
         */
        public CodeableConcept substitution() {
            return getObject(CodeableConcept.class, PROPERTY_SUBSTITUTION);
        }

        /**
         * Half life - for a non-natural nuclide.
         */
        public Quantity halfLife() {
            return getObject(Quantity.class, PROPERTY_HALF_LIFE);
        }

        /**
         * The molecular weight or weight range (for proteins, polymers or
         * nucleic acids).
         */
        public SubstanceSpecificationMolecularWeight molecularWeight() {
            return getObject(SubstanceSpecificationMolecularWeight.class, PROPERTY_MOLECULAR_WEIGHT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder identifier(final Identifier identifier) {
                b.add(PROPERTY_IDENTIFIER, identifier);
                return this;
            }

            public Builder name(final CodeableConcept name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder substitution(final CodeableConcept substitution) {
                b.add(PROPERTY_SUBSTITUTION, substitution);
                return this;
            }

            public Builder halfLife(final Quantity halfLife) {
                b.add(PROPERTY_HALF_LIFE, halfLife);
                return this;
            }

            public Builder molecularWeight(final SubstanceSpecificationMolecularWeight molecularWeight) {
                b.add(PROPERTY_MOLECULAR_WEIGHT, molecularWeight);
                return this;
            }

            public SubstanceSpecificationIsotope build() {
                return new SubstanceSpecificationIsotope(b.build());
            }
        }
    }

    public static class SubstanceSpecificationMoiety extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationMoiety";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_ROLE = "role";
        public static final String PROPERTY_IDENTIFIER = "identifier";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_STEREOCHEMISTRY = "stereochemistry";
        public static final String PROPERTY_OPTICAL_ACTIVITY = "opticalActivity";
        public static final String PROPERTY_MOLECULAR_FORMULA = "molecularFormula";
        public static final String PROPERTY_AMOUNT_QUANTITY = "amountQuantity";
        public static final String PROPERTY_AMOUNT_STRING = "amountString";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationMoiety(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Role that the moiety is playing.
         */
        public CodeableConcept role() {
            return getObject(CodeableConcept.class, PROPERTY_ROLE);
        }

        /**
         * Identifier by which this moiety substance is known.
         */
        public Identifier identifier() {
            return getObject(Identifier.class, PROPERTY_IDENTIFIER);
        }

        /**
         * Textual name for this moiety substance.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Stereochemistry type.
         */
        public CodeableConcept stereochemistry() {
            return getObject(CodeableConcept.class, PROPERTY_STEREOCHEMISTRY);
        }

        /**
         * Optical activity type.
         */
        public CodeableConcept opticalActivity() {
            return getObject(CodeableConcept.class, PROPERTY_OPTICAL_ACTIVITY);
        }

        /**
         * Molecular formula.
         */
        public String molecularFormula() {
            return getString(PROPERTY_MOLECULAR_FORMULA);
        }

        /**
         * Quantitative value for this moiety.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * Quantitative value for this moiety.
         */
        public String amountString() {
            return getString(PROPERTY_AMOUNT_STRING);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder role(final CodeableConcept role) {
                b.add(PROPERTY_ROLE, role);
                return this;
            }

            public Builder identifier(final Identifier identifier) {
                b.add(PROPERTY_IDENTIFIER, identifier);
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder stereochemistry(final CodeableConcept stereochemistry) {
                b.add(PROPERTY_STEREOCHEMISTRY, stereochemistry);
                return this;
            }

            public Builder opticalActivity(final CodeableConcept opticalActivity) {
                b.add(PROPERTY_OPTICAL_ACTIVITY, opticalActivity);
                return this;
            }

            public Builder molecularFormula(final String molecularFormula) {
                b.add(PROPERTY_MOLECULAR_FORMULA, molecularFormula);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public SubstanceSpecificationMoiety build() {
                return new SubstanceSpecificationMoiety(b.build());
            }
        }
    }

    public static class SubstanceSpecificationMolecularWeight extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationMolecularWeight";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_METHOD = "method";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_AMOUNT = "amount";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationMolecularWeight(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The method by which the molecular weight was determined.
         */
        public CodeableConcept method() {
            return getObject(CodeableConcept.class, PROPERTY_METHOD);
        }

        /**
         * Type of molecular weight such as exact, average (also known as. number
         * average), weight average.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Used to capture quantitative values for a variety of elements. If only
         * limits are given, the arithmetic mean would be the average. If only a
         * single definite value for a given element is given, it would be
         * captured in this field.
         */
        public Quantity amount() {
            return getObject(Quantity.class, PROPERTY_AMOUNT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder method(final CodeableConcept method) {
                b.add(PROPERTY_METHOD, method);
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder amount(final Quantity amount) {
                b.add(PROPERTY_AMOUNT, amount);
                return this;
            }

            public SubstanceSpecificationMolecularWeight build() {
                return new SubstanceSpecificationMolecularWeight(b.build());
            }
        }
    }

    public static class SubstanceSpecificationName extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationName";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_STATUS = "status";
        public static final String PROPERTY_PREFERRED = "preferred";
        public static final String PROPERTY_LANGUAGE = "language";
        public static final String PROPERTY_DOMAIN = "domain";
        public static final String PROPERTY_JURISDICTION = "jurisdiction";
        public static final String PROPERTY_SYNONYM = "synonym";
        public static final String PROPERTY_TRANSLATION = "translation";
        public static final String PROPERTY_OFFICIAL = "official";
        public static final String PROPERTY_SOURCE = "source";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationName(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The actual name.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Name type.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * The status of the name.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, PROPERTY_STATUS);
        }

        /**
         * If this is the preferred name for this substance.
         */
        public Boolean preferred() {
            return data.getBoolean(PROPERTY_PREFERRED);
        }

        /**
         * Language of the name.
         */
        public java.util.List<CodeableConcept> language() {
            return getList(CodeableConcept.class, PROPERTY_LANGUAGE);
        }

        /**
         * The use context of this name for example if there is a different name
         * a drug active ingredient as opposed to a food colour additive.
         */
        public java.util.List<CodeableConcept> domain() {
            return getList(CodeableConcept.class, PROPERTY_DOMAIN);
        }

        /**
         * The jurisdiction where this name applies.
         */
        public java.util.List<CodeableConcept> jurisdiction() {
            return getList(CodeableConcept.class, PROPERTY_JURISDICTION);
        }

        /**
         * A synonym of this name.
         */
        public java.util.List<SubstanceSpecificationName> synonym() {
            return getList(SubstanceSpecificationName.class, PROPERTY_SYNONYM);
        }

        /**
         * A translation for this name.
         */
        public java.util.List<SubstanceSpecificationName> translation() {
            return getList(SubstanceSpecificationName.class, PROPERTY_TRANSLATION);
        }

        /**
         * Details of the official nature of this name.
         */
        public java.util.List<SubstanceSpecificationOfficial> official() {
            return getList(SubstanceSpecificationOfficial.class, PROPERTY_OFFICIAL);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, PROPERTY_SOURCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(PROPERTY_STATUS, status);
                return this;
            }

            public Builder preferred(final Boolean preferred) {
                b.add(PROPERTY_PREFERRED, preferred);
                return this;
            }

            public Builder language(final java.util.List<CodeableConcept> language) {
                b.add(PROPERTY_LANGUAGE, FhirObject.toArray(language));
                return this;
            }

            public Builder domain(final java.util.List<CodeableConcept> domain) {
                b.add(PROPERTY_DOMAIN, FhirObject.toArray(domain));
                return this;
            }

            public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
                b.add(PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
                return this;
            }

            public Builder synonym(final java.util.List<SubstanceSpecificationName> synonym) {
                b.add(PROPERTY_SYNONYM, FhirObject.toArray(synonym));
                return this;
            }

            public Builder translation(final java.util.List<SubstanceSpecificationName> translation) {
                b.add(PROPERTY_TRANSLATION, FhirObject.toArray(translation));
                return this;
            }

            public Builder official(final java.util.List<SubstanceSpecificationOfficial> official) {
                b.add(PROPERTY_OFFICIAL, FhirObject.toArray(official));
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationName build() {
                return new SubstanceSpecificationName(b.build());
            }
        }
    }

    public static class SubstanceSpecificationOfficial extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationOfficial";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_AUTHORITY = "authority";
        public static final String PROPERTY_STATUS = "status";
        public static final String PROPERTY_DATE = "date";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationOfficial(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Which authority uses this official name.
         */
        public CodeableConcept authority() {
            return getObject(CodeableConcept.class, PROPERTY_AUTHORITY);
        }

        /**
         * The status of the official name.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, PROPERTY_STATUS);
        }

        /**
         * Date of official name change.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder authority(final CodeableConcept authority) {
                b.add(PROPERTY_AUTHORITY, authority);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(PROPERTY_STATUS, status);
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public SubstanceSpecificationOfficial build() {
                return new SubstanceSpecificationOfficial(b.build());
            }
        }
    }

    public static class SubstanceSpecificationProperty extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationProperty";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CATEGORY = "category";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_PARAMETERS = "parameters";
        public static final String PROPERTY_DEFINING_SUBSTANCE_REFERENCE = "definingSubstanceReference";
        public static final String PROPERTY_DEFINING_SUBSTANCE_CODEABLE_CONCEPT = "definingSubstanceCodeableConcept";
        public static final String PROPERTY_AMOUNT_QUANTITY = "amountQuantity";
        public static final String PROPERTY_AMOUNT_STRING = "amountString";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationProperty(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A category for this property, e.g. Physical, Chemical, Enzymatic.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, PROPERTY_CATEGORY);
        }

        /**
         * Property type e.g. viscosity, pH, isoelectric point.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, PROPERTY_CODE);
        }

        /**
         * Parameters that were used in the measurement of a property (e.g. for
         * viscosity: measured at 20C with a pH of 7.1).
         */
        public String parameters() {
            return getString(PROPERTY_PARAMETERS);
        }

        /**
         * A substance upon which a defining property depends (e.g. for
         * solubility: in water, in alcohol).
         */
        public Reference definingSubstanceReference() {
            return getObject(Reference.class, PROPERTY_DEFINING_SUBSTANCE_REFERENCE);
        }

        /**
         * A substance upon which a defining property depends (e.g. for
         * solubility: in water, in alcohol).
         */
        public CodeableConcept definingSubstanceCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_DEFINING_SUBSTANCE_CODEABLE_CONCEPT);
        }

        /**
         * Quantitative value for this property.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * Quantitative value for this property.
         */
        public String amountString() {
            return getString(PROPERTY_AMOUNT_STRING);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder parameters(final String parameters) {
                b.add(PROPERTY_PARAMETERS, parameters);
                return this;
            }

            public Builder definingSubstanceReference(final Reference definingSubstanceReference) {
                b.add(PROPERTY_DEFINING_SUBSTANCE_REFERENCE, definingSubstanceReference);
                return this;
            }

            public Builder definingSubstanceCodeableConcept(final CodeableConcept definingSubstanceCodeableConcept) {
                b.add(PROPERTY_DEFINING_SUBSTANCE_CODEABLE_CONCEPT, definingSubstanceCodeableConcept);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public SubstanceSpecificationProperty build() {
                return new SubstanceSpecificationProperty(b.build());
            }
        }
    }

    public static class SubstanceSpecificationRelationship extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationRelationship";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_SUBSTANCE_REFERENCE = "substanceReference";
        public static final String PROPERTY_SUBSTANCE_CODEABLE_CONCEPT = "substanceCodeableConcept";
        public static final String PROPERTY_RELATIONSHIP = "relationship";
        public static final String PROPERTY_IS_DEFINING = "isDefining";
        public static final String PROPERTY_AMOUNT_QUANTITY = "amountQuantity";
        public static final String PROPERTY_AMOUNT_RANGE = "amountRange";
        public static final String PROPERTY_AMOUNT_RATIO = "amountRatio";
        public static final String PROPERTY_AMOUNT_STRING = "amountString";
        public static final String PROPERTY_AMOUNT_RATIO_LOW_LIMIT = "amountRatioLowLimit";
        public static final String PROPERTY_AMOUNT_TYPE = "amountType";
        public static final String PROPERTY_SOURCE = "source";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationRelationship(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A pointer to another substance, as a resource or just a
         * representational code.
         */
        public Reference substanceReference() {
            return getObject(Reference.class, PROPERTY_SUBSTANCE_REFERENCE);
        }

        /**
         * A pointer to another substance, as a resource or just a
         * representational code.
         */
        public CodeableConcept substanceCodeableConcept() {
            return getObject(CodeableConcept.class, PROPERTY_SUBSTANCE_CODEABLE_CONCEPT);
        }

        /**
         * For example &quot;salt to parent&quot;, &quot;active moiety&quot;, &quot;starting material&quot;.
         */
        public CodeableConcept relationship() {
            return getObject(CodeableConcept.class, PROPERTY_RELATIONSHIP);
        }

        /**
         * For example where an enzyme strongly bonds with a particular
         * substance, this is a defining relationship for that enzyme, out of
         * several possible substance relationships.
         */
        public Boolean isDefining() {
            return data.getBoolean(PROPERTY_IS_DEFINING);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Range amountRange() {
            return getObject(Range.class, PROPERTY_AMOUNT_RANGE);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Ratio amountRatio() {
            return getObject(Ratio.class, PROPERTY_AMOUNT_RATIO);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public String amountString() {
            return getString(PROPERTY_AMOUNT_STRING);
        }

        /**
         * For use when the numeric.
         */
        public Ratio amountRatioLowLimit() {
            return getObject(Ratio.class, PROPERTY_AMOUNT_RATIO_LOW_LIMIT);
        }

        /**
         * An operator for the amount, for example &quot;average&quot;, &quot;approximately&quot;,
         * &quot;less than&quot;.
         */
        public CodeableConcept amountType() {
            return getObject(CodeableConcept.class, PROPERTY_AMOUNT_TYPE);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, PROPERTY_SOURCE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder substanceReference(final Reference substanceReference) {
                b.add(PROPERTY_SUBSTANCE_REFERENCE, substanceReference);
                return this;
            }

            public Builder substanceCodeableConcept(final CodeableConcept substanceCodeableConcept) {
                b.add(PROPERTY_SUBSTANCE_CODEABLE_CONCEPT, substanceCodeableConcept);
                return this;
            }

            public Builder relationship(final CodeableConcept relationship) {
                b.add(PROPERTY_RELATIONSHIP, relationship);
                return this;
            }

            public Builder isDefining(final Boolean isDefining) {
                b.add(PROPERTY_IS_DEFINING, isDefining);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountRange(final Range amountRange) {
                b.add(PROPERTY_AMOUNT_RANGE, amountRange);
                return this;
            }

            public Builder amountRatio(final Ratio amountRatio) {
                b.add(PROPERTY_AMOUNT_RATIO, amountRatio);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public Builder amountRatioLowLimit(final Ratio amountRatioLowLimit) {
                b.add(PROPERTY_AMOUNT_RATIO_LOW_LIMIT, amountRatioLowLimit);
                return this;
            }

            public Builder amountType(final CodeableConcept amountType) {
                b.add(PROPERTY_AMOUNT_TYPE, amountType);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationRelationship build() {
                return new SubstanceSpecificationRelationship(b.build());
            }
        }
    }

    public static class SubstanceSpecificationRepresentation extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationRepresentation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_REPRESENTATION = "representation";
        public static final String PROPERTY_ATTACHMENT = "attachment";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationRepresentation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The type of structure (e.g. Full, Partial, Representative).
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * The structural representation as text string in a format e.g. InChI,
         * SMILES, MOLFILE, CDX.
         */
        public String representation() {
            return getString(PROPERTY_REPRESENTATION);
        }

        /**
         * An attached file with the structural representation.
         */
        public Attachment attachment() {
            return getObject(Attachment.class, PROPERTY_ATTACHMENT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder representation(final String representation) {
                b.add(PROPERTY_REPRESENTATION, representation);
                return this;
            }

            public Builder attachment(final Attachment attachment) {
                b.add(PROPERTY_ATTACHMENT, attachment);
                return this;
            }

            public SubstanceSpecificationRepresentation build() {
                return new SubstanceSpecificationRepresentation(b.build());
            }
        }
    }

    public static class SubstanceSpecificationStructure extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationStructure";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_STEREOCHEMISTRY = "stereochemistry";
        public static final String PROPERTY_OPTICAL_ACTIVITY = "opticalActivity";
        public static final String PROPERTY_MOLECULAR_FORMULA = "molecularFormula";
        public static final String PROPERTY_MOLECULAR_FORMULA_BY_MOIETY = "molecularFormulaByMoiety";
        public static final String PROPERTY_ISOTOPE = "isotope";
        public static final String PROPERTY_MOLECULAR_WEIGHT = "molecularWeight";
        public static final String PROPERTY_SOURCE = "source";
        public static final String PROPERTY_REPRESENTATION = "representation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationStructure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Stereochemistry type.
         */
        public CodeableConcept stereochemistry() {
            return getObject(CodeableConcept.class, PROPERTY_STEREOCHEMISTRY);
        }

        /**
         * Optical activity type.
         */
        public CodeableConcept opticalActivity() {
            return getObject(CodeableConcept.class, PROPERTY_OPTICAL_ACTIVITY);
        }

        /**
         * Molecular formula.
         */
        public String molecularFormula() {
            return getString(PROPERTY_MOLECULAR_FORMULA);
        }

        /**
         * Specified per moiety according to the Hill system, i.e. first C, then
         * H, then alphabetical, each moiety separated by a dot.
         */
        public String molecularFormulaByMoiety() {
            return getString(PROPERTY_MOLECULAR_FORMULA_BY_MOIETY);
        }

        /**
         * Applicable for single substances that contain a radionuclide or a
         * non-natural isotopic ratio.
         */
        public java.util.List<SubstanceSpecificationIsotope> isotope() {
            return getList(SubstanceSpecificationIsotope.class, PROPERTY_ISOTOPE);
        }

        /**
         * The molecular weight or weight range (for proteins, polymers or
         * nucleic acids).
         */
        public SubstanceSpecificationMolecularWeight molecularWeight() {
            return getObject(SubstanceSpecificationMolecularWeight.class, PROPERTY_MOLECULAR_WEIGHT);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, PROPERTY_SOURCE);
        }

        /**
         * Molecular structural representation.
         */
        public java.util.List<SubstanceSpecificationRepresentation> representation() {
            return getList(SubstanceSpecificationRepresentation.class, PROPERTY_REPRESENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder stereochemistry(final CodeableConcept stereochemistry) {
                b.add(PROPERTY_STEREOCHEMISTRY, stereochemistry);
                return this;
            }

            public Builder opticalActivity(final CodeableConcept opticalActivity) {
                b.add(PROPERTY_OPTICAL_ACTIVITY, opticalActivity);
                return this;
            }

            public Builder molecularFormula(final String molecularFormula) {
                b.add(PROPERTY_MOLECULAR_FORMULA, molecularFormula);
                return this;
            }

            public Builder molecularFormulaByMoiety(final String molecularFormulaByMoiety) {
                b.add(PROPERTY_MOLECULAR_FORMULA_BY_MOIETY, molecularFormulaByMoiety);
                return this;
            }

            public Builder isotope(final java.util.List<SubstanceSpecificationIsotope> isotope) {
                b.add(PROPERTY_ISOTOPE, FhirObject.toArray(isotope));
                return this;
            }

            public Builder molecularWeight(final SubstanceSpecificationMolecularWeight molecularWeight) {
                b.add(PROPERTY_MOLECULAR_WEIGHT, molecularWeight);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public Builder representation(final java.util.List<SubstanceSpecificationRepresentation> representation) {
                b.add(PROPERTY_REPRESENTATION, FhirObject.toArray(representation));
                return this;
            }

            public SubstanceSpecificationStructure build() {
                return new SubstanceSpecificationStructure(b.build());
            }
        }
    }
}
