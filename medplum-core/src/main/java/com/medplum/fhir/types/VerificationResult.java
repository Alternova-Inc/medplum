/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class VerificationResult extends FhirResource {
    public static final String RESOURCE_TYPE = "VerificationResult";
    public static final String PROPERTY_RESOURCETYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICITRULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_TARGET = "target";
    public static final String PROPERTY_TARGETLOCATION = "targetLocation";
    public static final String PROPERTY_NEED = "need";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_STATUSDATE = "statusDate";
    public static final String PROPERTY_VALIDATIONTYPE = "validationType";
    public static final String PROPERTY_VALIDATIONPROCESS = "validationProcess";
    public static final String PROPERTY_FREQUENCY = "frequency";
    public static final String PROPERTY_LASTPERFORMED = "lastPerformed";
    public static final String PROPERTY_NEXTSCHEDULED = "nextScheduled";
    public static final String PROPERTY_FAILUREACTION = "failureAction";
    public static final String PROPERTY_PRIMARYSOURCE = "primarySource";
    public static final String PROPERTY_ATTESTATION = "attestation";
    public static final String PROPERTY_VALIDATOR = "validator";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public VerificationResult(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICITRULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * A resource that was validated.
     */
    public java.util.List<Reference> target() {
        return getList(Reference.class, PROPERTY_TARGET);
    }

    /**
     * The fhirpath location(s) within the resource that was validated.
     */
    public java.util.List<String> targetLocation() {
        return getList(String.class, PROPERTY_TARGETLOCATION);
    }

    /**
     * The frequency with which the target must be validated (none; initial; periodic).
     */
    public CodeableConcept need() {
        return getObject(CodeableConcept.class, PROPERTY_NEED);
    }

    /**
     * The validation status of the target (attested; validated; in process; requires revalidation; validation failed; revalidation failed).
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * When the validation status was updated.
     */
    public java.time.Instant statusDate() {
        return java.time.Instant.parse(data.getString(PROPERTY_STATUSDATE));
    }

    /**
     * What the target is validated against (nothing; primary source; multiple sources).
     */
    public CodeableConcept validationType() {
        return getObject(CodeableConcept.class, PROPERTY_VALIDATIONTYPE);
    }

    /**
     * The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context).
     */
    public java.util.List<CodeableConcept> validationProcess() {
        return getList(CodeableConcept.class, PROPERTY_VALIDATIONPROCESS);
    }

    /**
     * Frequency of revalidation.
     */
    public Timing frequency() {
        return getObject(Timing.class, PROPERTY_FREQUENCY);
    }

    /**
     * The date/time validation was last completed (including failed validations).
     */
    public java.time.Instant lastPerformed() {
        return java.time.Instant.parse(data.getString(PROPERTY_LASTPERFORMED));
    }

    /**
     * The date when target is next validated, if appropriate.
     */
    public java.time.Instant nextScheduled() {
        return java.time.Instant.parse(data.getString(PROPERTY_NEXTSCHEDULED));
    }

    /**
     * The result if validation fails (fatal; warning; record only; none).
     */
    public CodeableConcept failureAction() {
        return getObject(CodeableConcept.class, PROPERTY_FAILUREACTION);
    }

    /**
     * Information about the primary source(s) involved in validation.
     */
    public java.util.List<VerificationResultPrimarySource> primarySource() {
        return getList(VerificationResultPrimarySource.class, PROPERTY_PRIMARYSOURCE);
    }

    /**
     * Information about the entity attesting to information.
     */
    public VerificationResultAttestation attestation() {
        return getObject(VerificationResultAttestation.class, PROPERTY_ATTESTATION);
    }

    /**
     * Information about the entity validating information.
     */
    public java.util.List<VerificationResultValidator> validator() {
        return getList(VerificationResultValidator.class, PROPERTY_VALIDATOR);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCETYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICITRULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder target(final java.util.List<Reference> target) {
            b.add(PROPERTY_TARGET, FhirObject.toArray(target));
            return this;
        }

        public Builder targetLocation(final java.util.List<String> targetLocation) {
            b.add(PROPERTY_TARGETLOCATION, FhirObject.toStringArray(targetLocation));
            return this;
        }

        public Builder need(final CodeableConcept need) {
            b.add(PROPERTY_NEED, need);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder statusDate(final java.time.Instant statusDate) {
            b.add(PROPERTY_STATUSDATE, statusDate.toString());
            return this;
        }

        public Builder validationType(final CodeableConcept validationType) {
            b.add(PROPERTY_VALIDATIONTYPE, validationType);
            return this;
        }

        public Builder validationProcess(final java.util.List<CodeableConcept> validationProcess) {
            b.add(PROPERTY_VALIDATIONPROCESS, FhirObject.toArray(validationProcess));
            return this;
        }

        public Builder frequency(final Timing frequency) {
            b.add(PROPERTY_FREQUENCY, frequency);
            return this;
        }

        public Builder lastPerformed(final java.time.Instant lastPerformed) {
            b.add(PROPERTY_LASTPERFORMED, lastPerformed.toString());
            return this;
        }

        public Builder nextScheduled(final java.time.Instant nextScheduled) {
            b.add(PROPERTY_NEXTSCHEDULED, nextScheduled.toString());
            return this;
        }

        public Builder failureAction(final CodeableConcept failureAction) {
            b.add(PROPERTY_FAILUREACTION, failureAction);
            return this;
        }

        public Builder primarySource(final java.util.List<VerificationResultPrimarySource> primarySource) {
            b.add(PROPERTY_PRIMARYSOURCE, FhirObject.toArray(primarySource));
            return this;
        }

        public Builder attestation(final VerificationResultAttestation attestation) {
            b.add(PROPERTY_ATTESTATION, attestation);
            return this;
        }

        public Builder validator(final java.util.List<VerificationResultValidator> validator) {
            b.add(PROPERTY_VALIDATOR, FhirObject.toArray(validator));
            return this;
        }

        public VerificationResult build() {
            return new VerificationResult(b.build());
        }
    }

    public static class VerificationResultAttestation extends FhirObject {
        public static final String RESOURCE_TYPE = "VerificationResultAttestation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_WHO = "who";
        public static final String PROPERTY_ONBEHALFOF = "onBehalfOf";
        public static final String PROPERTY_COMMUNICATIONMETHOD = "communicationMethod";
        public static final String PROPERTY_DATE = "date";
        public static final String PROPERTY_SOURCEIDENTITYCERTIFICATE = "sourceIdentityCertificate";
        public static final String PROPERTY_PROXYIDENTITYCERTIFICATE = "proxyIdentityCertificate";
        public static final String PROPERTY_PROXYSIGNATURE = "proxySignature";
        public static final String PROPERTY_SOURCESIGNATURE = "sourceSignature";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public VerificationResultAttestation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The individual or organization attesting to information.
         */
        public Reference who() {
            return getObject(Reference.class, PROPERTY_WHO);
        }

        /**
         * When the who is asserting on behalf of another (organization or individual).
         */
        public Reference onBehalfOf() {
            return getObject(Reference.class, PROPERTY_ONBEHALFOF);
        }

        /**
         * The method by which attested information was submitted/retrieved (manual; API; Push).
         */
        public CodeableConcept communicationMethod() {
            return getObject(CodeableConcept.class, PROPERTY_COMMUNICATIONMETHOD);
        }

        /**
         * The date the information was attested to.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        /**
         * A digital identity certificate associated with the attestation source.
         */
        public String sourceIdentityCertificate() {
            return getString(PROPERTY_SOURCEIDENTITYCERTIFICATE);
        }

        /**
         * A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
         */
        public String proxyIdentityCertificate() {
            return getString(PROPERTY_PROXYIDENTITYCERTIFICATE);
        }

        /**
         * Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source.
         */
        public Signature proxySignature() {
            return getObject(Signature.class, PROPERTY_PROXYSIGNATURE);
        }

        /**
         * Signed assertion by the attestation source that they have attested to the information.
         */
        public Signature sourceSignature() {
            return getObject(Signature.class, PROPERTY_SOURCESIGNATURE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder who(final Reference who) {
                b.add(PROPERTY_WHO, who);
                return this;
            }

            public Builder onBehalfOf(final Reference onBehalfOf) {
                b.add(PROPERTY_ONBEHALFOF, onBehalfOf);
                return this;
            }

            public Builder communicationMethod(final CodeableConcept communicationMethod) {
                b.add(PROPERTY_COMMUNICATIONMETHOD, communicationMethod);
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public Builder sourceIdentityCertificate(final String sourceIdentityCertificate) {
                b.add(PROPERTY_SOURCEIDENTITYCERTIFICATE, sourceIdentityCertificate);
                return this;
            }

            public Builder proxyIdentityCertificate(final String proxyIdentityCertificate) {
                b.add(PROPERTY_PROXYIDENTITYCERTIFICATE, proxyIdentityCertificate);
                return this;
            }

            public Builder proxySignature(final Signature proxySignature) {
                b.add(PROPERTY_PROXYSIGNATURE, proxySignature);
                return this;
            }

            public Builder sourceSignature(final Signature sourceSignature) {
                b.add(PROPERTY_SOURCESIGNATURE, sourceSignature);
                return this;
            }

            public VerificationResultAttestation build() {
                return new VerificationResultAttestation(b.build());
            }
        }
    }

    public static class VerificationResultPrimarySource extends FhirObject {
        public static final String RESOURCE_TYPE = "VerificationResultPrimarySource";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_WHO = "who";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_COMMUNICATIONMETHOD = "communicationMethod";
        public static final String PROPERTY_VALIDATIONSTATUS = "validationStatus";
        public static final String PROPERTY_VALIDATIONDATE = "validationDate";
        public static final String PROPERTY_CANPUSHUPDATES = "canPushUpdates";
        public static final String PROPERTY_PUSHTYPEAVAILABLE = "pushTypeAvailable";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public VerificationResultPrimarySource(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Reference to the primary source.
         */
        public Reference who() {
            return getObject(Reference.class, PROPERTY_WHO);
        }

        /**
         * Type of primary source (License Board; Primary Education; Continuing Education; Postal Service; Relationship owner; Registration Authority; legal source; issuing source; authoritative source).
         */
        public java.util.List<CodeableConcept> type() {
            return getList(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Method for communicating with the primary source (manual; API; Push).
         */
        public java.util.List<CodeableConcept> communicationMethod() {
            return getList(CodeableConcept.class, PROPERTY_COMMUNICATIONMETHOD);
        }

        /**
         * Status of the validation of the target against the primary source (successful; failed; unknown).
         */
        public CodeableConcept validationStatus() {
            return getObject(CodeableConcept.class, PROPERTY_VALIDATIONSTATUS);
        }

        /**
         * When the target was validated against the primary source.
         */
        public java.time.Instant validationDate() {
            return java.time.Instant.parse(data.getString(PROPERTY_VALIDATIONDATE));
        }

        /**
         * Ability of the primary source to push updates/alerts (yes; no; undetermined).
         */
        public CodeableConcept canPushUpdates() {
            return getObject(CodeableConcept.class, PROPERTY_CANPUSHUPDATES);
        }

        /**
         * Type of alerts/updates the primary source can send (specific requested changes; any changes; as defined by source).
         */
        public java.util.List<CodeableConcept> pushTypeAvailable() {
            return getList(CodeableConcept.class, PROPERTY_PUSHTYPEAVAILABLE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder who(final Reference who) {
                b.add(PROPERTY_WHO, who);
                return this;
            }

            public Builder type(final java.util.List<CodeableConcept> type) {
                b.add(PROPERTY_TYPE, FhirObject.toArray(type));
                return this;
            }

            public Builder communicationMethod(final java.util.List<CodeableConcept> communicationMethod) {
                b.add(PROPERTY_COMMUNICATIONMETHOD, FhirObject.toArray(communicationMethod));
                return this;
            }

            public Builder validationStatus(final CodeableConcept validationStatus) {
                b.add(PROPERTY_VALIDATIONSTATUS, validationStatus);
                return this;
            }

            public Builder validationDate(final java.time.Instant validationDate) {
                b.add(PROPERTY_VALIDATIONDATE, validationDate.toString());
                return this;
            }

            public Builder canPushUpdates(final CodeableConcept canPushUpdates) {
                b.add(PROPERTY_CANPUSHUPDATES, canPushUpdates);
                return this;
            }

            public Builder pushTypeAvailable(final java.util.List<CodeableConcept> pushTypeAvailable) {
                b.add(PROPERTY_PUSHTYPEAVAILABLE, FhirObject.toArray(pushTypeAvailable));
                return this;
            }

            public VerificationResultPrimarySource build() {
                return new VerificationResultPrimarySource(b.build());
            }
        }
    }

    public static class VerificationResultValidator extends FhirObject {
        public static final String RESOURCE_TYPE = "VerificationResultValidator";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_ORGANIZATION = "organization";
        public static final String PROPERTY_IDENTITYCERTIFICATE = "identityCertificate";
        public static final String PROPERTY_ATTESTATIONSIGNATURE = "attestationSignature";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public VerificationResultValidator(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Reference to the organization validating information.
         */
        public Reference organization() {
            return getObject(Reference.class, PROPERTY_ORGANIZATION);
        }

        /**
         * A digital identity certificate associated with the validator.
         */
        public String identityCertificate() {
            return getString(PROPERTY_IDENTITYCERTIFICATE);
        }

        /**
         * Signed assertion by the validator that they have validated the information.
         */
        public Signature attestationSignature() {
            return getObject(Signature.class, PROPERTY_ATTESTATIONSIGNATURE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder organization(final Reference organization) {
                b.add(PROPERTY_ORGANIZATION, organization);
                return this;
            }

            public Builder identityCertificate(final String identityCertificate) {
                b.add(PROPERTY_IDENTITYCERTIFICATE, identityCertificate);
                return this;
            }

            public Builder attestationSignature(final Signature attestationSignature) {
                b.add(PROPERTY_ATTESTATIONSIGNATURE, attestationSignature);
                return this;
            }

            public VerificationResultValidator build() {
                return new VerificationResultValidator(b.build());
            }
        }
    }
}
