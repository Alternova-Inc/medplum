/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class TerminologyCapabilities extends FhirResource {
    public static final String RESOURCE_TYPE = "TerminologyCapabilities";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_EXTENSION = "extension";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_URL = "url";
    public static final String PROPERTY_VERSION = "version";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_TITLE = "title";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_EXPERIMENTAL = "experimental";
    public static final String PROPERTY_DATE = "date";
    public static final String PROPERTY_PUBLISHER = "publisher";
    public static final String PROPERTY_CONTACT = "contact";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_USE_CONTEXT = "useContext";
    public static final String PROPERTY_JURISDICTION = "jurisdiction";
    public static final String PROPERTY_PURPOSE = "purpose";
    public static final String PROPERTY_COPYRIGHT = "copyright";
    public static final String PROPERTY_KIND = "kind";
    public static final String PROPERTY_SOFTWARE = "software";
    public static final String PROPERTY_IMPLEMENTATION = "implementation";
    public static final String PROPERTY_LOCKED_DATE = "lockedDate";
    public static final String PROPERTY_CODE_SYSTEM = "codeSystem";
    public static final String PROPERTY_EXPANSION = "expansion";
    public static final String PROPERTY_CODE_SEARCH = "codeSearch";
    public static final String PROPERTY_VALIDATE_CODE = "validateCode";
    public static final String PROPERTY_TRANSLATION = "translation";
    public static final String PROPERTY_CLOSURE = "closure";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public TerminologyCapabilities(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public java.net.URI implicitRules() {
        return getUri(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * An absolute URI that is used to identify this terminology capabilities
     * when it is referenced in a specification, model, design or an
     * instance; also called its canonical identifier. This SHOULD be
     * globally unique and SHOULD be a literal address at which at which an
     * authoritative instance of this terminology capabilities is (or will
     * be) published. This URL can be the target of a canonical reference. It
     * SHALL remain the same when the terminology capabilities is stored on
     * different servers.
     */
    public java.net.URI url() {
        return getUri(PROPERTY_URL);
    }

    /**
     * The identifier that is used to identify this version of the
     * terminology capabilities when it is referenced in a specification,
     * model, design or instance. This is an arbitrary value managed by the
     * terminology capabilities author and is not expected to be globally
     * unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
     * managed version is not available. There is also no expectation that
     * versions can be placed in a lexicographical sequence.
     */
    public String version() {
        return getString(PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the terminology capabilities. This
     * name should be usable as an identifier for the module by machine
     * processing applications such as code generation.
     */
    public String name() {
        return getString(PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the terminology
     * capabilities.
     */
    public String title() {
        return getString(PROPERTY_TITLE);
    }

    /**
     * The status of this terminology capabilities. Enables tracking the
     * life-cycle of the content.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this terminology capabilities is
     * authored for testing purposes (or education/evaluation/marketing) and
     * is not intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the terminology capabilities was
     * published. The date must change when the business version changes and
     * it must change if the status code changes. In addition, it should
     * change when the substantive content of the terminology capabilities
     * changes.
     */
    public java.time.Instant date() {
        return getInstant(PROPERTY_DATE);
    }

    /**
     * The name of the organization or individual that published the
     * terminology capabilities.
     */
    public String publisher() {
        return getString(PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the terminology
     * capabilities from a consumer's perspective. Typically, this is used
     * when the capability statement describes a desired rather than an
     * actual solution, for example as a formal expression of requirements as
     * part of an RFP.
     */
    public String description() {
        return getString(PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate terminology capabilities
     * instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the terminology capabilities is
     * intended to be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this terminology capabilities is needed and why it
     * has been designed as it has.
     */
    public String purpose() {
        return getString(PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the terminology capabilities and/or
     * its contents. Copyright statements are generally legal restrictions on
     * the use and publishing of the terminology capabilities.
     */
    public String copyright() {
        return getString(PROPERTY_COPYRIGHT);
    }

    /**
     * The way that this statement is intended to be used, to describe an
     * actual running instance of software, a particular product (kind, not
     * instance of software) or a class of implementation (e.g. a desired
     * purchase).
     */
    public String kind() {
        return getString(PROPERTY_KIND);
    }

    /**
     * Software that is covered by this terminology capability statement.  It
     * is used when the statement describes the capabilities of a particular
     * software version, independent of an installation.
     */
    public TerminologyCapabilitiesSoftware software() {
        return getObject(TerminologyCapabilitiesSoftware.class, PROPERTY_SOFTWARE);
    }

    /**
     * Identifies a specific implementation instance that is described by the
     * terminology capability statement - i.e. a particular installation,
     * rather than the capabilities of a software program.
     */
    public TerminologyCapabilitiesImplementation implementation() {
        return getObject(TerminologyCapabilitiesImplementation.class, PROPERTY_IMPLEMENTATION);
    }

    /**
     * Whether the server supports lockedDate.
     */
    public Boolean lockedDate() {
        return data.getBoolean(PROPERTY_LOCKED_DATE);
    }

    /**
     * Identifies a code system that is supported by the server. If there is
     * a no code system URL, then this declares the general assumptions a
     * client can make about support for any CodeSystem resource.
     */
    public java.util.List<TerminologyCapabilitiesCodeSystem> codeSystem() {
        return getList(TerminologyCapabilitiesCodeSystem.class, PROPERTY_CODE_SYSTEM);
    }

    /**
     * Information about the
     * [ValueSet/$expand](valueset-operation-expand.html) operation.
     */
    public TerminologyCapabilitiesExpansion expansion() {
        return getObject(TerminologyCapabilitiesExpansion.class, PROPERTY_EXPANSION);
    }

    /**
     * The degree to which the server supports the code search parameter on
     * ValueSet, if it is supported.
     */
    public String codeSearch() {
        return getString(PROPERTY_CODE_SEARCH);
    }

    /**
     * Information about the
     * [ValueSet/$validate-code](valueset-operation-validate-code.html)
     * operation.
     */
    public TerminologyCapabilitiesValidateCode validateCode() {
        return getObject(TerminologyCapabilitiesValidateCode.class, PROPERTY_VALIDATE_CODE);
    }

    /**
     * Information about the
     * [ConceptMap/$translate](conceptmap-operation-translate.html)
     * operation.
     */
    public TerminologyCapabilitiesTranslation translation() {
        return getObject(TerminologyCapabilitiesTranslation.class, PROPERTY_TRANSLATION);
    }

    /**
     * Whether the $closure operation is supported.
     */
    public TerminologyCapabilitiesClosure closure() {
        return getObject(TerminologyCapabilitiesClosure.class, PROPERTY_CLOSURE);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final java.net.URI implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules.toString());
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder url(final java.net.URI url) {
            b.add(PROPERTY_URL, url.toString());
            return this;
        }

        public Builder version(final String version) {
            b.add(PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder kind(final String kind) {
            b.add(PROPERTY_KIND, kind);
            return this;
        }

        public Builder software(final TerminologyCapabilitiesSoftware software) {
            b.add(PROPERTY_SOFTWARE, software);
            return this;
        }

        public Builder implementation(final TerminologyCapabilitiesImplementation implementation) {
            b.add(PROPERTY_IMPLEMENTATION, implementation);
            return this;
        }

        public Builder lockedDate(final Boolean lockedDate) {
            b.add(PROPERTY_LOCKED_DATE, lockedDate);
            return this;
        }

        public Builder codeSystem(final java.util.List<TerminologyCapabilitiesCodeSystem> codeSystem) {
            b.add(PROPERTY_CODE_SYSTEM, FhirObject.toArray(codeSystem));
            return this;
        }

        public Builder expansion(final TerminologyCapabilitiesExpansion expansion) {
            b.add(PROPERTY_EXPANSION, expansion);
            return this;
        }

        public Builder codeSearch(final String codeSearch) {
            b.add(PROPERTY_CODE_SEARCH, codeSearch);
            return this;
        }

        public Builder validateCode(final TerminologyCapabilitiesValidateCode validateCode) {
            b.add(PROPERTY_VALIDATE_CODE, validateCode);
            return this;
        }

        public Builder translation(final TerminologyCapabilitiesTranslation translation) {
            b.add(PROPERTY_TRANSLATION, translation);
            return this;
        }

        public Builder closure(final TerminologyCapabilitiesClosure closure) {
            b.add(PROPERTY_CLOSURE, closure);
            return this;
        }

        public TerminologyCapabilities build() {
            return new TerminologyCapabilities(b.build());
        }
    }

    public static class TerminologyCapabilitiesClosure extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesClosure";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TRANSLATION = "translation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesClosure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * If cross-system closure is supported.
         */
        public Boolean translation() {
            return data.getBoolean(PROPERTY_TRANSLATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder translation(final Boolean translation) {
                b.add(PROPERTY_TRANSLATION, translation);
                return this;
            }

            public TerminologyCapabilitiesClosure build() {
                return new TerminologyCapabilitiesClosure(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesCodeSystem extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesCodeSystem";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_URI = "uri";
        public static final String PROPERTY_VERSION = "version";
        public static final String PROPERTY_SUBSUMPTION = "subsumption";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesCodeSystem(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * URI for the Code System.
         */
        public String uri() {
            return getString(PROPERTY_URI);
        }

        /**
         * For the code system, a list of versions that are supported by the
         * server.
         */
        public java.util.List<TerminologyCapabilitiesVersion> version() {
            return getList(TerminologyCapabilitiesVersion.class, PROPERTY_VERSION);
        }

        /**
         * True if subsumption is supported for this version of the code system.
         */
        public Boolean subsumption() {
            return data.getBoolean(PROPERTY_SUBSUMPTION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder uri(final String uri) {
                b.add(PROPERTY_URI, uri);
                return this;
            }

            public Builder version(final java.util.List<TerminologyCapabilitiesVersion> version) {
                b.add(PROPERTY_VERSION, FhirObject.toArray(version));
                return this;
            }

            public Builder subsumption(final Boolean subsumption) {
                b.add(PROPERTY_SUBSUMPTION, subsumption);
                return this;
            }

            public TerminologyCapabilitiesCodeSystem build() {
                return new TerminologyCapabilitiesCodeSystem(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesExpansion extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesExpansion";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_HIERARCHICAL = "hierarchical";
        public static final String PROPERTY_PAGING = "paging";
        public static final String PROPERTY_INCOMPLETE = "incomplete";
        public static final String PROPERTY_PARAMETER = "parameter";
        public static final String PROPERTY_TEXT_FILTER = "textFilter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesExpansion(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether the server can return nested value sets.
         */
        public Boolean hierarchical() {
            return data.getBoolean(PROPERTY_HIERARCHICAL);
        }

        /**
         * Whether the server supports paging on expansion.
         */
        public Boolean paging() {
            return data.getBoolean(PROPERTY_PAGING);
        }

        /**
         * Allow request for incomplete expansions?
         */
        public Boolean incomplete() {
            return data.getBoolean(PROPERTY_INCOMPLETE);
        }

        /**
         * Supported expansion parameter.
         */
        public java.util.List<TerminologyCapabilitiesParameter> parameter() {
            return getList(TerminologyCapabilitiesParameter.class, PROPERTY_PARAMETER);
        }

        /**
         * Documentation about text searching works.
         */
        public String textFilter() {
            return getString(PROPERTY_TEXT_FILTER);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder hierarchical(final Boolean hierarchical) {
                b.add(PROPERTY_HIERARCHICAL, hierarchical);
                return this;
            }

            public Builder paging(final Boolean paging) {
                b.add(PROPERTY_PAGING, paging);
                return this;
            }

            public Builder incomplete(final Boolean incomplete) {
                b.add(PROPERTY_INCOMPLETE, incomplete);
                return this;
            }

            public Builder parameter(final java.util.List<TerminologyCapabilitiesParameter> parameter) {
                b.add(PROPERTY_PARAMETER, FhirObject.toArray(parameter));
                return this;
            }

            public Builder textFilter(final String textFilter) {
                b.add(PROPERTY_TEXT_FILTER, textFilter);
                return this;
            }

            public TerminologyCapabilitiesExpansion build() {
                return new TerminologyCapabilitiesExpansion(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesFilter extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesFilter";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_OP = "op";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesFilter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Code of the property supported.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * Operations supported for the property.
         */
        public java.util.List<String> op() {
            return getList(String.class, PROPERTY_OP);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder op(final java.util.List<String> op) {
                b.add(PROPERTY_OP, FhirObject.toStringArray(op));
                return this;
            }

            public TerminologyCapabilitiesFilter build() {
                return new TerminologyCapabilitiesFilter(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesImplementation extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesImplementation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_URL = "url";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesImplementation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about the specific installation that this terminology
         * capability statement relates to.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * An absolute base URL for the implementation.
         */
        public java.net.URI url() {
            return getUri(PROPERTY_URL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder url(final java.net.URI url) {
                b.add(PROPERTY_URL, url.toString());
                return this;
            }

            public TerminologyCapabilitiesImplementation build() {
                return new TerminologyCapabilitiesImplementation(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesParameter extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesParameter";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_DOCUMENTATION = "documentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesParameter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Expansion Parameter name.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * Description of support for parameter.
         */
        public String documentation() {
            return getString(PROPERTY_DOCUMENTATION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public TerminologyCapabilitiesParameter build() {
                return new TerminologyCapabilitiesParameter(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesSoftware extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesSoftware";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NAME = "name";
        public static final String PROPERTY_VERSION = "version";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesSoftware(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name the software is known by.
         */
        public String name() {
            return getString(PROPERTY_NAME);
        }

        /**
         * The version identifier for the software covered by this statement.
         */
        public String version() {
            return getString(PROPERTY_VERSION);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(PROPERTY_NAME, name);
                return this;
            }

            public Builder version(final String version) {
                b.add(PROPERTY_VERSION, version);
                return this;
            }

            public TerminologyCapabilitiesSoftware build() {
                return new TerminologyCapabilitiesSoftware(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesTranslation extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesTranslation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_NEEDS_MAP = "needsMap";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesTranslation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether the client must identify the map.
         */
        public Boolean needsMap() {
            return data.getBoolean(PROPERTY_NEEDS_MAP);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder needsMap(final Boolean needsMap) {
                b.add(PROPERTY_NEEDS_MAP, needsMap);
                return this;
            }

            public TerminologyCapabilitiesTranslation build() {
                return new TerminologyCapabilitiesTranslation(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesValidateCode extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesValidateCode";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_TRANSLATIONS = "translations";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesValidateCode(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether translations are validated.
         */
        public Boolean translations() {
            return data.getBoolean(PROPERTY_TRANSLATIONS);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder translations(final Boolean translations) {
                b.add(PROPERTY_TRANSLATIONS, translations);
                return this;
            }

            public TerminologyCapabilitiesValidateCode build() {
                return new TerminologyCapabilitiesValidateCode(b.build());
            }
        }
    }

    public static class TerminologyCapabilitiesVersion extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesVersion";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_EXTENSION = "extension";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_IS_DEFAULT = "isDefault";
        public static final String PROPERTY_COMPOSITIONAL = "compositional";
        public static final String PROPERTY_LANGUAGE = "language";
        public static final String PROPERTY_FILTER = "filter";
        public static final String PROPERTY_PROPERTY = "property";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesVersion(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * For version-less code systems, there should be a single version with
         * no identifier.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * If this is the default version for this code system.
         */
        public Boolean isDefault() {
            return data.getBoolean(PROPERTY_IS_DEFAULT);
        }

        /**
         * If the compositional grammar defined by the code system is supported.
         */
        public Boolean compositional() {
            return data.getBoolean(PROPERTY_COMPOSITIONAL);
        }

        /**
         * Language Displays supported.
         */
        public java.util.List<String> language() {
            return getList(String.class, PROPERTY_LANGUAGE);
        }

        /**
         * Filter Properties supported.
         */
        public java.util.List<TerminologyCapabilitiesFilter> filter() {
            return getList(TerminologyCapabilitiesFilter.class, PROPERTY_FILTER);
        }

        /**
         * Properties supported for $lookup.
         */
        public java.util.List<String> property() {
            return getList(String.class, PROPERTY_PROPERTY);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder isDefault(final Boolean isDefault) {
                b.add(PROPERTY_IS_DEFAULT, isDefault);
                return this;
            }

            public Builder compositional(final Boolean compositional) {
                b.add(PROPERTY_COMPOSITIONAL, compositional);
                return this;
            }

            public Builder language(final java.util.List<String> language) {
                b.add(PROPERTY_LANGUAGE, FhirObject.toStringArray(language));
                return this;
            }

            public Builder filter(final java.util.List<TerminologyCapabilitiesFilter> filter) {
                b.add(PROPERTY_FILTER, FhirObject.toArray(filter));
                return this;
            }

            public Builder property(final java.util.List<String> property) {
                b.add(PROPERTY_PROPERTY, FhirObject.toStringArray(property));
                return this;
            }

            public TerminologyCapabilitiesVersion build() {
                return new TerminologyCapabilitiesVersion(b.build());
            }
        }
    }
}
