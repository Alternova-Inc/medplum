/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class CodeSystem extends FhirResource {
    public static final String RESOURCE_TYPE = "CodeSystem";
    public static final String PROPERTY_RESOURCE_TYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICIT_RULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
    public static final String PROPERTY_URL = "url";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_VERSION = "version";
    public static final String PROPERTY_NAME = "name";
    public static final String PROPERTY_TITLE = "title";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_EXPERIMENTAL = "experimental";
    public static final String PROPERTY_DATE = "date";
    public static final String PROPERTY_PUBLISHER = "publisher";
    public static final String PROPERTY_CONTACT = "contact";
    public static final String PROPERTY_DESCRIPTION = "description";
    public static final String PROPERTY_USE_CONTEXT = "useContext";
    public static final String PROPERTY_JURISDICTION = "jurisdiction";
    public static final String PROPERTY_PURPOSE = "purpose";
    public static final String PROPERTY_COPYRIGHT = "copyright";
    public static final String PROPERTY_CASE_SENSITIVE = "caseSensitive";
    public static final String PROPERTY_VALUE_SET = "valueSet";
    public static final String PROPERTY_HIERARCHY_MEANING = "hierarchyMeaning";
    public static final String PROPERTY_COMPOSITIONAL = "compositional";
    public static final String PROPERTY_VERSION_NEEDED = "versionNeeded";
    public static final String PROPERTY_CONTENT = "content";
    public static final String PROPERTY_SUPPLEMENTS = "supplements";
    public static final String PROPERTY_COUNT = "count";
    public static final String PROPERTY_FILTER = "filter";
    public static final String PROPERTY_PROPERTY = "property";
    public static final String PROPERTY_CONCEPT = "concept";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public CodeSystem(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was
     * constructed, and which must be understood when processing the content.
     * Often, this is a reference to an implementation guide that defines the
     * special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICIT_RULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and
     * can be used to represent the content of the resource to a human. The
     * narrative need not encode all the structured data, but is required to
     * contain sufficient detail to make it &quot;clinically safe&quot; for a human to
     * just read the narrative. Resource definitions may define what content
     * should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the
     * resource that contains them - they cannot be identified independently,
     * and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the resource and that modifies the
     * understanding of the element that contains it and/or the understanding
     * of the containing element's descendants. Usually modifier elements
     * provide negation or qualification. To make the use of extensions safe
     * and manageable, there is a strict set of governance applied to the
     * definition and use of extensions. Though any implementer is allowed to
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension. Applications processing a
     * resource are required to check for modifier extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * An absolute URI that is used to identify this code system when it is
     * referenced in a specification, model, design or an instance; also
     * called its canonical identifier. This SHOULD be globally unique and
     * SHOULD be a literal address at which at which an authoritative
     * instance of this code system is (or will be) published. This URL can
     * be the target of a canonical reference. It SHALL remain the same when
     * the code system is stored on different servers. This is used in
     * [Coding](datatypes.html#Coding).system.
     */
    public String url() {
        return getString(PROPERTY_URL);
    }

    /**
     * A formal identifier that is used to identify this code system when it
     * is represented in other formats, or referenced in a specification,
     * model, design or an instance.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * The identifier that is used to identify this version of the code
     * system when it is referenced in a specification, model, design or
     * instance. This is an arbitrary value managed by the code system author
     * and is not expected to be globally unique. For example, it might be a
     * timestamp (e.g. yyyymmdd) if a managed version is not available. There
     * is also no expectation that versions can be placed in a
     * lexicographical sequence. This is used in
     * [Coding](datatypes.html#Coding).version.
     */
    public String version() {
        return getString(PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the code system. This name should
     * be usable as an identifier for the module by machine processing
     * applications such as code generation.
     */
    public String name() {
        return getString(PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the code system.
     */
    public String title() {
        return getString(PROPERTY_TITLE);
    }

    /**
     * The date (and optionally time) when the code system resource was
     * created or revised.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this code system is authored for
     * testing purposes (or education/evaluation/marketing) and is not
     * intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the code system was published.
     * The date must change when the business version changes and it must
     * change if the status code changes. In addition, it should change when
     * the substantive content of the code system changes.
     */
    public java.time.Instant date() {
        return java.time.Instant.parse(data.getString(PROPERTY_DATE));
    }

    /**
     * The name of the organization or individual that published the code
     * system.
     */
    public String publisher() {
        return getString(PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the code system from a
     * consumer's perspective.
     */
    public String description() {
        return getString(PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate code system instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the code system is intended to
     * be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this code system is needed and why it has been
     * designed as it has.
     */
    public String purpose() {
        return getString(PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the code system and/or its contents.
     * Copyright statements are generally legal restrictions on the use and
     * publishing of the code system.
     */
    public String copyright() {
        return getString(PROPERTY_COPYRIGHT);
    }

    /**
     * If code comparison is case sensitive when codes within this system are
     * compared to each other.
     */
    public Boolean caseSensitive() {
        return data.getBoolean(PROPERTY_CASE_SENSITIVE);
    }

    /**
     * Canonical reference to the value set that contains the entire code
     * system.
     */
    public String valueSet() {
        return getString(PROPERTY_VALUE_SET);
    }

    /**
     * The meaning of the hierarchy of concepts as represented in this
     * resource.
     */
    public String hierarchyMeaning() {
        return getString(PROPERTY_HIERARCHY_MEANING);
    }

    /**
     * The code system defines a compositional (post-coordination) grammar.
     */
    public Boolean compositional() {
        return data.getBoolean(PROPERTY_COMPOSITIONAL);
    }

    /**
     * This flag is used to signify that the code system does not commit to
     * concept permanence across versions. If true, a version must be
     * specified when referencing this code system.
     */
    public Boolean versionNeeded() {
        return data.getBoolean(PROPERTY_VERSION_NEEDED);
    }

    /**
     * The extent of the content of the code system (the concepts and codes
     * it defines) are represented in this resource instance.
     */
    public String content() {
        return getString(PROPERTY_CONTENT);
    }

    /**
     * The canonical URL of the code system that this code system supplement
     * is adding designations and properties to.
     */
    public String supplements() {
        return getString(PROPERTY_SUPPLEMENTS);
    }

    /**
     * The total number of concepts defined by the code system. Where the
     * code system has a compositional grammar, the basis of this count is
     * defined by the system steward.
     */
    public Integer count() {
        return data.getInt(PROPERTY_COUNT);
    }

    /**
     * A filter that can be used in a value set compose statement when
     * selecting concepts using a filter.
     */
    public java.util.List<CodeSystemFilter> filter() {
        return getList(CodeSystemFilter.class, PROPERTY_FILTER);
    }

    /**
     * A property defines an additional slot through which additional
     * information can be provided about a concept.
     */
    public java.util.List<CodeSystemProperty> property() {
        return getList(CodeSystemProperty.class, PROPERTY_PROPERTY);
    }

    /**
     * Concepts that are in the code system. The concept definitions are
     * inherently hierarchical, but the definitions must be consulted to
     * determine what the meanings of the hierarchical relationships are.
     */
    public java.util.List<CodeSystemConcept> concept() {
        return getList(CodeSystemConcept.class, PROPERTY_CONCEPT);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCE_TYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICIT_RULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder url(final String url) {
            b.add(PROPERTY_URL, url);
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder version(final String version) {
            b.add(PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder caseSensitive(final Boolean caseSensitive) {
            b.add(PROPERTY_CASE_SENSITIVE, caseSensitive);
            return this;
        }

        public Builder valueSet(final String valueSet) {
            b.add(PROPERTY_VALUE_SET, valueSet);
            return this;
        }

        public Builder hierarchyMeaning(final String hierarchyMeaning) {
            b.add(PROPERTY_HIERARCHY_MEANING, hierarchyMeaning);
            return this;
        }

        public Builder compositional(final Boolean compositional) {
            b.add(PROPERTY_COMPOSITIONAL, compositional);
            return this;
        }

        public Builder versionNeeded(final Boolean versionNeeded) {
            b.add(PROPERTY_VERSION_NEEDED, versionNeeded);
            return this;
        }

        public Builder content(final String content) {
            b.add(PROPERTY_CONTENT, content);
            return this;
        }

        public Builder supplements(final String supplements) {
            b.add(PROPERTY_SUPPLEMENTS, supplements);
            return this;
        }

        public Builder count(final Integer count) {
            b.add(PROPERTY_COUNT, count);
            return this;
        }

        public Builder filter(final java.util.List<CodeSystemFilter> filter) {
            b.add(PROPERTY_FILTER, FhirObject.toArray(filter));
            return this;
        }

        public Builder property(final java.util.List<CodeSystemProperty> property) {
            b.add(PROPERTY_PROPERTY, FhirObject.toArray(property));
            return this;
        }

        public Builder concept(final java.util.List<CodeSystemConcept> concept) {
            b.add(PROPERTY_CONCEPT, FhirObject.toArray(concept));
            return this;
        }

        public CodeSystem build() {
            return new CodeSystem(b.build());
        }
    }

    public static class CodeSystemConcept extends FhirObject {
        public static final String RESOURCE_TYPE = "CodeSystemConcept";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_DISPLAY = "display";
        public static final String PROPERTY_DEFINITION = "definition";
        public static final String PROPERTY_DESIGNATION = "designation";
        public static final String PROPERTY_PROPERTY = "property";
        public static final String PROPERTY_CONCEPT = "concept";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CodeSystemConcept(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A code - a text symbol - that uniquely identifies the concept within
         * the code system.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * A human readable string that is the recommended default way to present
         * this concept to a user.
         */
        public String display() {
            return getString(PROPERTY_DISPLAY);
        }

        /**
         * The formal definition of the concept. The code system resource does
         * not make formal definitions required, because of the prevalence of
         * legacy systems. However, they are highly recommended, as without them
         * there is no formal meaning associated with the concept.
         */
        public String definition() {
            return getString(PROPERTY_DEFINITION);
        }

        /**
         * Additional representations for the concept - other languages, aliases,
         * specialized purposes, used for particular purposes, etc.
         */
        public java.util.List<CodeSystemDesignation> designation() {
            return getList(CodeSystemDesignation.class, PROPERTY_DESIGNATION);
        }

        /**
         * A property value for this concept.
         */
        public java.util.List<CodeSystemProperty1> property() {
            return getList(CodeSystemProperty1.class, PROPERTY_PROPERTY);
        }

        /**
         * Defines children of a concept to produce a hierarchy of concepts. The
         * nature of the relationships is variable (is-a/contains/categorizes) -
         * see hierarchyMeaning.
         */
        public java.util.List<CodeSystemConcept> concept() {
            return getList(CodeSystemConcept.class, PROPERTY_CONCEPT);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder display(final String display) {
                b.add(PROPERTY_DISPLAY, display);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(PROPERTY_DEFINITION, definition);
                return this;
            }

            public Builder designation(final java.util.List<CodeSystemDesignation> designation) {
                b.add(PROPERTY_DESIGNATION, FhirObject.toArray(designation));
                return this;
            }

            public Builder property(final java.util.List<CodeSystemProperty1> property) {
                b.add(PROPERTY_PROPERTY, FhirObject.toArray(property));
                return this;
            }

            public Builder concept(final java.util.List<CodeSystemConcept> concept) {
                b.add(PROPERTY_CONCEPT, FhirObject.toArray(concept));
                return this;
            }

            public CodeSystemConcept build() {
                return new CodeSystemConcept(b.build());
            }
        }
    }

    public static class CodeSystemDesignation extends FhirObject {
        public static final String RESOURCE_TYPE = "CodeSystemDesignation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_LANGUAGE = "language";
        public static final String PROPERTY_USE = "use";
        public static final String PROPERTY_VALUE = "value";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CodeSystemDesignation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The language this designation is defined for.
         */
        public String language() {
            return getString(PROPERTY_LANGUAGE);
        }

        /**
         * A code that details how this designation would be used.
         */
        public Coding use() {
            return getObject(Coding.class, PROPERTY_USE);
        }

        /**
         * The text value for this designation.
         */
        public String value() {
            return getString(PROPERTY_VALUE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder language(final String language) {
                b.add(PROPERTY_LANGUAGE, language);
                return this;
            }

            public Builder use(final Coding use) {
                b.add(PROPERTY_USE, use);
                return this;
            }

            public Builder value(final String value) {
                b.add(PROPERTY_VALUE, value);
                return this;
            }

            public CodeSystemDesignation build() {
                return new CodeSystemDesignation(b.build());
            }
        }
    }

    public static class CodeSystemFilter extends FhirObject {
        public static final String RESOURCE_TYPE = "CodeSystemFilter";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_OPERATOR = "operator";
        public static final String PROPERTY_VALUE = "value";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CodeSystemFilter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The code that identifies this filter when it is used as a filter in
         * [[[ValueSet]]].compose.include.filter.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * A description of how or why the filter is used.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * A list of operators that can be used with the filter.
         */
        public java.util.List<String> operator() {
            return getList(String.class, PROPERTY_OPERATOR);
        }

        /**
         * A description of what the value for the filter should be.
         */
        public String value() {
            return getString(PROPERTY_VALUE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder operator(final java.util.List<String> operator) {
                b.add(PROPERTY_OPERATOR, FhirObject.toStringArray(operator));
                return this;
            }

            public Builder value(final String value) {
                b.add(PROPERTY_VALUE, value);
                return this;
            }

            public CodeSystemFilter build() {
                return new CodeSystemFilter(b.build());
            }
        }
    }

    public static class CodeSystemProperty extends FhirObject {
        public static final String RESOURCE_TYPE = "CodeSystemProperty";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_URI = "uri";
        public static final String PROPERTY_DESCRIPTION = "description";
        public static final String PROPERTY_TYPE = "type";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CodeSystemProperty(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A code that is used to identify the property. The code is used
         * internally (in CodeSystem.concept.property.code) and also externally,
         * such as in property filters.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * Reference to the formal meaning of the property. One possible source
         * of meaning is the [Concept
         * Properties](codesystem-concept-properties.html) code system.
         */
        public String uri() {
            return getString(PROPERTY_URI);
        }

        /**
         * A description of the property- why it is defined, and how its value
         * might be used.
         */
        public String description() {
            return getString(PROPERTY_DESCRIPTION);
        }

        /**
         * The type of the property value. Properties of type &quot;code&quot; contain a
         * code defined by the code system (e.g. a reference to another defined
         * concept).
         */
        public String type() {
            return getString(PROPERTY_TYPE);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder uri(final String uri) {
                b.add(PROPERTY_URI, uri);
                return this;
            }

            public Builder description(final String description) {
                b.add(PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder type(final String type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public CodeSystemProperty build() {
                return new CodeSystemProperty(b.build());
            }
        }
    }

    public static class CodeSystemProperty1 extends FhirObject {
        public static final String RESOURCE_TYPE = "CodeSystemProperty1";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIER_EXTENSION = "modifierExtension";
        public static final String PROPERTY_CODE = "code";
        public static final String PROPERTY_VALUE_CODE = "valueCode";
        public static final String PROPERTY_VALUE_CODING = "valueCoding";
        public static final String PROPERTY_VALUE_STRING = "valueString";
        public static final String PROPERTY_VALUE_INTEGER = "valueInteger";
        public static final String PROPERTY_VALUE_BOOLEAN = "valueBoolean";
        public static final String PROPERTY_VALUE_DATE_TIME = "valueDateTime";
        public static final String PROPERTY_VALUE_DECIMAL = "valueDecimal";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CodeSystemProperty1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A code that is a reference to CodeSystem.property.code.
         */
        public String code() {
            return getString(PROPERTY_CODE);
        }

        /**
         * The value of this property.
         */
        public String valueCode() {
            return getString(PROPERTY_VALUE_CODE);
        }

        /**
         * The value of this property.
         */
        public Coding valueCoding() {
            return getObject(Coding.class, PROPERTY_VALUE_CODING);
        }

        /**
         * The value of this property.
         */
        public String valueString() {
            return getString(PROPERTY_VALUE_STRING);
        }

        /**
         * The value of this property.
         */
        public Integer valueInteger() {
            return data.getInt(PROPERTY_VALUE_INTEGER);
        }

        /**
         * The value of this property.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(PROPERTY_VALUE_BOOLEAN);
        }

        /**
         * The value of this property.
         */
        public String valueDateTime() {
            return getString(PROPERTY_VALUE_DATE_TIME);
        }

        /**
         * The value of this property.
         */
        public Integer valueDecimal() {
            return data.getInt(PROPERTY_VALUE_DECIMAL);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(PROPERTY_CODE, code);
                return this;
            }

            public Builder valueCode(final String valueCode) {
                b.add(PROPERTY_VALUE_CODE, valueCode);
                return this;
            }

            public Builder valueCoding(final Coding valueCoding) {
                b.add(PROPERTY_VALUE_CODING, valueCoding);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(PROPERTY_VALUE_STRING, valueString);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(PROPERTY_VALUE_INTEGER, valueInteger);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(PROPERTY_VALUE_BOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueDateTime(final String valueDateTime) {
                b.add(PROPERTY_VALUE_DATE_TIME, valueDateTime);
                return this;
            }

            public Builder valueDecimal(final Integer valueDecimal) {
                b.add(PROPERTY_VALUE_DECIMAL, valueDecimal);
                return this;
            }

            public CodeSystemProperty1 build() {
                return new CodeSystemProperty1(b.build());
            }
        }
    }
}
