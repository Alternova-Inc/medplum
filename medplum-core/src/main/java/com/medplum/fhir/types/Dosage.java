/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class Dosage extends FhirResource {
    public static final String RESOURCE_TYPE = "Dosage";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_SEQUENCE = "sequence";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_ADDITIONALINSTRUCTION = "additionalInstruction";
    public static final String PROPERTY_PATIENTINSTRUCTION = "patientInstruction";
    public static final String PROPERTY_TIMING = "timing";
    public static final String PROPERTY_ASNEEDEDBOOLEAN = "asNeededBoolean";
    public static final String PROPERTY_ASNEEDEDCODEABLECONCEPT = "asNeededCodeableConcept";
    public static final String PROPERTY_SITE = "site";
    public static final String PROPERTY_ROUTE = "route";
    public static final String PROPERTY_METHOD = "method";
    public static final String PROPERTY_DOSEANDRATE = "doseAndRate";
    public static final String PROPERTY_MAXDOSEPERPERIOD = "maxDosePerPeriod";
    public static final String PROPERTY_MAXDOSEPERADMINISTRATION = "maxDosePerAdministration";
    public static final String PROPERTY_MAXDOSEPERLIFETIME = "maxDosePerLifetime";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Dosage(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * Indicates the order in which the dosage instructions should be applied or interpreted.
     */
    public Integer sequence() {
        return data.getInt(PROPERTY_SEQUENCE);
    }

    /**
     * Free text dosage instructions e.g. SIG.
     */
    public String text() {
        return getString(PROPERTY_TEXT);
    }

    /**
     * Supplemental instructions to the patient on how to take the medication  (e.g. "with meals" or"take half to one hour before food") or warnings for the patient about the medication (e.g. "may cause drowsiness" or "avoid exposure of skin to direct sunlight or sunlamps").
     */
    public java.util.List<CodeableConcept> additionalInstruction() {
        return getList(CodeableConcept.class, PROPERTY_ADDITIONALINSTRUCTION);
    }

    /**
     * Instructions in terms that are understood by the patient or consumer.
     */
    public String patientInstruction() {
        return getString(PROPERTY_PATIENTINSTRUCTION);
    }

    /**
     * When medication should be administered.
     */
    public Timing timing() {
        return getObject(Timing.class, PROPERTY_TIMING);
    }

    /**
     * Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
     */
    public Boolean asNeededBoolean() {
        return data.getBoolean(PROPERTY_ASNEEDEDBOOLEAN);
    }

    /**
     * Indicates whether the Medication is only taken when needed within a specific dosing schedule (Boolean option), or it indicates the precondition for taking the Medication (CodeableConcept).
     */
    public CodeableConcept asNeededCodeableConcept() {
        return getObject(CodeableConcept.class, PROPERTY_ASNEEDEDCODEABLECONCEPT);
    }

    /**
     * Body site to administer to.
     */
    public CodeableConcept site() {
        return getObject(CodeableConcept.class, PROPERTY_SITE);
    }

    /**
     * How drug should enter body.
     */
    public CodeableConcept route() {
        return getObject(CodeableConcept.class, PROPERTY_ROUTE);
    }

    /**
     * Technique for administering medication.
     */
    public CodeableConcept method() {
        return getObject(CodeableConcept.class, PROPERTY_METHOD);
    }

    /**
     * The amount of medication administered.
     */
    public java.util.List<DosageDoseAndRate> doseAndRate() {
        return getList(DosageDoseAndRate.class, PROPERTY_DOSEANDRATE);
    }

    /**
     * Upper limit on medication per unit of time.
     */
    public Ratio maxDosePerPeriod() {
        return getObject(Ratio.class, PROPERTY_MAXDOSEPERPERIOD);
    }

    /**
     * Upper limit on medication per administration.
     */
    public Quantity maxDosePerAdministration() {
        return getObject(Quantity.class, PROPERTY_MAXDOSEPERADMINISTRATION);
    }

    /**
     * Upper limit on medication per lifetime of the patient.
     */
    public Quantity maxDosePerLifetime() {
        return getObject(Quantity.class, PROPERTY_MAXDOSEPERLIFETIME);
    }

    public static class Builder {
        private final JsonObjectBuilder b;

        private Builder() {
            b = Json.createObjectBuilder();
        }

        private Builder(final JsonObject data) {
            b = Json.createObjectBuilder(data);
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder sequence(final Integer sequence) {
            b.add(PROPERTY_SEQUENCE, sequence);
            return this;
        }

        public Builder text(final String text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder additionalInstruction(final java.util.List<CodeableConcept> additionalInstruction) {
            b.add(PROPERTY_ADDITIONALINSTRUCTION, FhirObject.toArray(additionalInstruction));
            return this;
        }

        public Builder patientInstruction(final String patientInstruction) {
            b.add(PROPERTY_PATIENTINSTRUCTION, patientInstruction);
            return this;
        }

        public Builder timing(final Timing timing) {
            b.add(PROPERTY_TIMING, timing);
            return this;
        }

        public Builder asNeededBoolean(final Boolean asNeededBoolean) {
            b.add(PROPERTY_ASNEEDEDBOOLEAN, asNeededBoolean);
            return this;
        }

        public Builder asNeededCodeableConcept(final CodeableConcept asNeededCodeableConcept) {
            b.add(PROPERTY_ASNEEDEDCODEABLECONCEPT, asNeededCodeableConcept);
            return this;
        }

        public Builder site(final CodeableConcept site) {
            b.add(PROPERTY_SITE, site);
            return this;
        }

        public Builder route(final CodeableConcept route) {
            b.add(PROPERTY_ROUTE, route);
            return this;
        }

        public Builder method(final CodeableConcept method) {
            b.add(PROPERTY_METHOD, method);
            return this;
        }

        public Builder doseAndRate(final java.util.List<DosageDoseAndRate> doseAndRate) {
            b.add(PROPERTY_DOSEANDRATE, FhirObject.toArray(doseAndRate));
            return this;
        }

        public Builder maxDosePerPeriod(final Ratio maxDosePerPeriod) {
            b.add(PROPERTY_MAXDOSEPERPERIOD, maxDosePerPeriod);
            return this;
        }

        public Builder maxDosePerAdministration(final Quantity maxDosePerAdministration) {
            b.add(PROPERTY_MAXDOSEPERADMINISTRATION, maxDosePerAdministration);
            return this;
        }

        public Builder maxDosePerLifetime(final Quantity maxDosePerLifetime) {
            b.add(PROPERTY_MAXDOSEPERLIFETIME, maxDosePerLifetime);
            return this;
        }

        public Dosage build() {
            return new Dosage(b.build());
        }
    }

    public static class DosageDoseAndRate extends FhirObject {
        public static final String RESOURCE_TYPE = "DosageDoseAndRate";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_TYPE = "type";
        public static final String PROPERTY_DOSERANGE = "doseRange";
        public static final String PROPERTY_DOSEQUANTITY = "doseQuantity";
        public static final String PROPERTY_RATERATIO = "rateRatio";
        public static final String PROPERTY_RATERANGE = "rateRange";
        public static final String PROPERTY_RATEQUANTITY = "rateQuantity";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DosageDoseAndRate(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * The kind of dose or rate specified, for example, ordered or calculated.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, PROPERTY_TYPE);
        }

        /**
         * Amount of medication per dose.
         */
        public Range doseRange() {
            return getObject(Range.class, PROPERTY_DOSERANGE);
        }

        /**
         * Amount of medication per dose.
         */
        public Quantity doseQuantity() {
            return getObject(Quantity.class, PROPERTY_DOSEQUANTITY);
        }

        /**
         * Amount of medication per unit of time.
         */
        public Ratio rateRatio() {
            return getObject(Ratio.class, PROPERTY_RATERATIO);
        }

        /**
         * Amount of medication per unit of time.
         */
        public Range rateRange() {
            return getObject(Range.class, PROPERTY_RATERANGE);
        }

        /**
         * Amount of medication per unit of time.
         */
        public Quantity rateQuantity() {
            return getObject(Quantity.class, PROPERTY_RATEQUANTITY);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(PROPERTY_TYPE, type);
                return this;
            }

            public Builder doseRange(final Range doseRange) {
                b.add(PROPERTY_DOSERANGE, doseRange);
                return this;
            }

            public Builder doseQuantity(final Quantity doseQuantity) {
                b.add(PROPERTY_DOSEQUANTITY, doseQuantity);
                return this;
            }

            public Builder rateRatio(final Ratio rateRatio) {
                b.add(PROPERTY_RATERATIO, rateRatio);
                return this;
            }

            public Builder rateRange(final Range rateRange) {
                b.add(PROPERTY_RATERANGE, rateRange);
                return this;
            }

            public Builder rateQuantity(final Quantity rateQuantity) {
                b.add(PROPERTY_RATEQUANTITY, rateQuantity);
                return this;
            }

            public DosageDoseAndRate build() {
                return new DosageDoseAndRate(b.build());
            }
        }
    }
}
