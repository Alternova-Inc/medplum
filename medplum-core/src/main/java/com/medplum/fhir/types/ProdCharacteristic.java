/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class ProdCharacteristic extends FhirResource {
    public static final String RESOURCE_TYPE = "ProdCharacteristic";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_HEIGHT = "height";
    public static final String PROPERTY_WIDTH = "width";
    public static final String PROPERTY_DEPTH = "depth";
    public static final String PROPERTY_WEIGHT = "weight";
    public static final String PROPERTY_NOMINALVOLUME = "nominalVolume";
    public static final String PROPERTY_EXTERNALDIAMETER = "externalDiameter";
    public static final String PROPERTY_SHAPE = "shape";
    public static final String PROPERTY_COLOR = "color";
    public static final String PROPERTY_IMPRINT = "imprint";
    public static final String PROPERTY_IMAGE = "image";
    public static final String PROPERTY_SCORING = "scoring";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public ProdCharacteristic(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element and that modifies the
     * understanding of the element in which it is contained and/or the
     * understanding of the containing element's descendants. Usually
     * modifier elements provide negation or qualification. To make the use
     * of extensions safe and manageable, there is a strict set of governance
     * applied to the definition and use of extensions. Though any
     * implementer can define an extension, there is a set of requirements
     * that SHALL be met as part of the definition of the extension.
     * Applications processing a resource are required to check for modifier
     * extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * Where applicable, the height can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity height() {
        return getObject(Quantity.class, PROPERTY_HEIGHT);
    }

    /**
     * Where applicable, the width can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity width() {
        return getObject(Quantity.class, PROPERTY_WIDTH);
    }

    /**
     * Where applicable, the depth can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity depth() {
        return getObject(Quantity.class, PROPERTY_DEPTH);
    }

    /**
     * Where applicable, the weight can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity weight() {
        return getObject(Quantity.class, PROPERTY_WEIGHT);
    }

    /**
     * Where applicable, the nominal volume can be specified using a
     * numerical value and its unit of measurement The unit of measurement
     * shall be specified in accordance with ISO 11240 and the resulting
     * terminology The symbol and the symbol identifier shall be used.
     */
    public Quantity nominalVolume() {
        return getObject(Quantity.class, PROPERTY_NOMINALVOLUME);
    }

    /**
     * Where applicable, the external diameter can be specified using a
     * numerical value and its unit of measurement The unit of measurement
     * shall be specified in accordance with ISO 11240 and the resulting
     * terminology The symbol and the symbol identifier shall be used.
     */
    public Quantity externalDiameter() {
        return getObject(Quantity.class, PROPERTY_EXTERNALDIAMETER);
    }

    /**
     * Where applicable, the shape can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be
     * used.
     */
    public String shape() {
        return getString(PROPERTY_SHAPE);
    }

    /**
     * Where applicable, the color can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be
     * used.
     */
    public java.util.List<String> color() {
        return getList(String.class, PROPERTY_COLOR);
    }

    /**
     * Where applicable, the imprint can be specified as text.
     */
    public java.util.List<String> imprint() {
        return getList(String.class, PROPERTY_IMPRINT);
    }

    /**
     * Where applicable, the image can be provided The format of the image
     * attachment shall be specified by regional implementations.
     */
    public java.util.List<Attachment> image() {
        return getList(Attachment.class, PROPERTY_IMAGE);
    }

    /**
     * Where applicable, the scoring can be specified An appropriate
     * controlled vocabulary shall be used The term and the term identifier
     * shall be used.
     */
    public CodeableConcept scoring() {
        return getObject(CodeableConcept.class, PROPERTY_SCORING);
    }

    public static class Builder {
        private final JsonObjectBuilder b;

        private Builder() {
            b = Json.createObjectBuilder();
        }

        private Builder(final JsonObject data) {
            b = Json.createObjectBuilder(data);
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder height(final Quantity height) {
            b.add(PROPERTY_HEIGHT, height);
            return this;
        }

        public Builder width(final Quantity width) {
            b.add(PROPERTY_WIDTH, width);
            return this;
        }

        public Builder depth(final Quantity depth) {
            b.add(PROPERTY_DEPTH, depth);
            return this;
        }

        public Builder weight(final Quantity weight) {
            b.add(PROPERTY_WEIGHT, weight);
            return this;
        }

        public Builder nominalVolume(final Quantity nominalVolume) {
            b.add(PROPERTY_NOMINALVOLUME, nominalVolume);
            return this;
        }

        public Builder externalDiameter(final Quantity externalDiameter) {
            b.add(PROPERTY_EXTERNALDIAMETER, externalDiameter);
            return this;
        }

        public Builder shape(final String shape) {
            b.add(PROPERTY_SHAPE, shape);
            return this;
        }

        public Builder color(final java.util.List<String> color) {
            b.add(PROPERTY_COLOR, FhirObject.toStringArray(color));
            return this;
        }

        public Builder imprint(final java.util.List<String> imprint) {
            b.add(PROPERTY_IMPRINT, FhirObject.toStringArray(imprint));
            return this;
        }

        public Builder image(final java.util.List<Attachment> image) {
            b.add(PROPERTY_IMAGE, FhirObject.toArray(image));
            return this;
        }

        public Builder scoring(final CodeableConcept scoring) {
            b.add(PROPERTY_SCORING, scoring);
            return this;
        }

        public ProdCharacteristic build() {
            return new ProdCharacteristic(b.build());
        }
    }
}
