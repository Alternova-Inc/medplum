/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.types;

import java.time.Instant;

import jakarta.json.Json;
import jakarta.json.JsonObject;
import jakarta.json.JsonObjectBuilder;

public class Immunization extends FhirResource {
    public static final String RESOURCE_TYPE = "Immunization";
    public static final String PROPERTY_RESOURCETYPE = "resourceType";
    public static final String PROPERTY_ID = "id";
    public static final String PROPERTY_META = "meta";
    public static final String PROPERTY_IMPLICITRULES = "implicitRules";
    public static final String PROPERTY_LANGUAGE = "language";
    public static final String PROPERTY_TEXT = "text";
    public static final String PROPERTY_CONTAINED = "contained";
    public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
    public static final String PROPERTY_IDENTIFIER = "identifier";
    public static final String PROPERTY_STATUS = "status";
    public static final String PROPERTY_STATUSREASON = "statusReason";
    public static final String PROPERTY_VACCINECODE = "vaccineCode";
    public static final String PROPERTY_PATIENT = "patient";
    public static final String PROPERTY_ENCOUNTER = "encounter";
    public static final String PROPERTY_OCCURRENCEDATETIME = "occurrenceDateTime";
    public static final String PROPERTY_OCCURRENCESTRING = "occurrenceString";
    public static final String PROPERTY_RECORDED = "recorded";
    public static final String PROPERTY_PRIMARYSOURCE = "primarySource";
    public static final String PROPERTY_REPORTORIGIN = "reportOrigin";
    public static final String PROPERTY_LOCATION = "location";
    public static final String PROPERTY_MANUFACTURER = "manufacturer";
    public static final String PROPERTY_LOTNUMBER = "lotNumber";
    public static final String PROPERTY_EXPIRATIONDATE = "expirationDate";
    public static final String PROPERTY_SITE = "site";
    public static final String PROPERTY_ROUTE = "route";
    public static final String PROPERTY_DOSEQUANTITY = "doseQuantity";
    public static final String PROPERTY_PERFORMER = "performer";
    public static final String PROPERTY_NOTE = "note";
    public static final String PROPERTY_REASONCODE = "reasonCode";
    public static final String PROPERTY_REASONREFERENCE = "reasonReference";
    public static final String PROPERTY_ISSUBPOTENT = "isSubpotent";
    public static final String PROPERTY_SUBPOTENTREASON = "subpotentReason";
    public static final String PROPERTY_EDUCATION = "education";
    public static final String PROPERTY_PROGRAMELIGIBILITY = "programEligibility";
    public static final String PROPERTY_FUNDINGSOURCE = "fundingSource";
    public static final String PROPERTY_REACTION = "reaction";
    public static final String PROPERTY_PROTOCOLAPPLIED = "protocolApplied";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Immunization(final JsonObject data) {
        super(data);
    }

    /**
     * A reference to a set of rules that were followed when the resource was constructed, and which must be understood when processing the content. Often, this is a reference to an implementation guide that defines the special rules along with other profiles etc.
     */
    public String implicitRules() {
        return getString(PROPERTY_IMPLICITRULES);
    }

    /**
     * The base language in which the resource is written.
     */
    public String language() {
        return getString(PROPERTY_LANGUAGE);
    }

    /**
     * A human-readable narrative that contains a summary of the resource and can be used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. Resource definitions may define what content should be represented in the narrative to ensure clinical safety.
     */
    public Narrative text() {
        return getObject(Narrative.class, PROPERTY_TEXT);
    }

    /**
     * These resources do not have an independent existence apart from the resource that contains them - they cannot be identified independently, and nor can they have their own independent transaction scope.
     */
    public java.util.List<FhirResource> contained() {
        return getList(FhirResource.class, PROPERTY_CONTAINED);
    }

    /**
     * May be used to represent additional information that is not part of the basic definition of the resource and that modifies the understanding of the element that contains it and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer is allowed to define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
    }

    /**
     * A unique identifier assigned to this immunization record.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, PROPERTY_IDENTIFIER);
    }

    /**
     * Indicates the current status of the immunization event.
     */
    public String status() {
        return getString(PROPERTY_STATUS);
    }

    /**
     * Indicates the reason the immunization event was not performed.
     */
    public CodeableConcept statusReason() {
        return getObject(CodeableConcept.class, PROPERTY_STATUSREASON);
    }

    /**
     * Vaccine that was administered or was to be administered.
     */
    public CodeableConcept vaccineCode() {
        return getObject(CodeableConcept.class, PROPERTY_VACCINECODE);
    }

    /**
     * The patient who either received or did not receive the immunization.
     */
    public Reference patient() {
        return getObject(Reference.class, PROPERTY_PATIENT);
    }

    /**
     * The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
     */
    public Reference encounter() {
        return getObject(Reference.class, PROPERTY_ENCOUNTER);
    }

    /**
     * Date vaccine administered or was to be administered.
     */
    public String occurrenceDateTime() {
        return getString(PROPERTY_OCCURRENCEDATETIME);
    }

    /**
     * Date vaccine administered or was to be administered.
     */
    public String occurrenceString() {
        return getString(PROPERTY_OCCURRENCESTRING);
    }

    /**
     * The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
     */
    public java.time.Instant recorded() {
        return java.time.Instant.parse(data.getString(PROPERTY_RECORDED));
    }

    /**
     * An indication that the content of the record is based on information from the person who administered the vaccine. This reflects the context under which the data was originally recorded.
     */
    public Boolean primarySource() {
        return data.getBoolean(PROPERTY_PRIMARYSOURCE);
    }

    /**
     * The source of the data when the report of the immunization event is not based on information from the person who administered the vaccine.
     */
    public CodeableConcept reportOrigin() {
        return getObject(CodeableConcept.class, PROPERTY_REPORTORIGIN);
    }

    /**
     * The service delivery location where the vaccine administration occurred.
     */
    public Reference location() {
        return getObject(Reference.class, PROPERTY_LOCATION);
    }

    /**
     * Name of vaccine manufacturer.
     */
    public Reference manufacturer() {
        return getObject(Reference.class, PROPERTY_MANUFACTURER);
    }

    /**
     * Lot number of the  vaccine product.
     */
    public String lotNumber() {
        return getString(PROPERTY_LOTNUMBER);
    }

    /**
     * Date vaccine batch expires.
     */
    public java.time.Instant expirationDate() {
        return java.time.Instant.parse(data.getString(PROPERTY_EXPIRATIONDATE));
    }

    /**
     * Body site where vaccine was administered.
     */
    public CodeableConcept site() {
        return getObject(CodeableConcept.class, PROPERTY_SITE);
    }

    /**
     * The path by which the vaccine product is taken into the body.
     */
    public CodeableConcept route() {
        return getObject(CodeableConcept.class, PROPERTY_ROUTE);
    }

    /**
     * The quantity of vaccine product that was administered.
     */
    public Quantity doseQuantity() {
        return getObject(Quantity.class, PROPERTY_DOSEQUANTITY);
    }

    /**
     * Indicates who performed the immunization event.
     */
    public java.util.List<ImmunizationPerformer> performer() {
        return getList(ImmunizationPerformer.class, PROPERTY_PERFORMER);
    }

    /**
     * Extra information about the immunization that is not conveyed by the other attributes.
     */
    public java.util.List<Annotation> note() {
        return getList(Annotation.class, PROPERTY_NOTE);
    }

    /**
     * Reasons why the vaccine was administered.
     */
    public java.util.List<CodeableConcept> reasonCode() {
        return getList(CodeableConcept.class, PROPERTY_REASONCODE);
    }

    /**
     * Condition, Observation or DiagnosticReport that supports why the immunization was administered.
     */
    public java.util.List<Reference> reasonReference() {
        return getList(Reference.class, PROPERTY_REASONREFERENCE);
    }

    /**
     * Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent.
     */
    public Boolean isSubpotent() {
        return data.getBoolean(PROPERTY_ISSUBPOTENT);
    }

    /**
     * Reason why a dose is considered to be subpotent.
     */
    public java.util.List<CodeableConcept> subpotentReason() {
        return getList(CodeableConcept.class, PROPERTY_SUBPOTENTREASON);
    }

    /**
     * Educational material presented to the patient (or guardian) at the time of vaccine administration.
     */
    public java.util.List<ImmunizationEducation> education() {
        return getList(ImmunizationEducation.class, PROPERTY_EDUCATION);
    }

    /**
     * Indicates a patient's eligibility for a funding program.
     */
    public java.util.List<CodeableConcept> programEligibility() {
        return getList(CodeableConcept.class, PROPERTY_PROGRAMELIGIBILITY);
    }

    /**
     * Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).
     */
    public CodeableConcept fundingSource() {
        return getObject(CodeableConcept.class, PROPERTY_FUNDINGSOURCE);
    }

    /**
     * Categorical data indicating that an adverse event is associated in time to an immunization.
     */
    public java.util.List<ImmunizationReaction> reaction() {
        return getList(ImmunizationReaction.class, PROPERTY_REACTION);
    }

    /**
     * The protocol (set of recommendations) being followed by the provider who administered the dose.
     */
    public java.util.List<ImmunizationProtocolApplied> protocolApplied() {
        return getList(ImmunizationProtocolApplied.class, PROPERTY_PROTOCOLAPPLIED);
    }

    public static class Builder extends FhirResource.Builder {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder resourceType(final String resourceType) {
            b.add(PROPERTY_RESOURCETYPE, resourceType);
            return this;
        }

        public Builder id(final String id) {
            b.add(PROPERTY_ID, id);
            return this;
        }

        public Builder meta(final Meta meta) {
            b.add(PROPERTY_META, meta);
            return this;
        }

        public Builder implicitRules(final String implicitRules) {
            b.add(PROPERTY_IMPLICITRULES, implicitRules);
            return this;
        }

        public Builder language(final String language) {
            b.add(PROPERTY_LANGUAGE, language);
            return this;
        }

        public Builder text(final Narrative text) {
            b.add(PROPERTY_TEXT, text);
            return this;
        }

        public Builder contained(final java.util.List<FhirResource> contained) {
            b.add(PROPERTY_CONTAINED, FhirObject.toArray(contained));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder status(final String status) {
            b.add(PROPERTY_STATUS, status);
            return this;
        }

        public Builder statusReason(final CodeableConcept statusReason) {
            b.add(PROPERTY_STATUSREASON, statusReason);
            return this;
        }

        public Builder vaccineCode(final CodeableConcept vaccineCode) {
            b.add(PROPERTY_VACCINECODE, vaccineCode);
            return this;
        }

        public Builder patient(final Reference patient) {
            b.add(PROPERTY_PATIENT, patient);
            return this;
        }

        public Builder encounter(final Reference encounter) {
            b.add(PROPERTY_ENCOUNTER, encounter);
            return this;
        }

        public Builder occurrenceDateTime(final String occurrenceDateTime) {
            b.add(PROPERTY_OCCURRENCEDATETIME, occurrenceDateTime);
            return this;
        }

        public Builder occurrenceString(final String occurrenceString) {
            b.add(PROPERTY_OCCURRENCESTRING, occurrenceString);
            return this;
        }

        public Builder recorded(final java.time.Instant recorded) {
            b.add(PROPERTY_RECORDED, recorded.toString());
            return this;
        }

        public Builder primarySource(final Boolean primarySource) {
            b.add(PROPERTY_PRIMARYSOURCE, primarySource);
            return this;
        }

        public Builder reportOrigin(final CodeableConcept reportOrigin) {
            b.add(PROPERTY_REPORTORIGIN, reportOrigin);
            return this;
        }

        public Builder location(final Reference location) {
            b.add(PROPERTY_LOCATION, location);
            return this;
        }

        public Builder manufacturer(final Reference manufacturer) {
            b.add(PROPERTY_MANUFACTURER, manufacturer);
            return this;
        }

        public Builder lotNumber(final String lotNumber) {
            b.add(PROPERTY_LOTNUMBER, lotNumber);
            return this;
        }

        public Builder expirationDate(final java.time.Instant expirationDate) {
            b.add(PROPERTY_EXPIRATIONDATE, expirationDate.toString());
            return this;
        }

        public Builder site(final CodeableConcept site) {
            b.add(PROPERTY_SITE, site);
            return this;
        }

        public Builder route(final CodeableConcept route) {
            b.add(PROPERTY_ROUTE, route);
            return this;
        }

        public Builder doseQuantity(final Quantity doseQuantity) {
            b.add(PROPERTY_DOSEQUANTITY, doseQuantity);
            return this;
        }

        public Builder performer(final java.util.List<ImmunizationPerformer> performer) {
            b.add(PROPERTY_PERFORMER, FhirObject.toArray(performer));
            return this;
        }

        public Builder note(final java.util.List<Annotation> note) {
            b.add(PROPERTY_NOTE, FhirObject.toArray(note));
            return this;
        }

        public Builder reasonCode(final java.util.List<CodeableConcept> reasonCode) {
            b.add(PROPERTY_REASONCODE, FhirObject.toArray(reasonCode));
            return this;
        }

        public Builder reasonReference(final java.util.List<Reference> reasonReference) {
            b.add(PROPERTY_REASONREFERENCE, FhirObject.toArray(reasonReference));
            return this;
        }

        public Builder isSubpotent(final Boolean isSubpotent) {
            b.add(PROPERTY_ISSUBPOTENT, isSubpotent);
            return this;
        }

        public Builder subpotentReason(final java.util.List<CodeableConcept> subpotentReason) {
            b.add(PROPERTY_SUBPOTENTREASON, FhirObject.toArray(subpotentReason));
            return this;
        }

        public Builder education(final java.util.List<ImmunizationEducation> education) {
            b.add(PROPERTY_EDUCATION, FhirObject.toArray(education));
            return this;
        }

        public Builder programEligibility(final java.util.List<CodeableConcept> programEligibility) {
            b.add(PROPERTY_PROGRAMELIGIBILITY, FhirObject.toArray(programEligibility));
            return this;
        }

        public Builder fundingSource(final CodeableConcept fundingSource) {
            b.add(PROPERTY_FUNDINGSOURCE, fundingSource);
            return this;
        }

        public Builder reaction(final java.util.List<ImmunizationReaction> reaction) {
            b.add(PROPERTY_REACTION, FhirObject.toArray(reaction));
            return this;
        }

        public Builder protocolApplied(final java.util.List<ImmunizationProtocolApplied> protocolApplied) {
            b.add(PROPERTY_PROTOCOLAPPLIED, FhirObject.toArray(protocolApplied));
            return this;
        }

        public Immunization build() {
            return new Immunization(b.build());
        }
    }

    public static class ImmunizationEducation extends FhirObject {
        public static final String RESOURCE_TYPE = "ImmunizationEducation";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_DOCUMENTTYPE = "documentType";
        public static final String PROPERTY_REFERENCE = "reference";
        public static final String PROPERTY_PUBLICATIONDATE = "publicationDate";
        public static final String PROPERTY_PRESENTATIONDATE = "presentationDate";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ImmunizationEducation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Identifier of the material presented to the patient.
         */
        public String documentType() {
            return getString(PROPERTY_DOCUMENTTYPE);
        }

        /**
         * Reference pointer to the educational material given to the patient if the information was on line.
         */
        public String reference() {
            return getString(PROPERTY_REFERENCE);
        }

        /**
         * Date the educational material was published.
         */
        public java.time.Instant publicationDate() {
            return java.time.Instant.parse(data.getString(PROPERTY_PUBLICATIONDATE));
        }

        /**
         * Date the educational material was given to the patient.
         */
        public java.time.Instant presentationDate() {
            return java.time.Instant.parse(data.getString(PROPERTY_PRESENTATIONDATE));
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder documentType(final String documentType) {
                b.add(PROPERTY_DOCUMENTTYPE, documentType);
                return this;
            }

            public Builder reference(final String reference) {
                b.add(PROPERTY_REFERENCE, reference);
                return this;
            }

            public Builder publicationDate(final java.time.Instant publicationDate) {
                b.add(PROPERTY_PUBLICATIONDATE, publicationDate.toString());
                return this;
            }

            public Builder presentationDate(final java.time.Instant presentationDate) {
                b.add(PROPERTY_PRESENTATIONDATE, presentationDate.toString());
                return this;
            }

            public ImmunizationEducation build() {
                return new ImmunizationEducation(b.build());
            }
        }
    }

    public static class ImmunizationPerformer extends FhirObject {
        public static final String RESOURCE_TYPE = "ImmunizationPerformer";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_FUNCTION = "function";
        public static final String PROPERTY_ACTOR = "actor";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ImmunizationPerformer(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Describes the type of performance (e.g. ordering provider, administering provider, etc.).
         */
        public CodeableConcept function() {
            return getObject(CodeableConcept.class, PROPERTY_FUNCTION);
        }

        /**
         * The practitioner or organization who performed the action.
         */
        public Reference actor() {
            return getObject(Reference.class, PROPERTY_ACTOR);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder function(final CodeableConcept function) {
                b.add(PROPERTY_FUNCTION, function);
                return this;
            }

            public Builder actor(final Reference actor) {
                b.add(PROPERTY_ACTOR, actor);
                return this;
            }

            public ImmunizationPerformer build() {
                return new ImmunizationPerformer(b.build());
            }
        }
    }

    public static class ImmunizationProtocolApplied extends FhirObject {
        public static final String RESOURCE_TYPE = "ImmunizationProtocolApplied";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_SERIES = "series";
        public static final String PROPERTY_AUTHORITY = "authority";
        public static final String PROPERTY_TARGETDISEASE = "targetDisease";
        public static final String PROPERTY_DOSENUMBERPOSITIVEINT = "doseNumberPositiveInt";
        public static final String PROPERTY_DOSENUMBERSTRING = "doseNumberString";
        public static final String PROPERTY_SERIESDOSESPOSITIVEINT = "seriesDosesPositiveInt";
        public static final String PROPERTY_SERIESDOSESSTRING = "seriesDosesString";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ImmunizationProtocolApplied(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * One possible path to achieve presumed immunity against a disease - within the context of an authority.
         */
        public String series() {
            return getString(PROPERTY_SERIES);
        }

        /**
         * Indicates the authority who published the protocol (e.g. ACIP) that is being followed.
         */
        public Reference authority() {
            return getObject(Reference.class, PROPERTY_AUTHORITY);
        }

        /**
         * The vaccine preventable disease the dose is being administered against.
         */
        public java.util.List<CodeableConcept> targetDisease() {
            return getList(CodeableConcept.class, PROPERTY_TARGETDISEASE);
        }

        /**
         * Nominal position in a series.
         */
        public Integer doseNumberPositiveInt() {
            return data.getInt(PROPERTY_DOSENUMBERPOSITIVEINT);
        }

        /**
         * Nominal position in a series.
         */
        public String doseNumberString() {
            return getString(PROPERTY_DOSENUMBERSTRING);
        }

        /**
         * The recommended number of doses to achieve immunity.
         */
        public Integer seriesDosesPositiveInt() {
            return data.getInt(PROPERTY_SERIESDOSESPOSITIVEINT);
        }

        /**
         * The recommended number of doses to achieve immunity.
         */
        public String seriesDosesString() {
            return getString(PROPERTY_SERIESDOSESSTRING);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder series(final String series) {
                b.add(PROPERTY_SERIES, series);
                return this;
            }

            public Builder authority(final Reference authority) {
                b.add(PROPERTY_AUTHORITY, authority);
                return this;
            }

            public Builder targetDisease(final java.util.List<CodeableConcept> targetDisease) {
                b.add(PROPERTY_TARGETDISEASE, FhirObject.toArray(targetDisease));
                return this;
            }

            public Builder doseNumberPositiveInt(final Integer doseNumberPositiveInt) {
                b.add(PROPERTY_DOSENUMBERPOSITIVEINT, doseNumberPositiveInt);
                return this;
            }

            public Builder doseNumberString(final String doseNumberString) {
                b.add(PROPERTY_DOSENUMBERSTRING, doseNumberString);
                return this;
            }

            public Builder seriesDosesPositiveInt(final Integer seriesDosesPositiveInt) {
                b.add(PROPERTY_SERIESDOSESPOSITIVEINT, seriesDosesPositiveInt);
                return this;
            }

            public Builder seriesDosesString(final String seriesDosesString) {
                b.add(PROPERTY_SERIESDOSESSTRING, seriesDosesString);
                return this;
            }

            public ImmunizationProtocolApplied build() {
                return new ImmunizationProtocolApplied(b.build());
            }
        }
    }

    public static class ImmunizationReaction extends FhirObject {
        public static final String RESOURCE_TYPE = "ImmunizationReaction";
        public static final String PROPERTY_ID = "id";
        public static final String PROPERTY_MODIFIEREXTENSION = "modifierExtension";
        public static final String PROPERTY_DATE = "date";
        public static final String PROPERTY_DETAIL = "detail";
        public static final String PROPERTY_REPORTED = "reported";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ImmunizationReaction(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references). This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of the basic definition of the element and that modifies the understanding of the element in which it is contained and/or the understanding of the containing element's descendants. Usually modifier elements provide negation or qualification. To make the use of extensions safe and manageable, there is a strict set of governance applied to the definition and use of extensions. Though any implementer can define an extension, there is a set of requirements that SHALL be met as part of the definition of the extension. Applications processing a resource are required to check for modifier extensions.

Modifier extensions SHALL NOT change the meaning of any elements on Resource or DomainResource (including cannot change the meaning of modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, PROPERTY_MODIFIEREXTENSION);
        }

        /**
         * Date of reaction to the immunization.
         */
        public java.time.Instant date() {
            return java.time.Instant.parse(data.getString(PROPERTY_DATE));
        }

        /**
         * Details of the reaction.
         */
        public Reference detail() {
            return getObject(Reference.class, PROPERTY_DETAIL);
        }

        /**
         * Self-reported indicator.
         */
        public Boolean reported() {
            return data.getBoolean(PROPERTY_REPORTED);
        }

        public static class Builder {
            private final JsonObjectBuilder b;

            private Builder() {
                b = Json.createObjectBuilder();
            }

            private Builder(final JsonObject data) {
                b = Json.createObjectBuilder(data);
            }

            public Builder id(final String id) {
                b.add(PROPERTY_ID, id);
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(PROPERTY_MODIFIEREXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(PROPERTY_DATE, date.toString());
                return this;
            }

            public Builder detail(final Reference detail) {
                b.add(PROPERTY_DETAIL, detail);
                return this;
            }

            public Builder reported(final Boolean reported) {
                b.add(PROPERTY_REPORTED, reported);
                return this;
            }

            public ImmunizationReaction build() {
                return new ImmunizationReaction(b.build());
            }
        }
    }
}
